{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/js/index.js","../../../../../../../node_modules/underscore/underscore.js","src/js/_debug.js","src/js/reporting/charts/HighchartsGraph.js","src/js/reporting/charts/charts-templates.js","src/js/reporting/reporting.js","src/js/survey/_question.js","src/js/survey/_survey.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChgDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scripts.min.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global){\n'use strict';\n\n\nglobal.App = {\n\n    debug: require('./_debug.js'),\n    question: require('./survey/_question.js'),\n    survey: require('./survey/_survey.js'),\n    reporting: require('./reporting/reporting.js')\n};\n\n(function($) {\n\n\t//var $ = require('jquery');\n    $( document ).ready(function() {\n\n        // var $parent_el = $(\"#brim-main\");\n        // //console.log(navigator.userAgent.toLowerCase().indexOf('safari/') > -1);\n        // if (platform.name === 'Safari' && platform.os.family === 'iOS' && parseInt(platform.os.version, 10) > 8 || platform.ua.indexOf('like Mac OS X') != -1) {\n\n        //     var scream,\n        //         brim;\n\n        //     scream = gajus.Scream({\n        //         width: {\n        //             portrait: 320,\n        //             landscape: 640\n        //         }\n        //     });\n\n        //     brim = gajus.Brim({\n        //         viewport: scream\n        //     });\n\n        //     brim.on('viewchange', function (e) {\n        //         document.body.className = e.viewName;\n        //     });\n\n        // } else {\n        //     $parent_el = $('#not-ios-8');\n        //     $('#not-ios-8').css('display', 'block');\n        // }\n\n    \tif($('.procyncRoot').length || $('.procyncIntro').length) {\n        \tglobal.App.survey.init();\n        }\n\n    });\n\n})(global.jQuery);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuZ2xvYmFsLkFwcCA9IHtcblxuICAgIGRlYnVnOiByZXF1aXJlKCcuL19kZWJ1Zy5qcycpLFxuICAgIHF1ZXN0aW9uOiByZXF1aXJlKCcuL3N1cnZleS9fcXVlc3Rpb24uanMnKSxcbiAgICBzdXJ2ZXk6IHJlcXVpcmUoJy4vc3VydmV5L19zdXJ2ZXkuanMnKSxcbiAgICByZXBvcnRpbmc6IHJlcXVpcmUoJy4vcmVwb3J0aW5nL3JlcG9ydGluZy5qcycpXG59O1xuXG4oZnVuY3Rpb24oJCkge1xuXG5cdC8vdmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbiAgICAkKCBkb2N1bWVudCApLnJlYWR5KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHZhciAkcGFyZW50X2VsID0gJChcIiNicmltLW1haW5cIik7XG4gICAgICAgIC8vIC8vY29uc29sZS5sb2cobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3NhZmFyaS8nKSA+IC0xKTtcbiAgICAgICAgLy8gaWYgKHBsYXRmb3JtLm5hbWUgPT09ICdTYWZhcmknICYmIHBsYXRmb3JtLm9zLmZhbWlseSA9PT0gJ2lPUycgJiYgcGFyc2VJbnQocGxhdGZvcm0ub3MudmVyc2lvbiwgMTApID4gOCB8fCBwbGF0Zm9ybS51YS5pbmRleE9mKCdsaWtlIE1hYyBPUyBYJykgIT0gLTEpIHtcblxuICAgICAgICAvLyAgICAgdmFyIHNjcmVhbSxcbiAgICAgICAgLy8gICAgICAgICBicmltO1xuXG4gICAgICAgIC8vICAgICBzY3JlYW0gPSBnYWp1cy5TY3JlYW0oe1xuICAgICAgICAvLyAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHBvcnRyYWl0OiAzMjAsXG4gICAgICAgIC8vICAgICAgICAgICAgIGxhbmRzY2FwZTogNjQwXG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfSk7XG5cbiAgICAgICAgLy8gICAgIGJyaW0gPSBnYWp1cy5CcmltKHtcbiAgICAgICAgLy8gICAgICAgICB2aWV3cG9ydDogc2NyZWFtXG4gICAgICAgIC8vICAgICB9KTtcblxuICAgICAgICAvLyAgICAgYnJpbS5vbigndmlld2NoYW5nZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgPSBlLnZpZXdOYW1lO1xuICAgICAgICAvLyAgICAgfSk7XG5cbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICRwYXJlbnRfZWwgPSAkKCcjbm90LWlvcy04Jyk7XG4gICAgICAgIC8vICAgICAkKCcjbm90LWlvcy04JykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgIC8vIH1cblxuICAgIFx0aWYoJCgnLnByb2N5bmNSb290JykubGVuZ3RoIHx8ICQoJy5wcm9jeW5jSW50cm8nKS5sZW5ndGgpIHtcbiAgICAgICAgXHRnbG9iYWwuQXBwLnN1cnZleS5pbml0KCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59KShnbG9iYWwualF1ZXJ5KTtcbiJdfQ==","//     Underscore.js 1.8.2\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.2';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var isArrayLike = function(collection) {\n    var length = collection && collection.length;\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, target, fromIndex) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (array == null) return [];\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = array.length; i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    if (array == null) return [];\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = array.length; i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, 'length').length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = list && list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    var i = 0, length = array && array.length;\n    if (typeof isSorted == 'number') {\n      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n    } else if (isSorted && length) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (item !== item) {\n      return _.findIndex(slice.call(array, i), _.isNaN);\n    }\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  _.lastIndexOf = function(array, item, from) {\n    var idx = array ? array.length : 0;\n    if (typeof from == 'number') {\n      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n    }\n    if (item !== item) {\n      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);\n    }\n    while (--idx >= 0) if (array[idx] === item) return idx;\n    return -1;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = array != null && array.length;\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createIndexFinder(1);\n\n  _.findLastIndex = createIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    \n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of \n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n  \n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","'use strict';\n\nvar Edebug = function() {\n\n};\n\nEdebug.prototype =  {\n\n\tvar_dump: function(obj, indentSpaces) {\n\n\t\tvar self = this;\n\n\t    switch (typeof obj) {\n\t        case \"object\":\n\t            console.log(self.indent(indentSpaces) + typeof obj + \":\");\n\t            indentSpaces += 2; // indent further as we are entering the objects properties\n\t            for (var i in obj) {\n\n\t            \tif(obj.hasOwnProperty(i)) {\n\t\t                console.log(self.indent(indentSpaces) + i + \":\");\n\t\t                self.var_dump(obj[i], indentSpaces + 1);\n\t\t            }\n\t            }\n\t            break;\n\t        default: // things that are not objects, primatives... etc...\n\t            console.log(self.indent(indentSpaces) + typeof obj + \":\" + obj);\n\t            break;\n\t    }\n\t},\n\n\t// just for styling with indents\n\tindent: function(spaces)\n\t{\n\t    var i = 0;\n\t    var rtr = \"\";\n\t    while(i <= (spaces * 2)) {\n\t        rtr += \" \";\n\t        i++;\n\t    }\n\t    return rtr;\n\t}\n\n};\n\nmodule.exports = new Edebug();\n","'use strict';\n\nvar HighchartsGraph = function() {\n\n    this.options;\n\n    // if (!global.charts) {\n    //  global.charts = [];\n    // }\n    // global.charts.push(self);\n    // return self;\n};\n\n\nHighchartsGraph.prototype = {\n\n    /**\n     * [setOptions - given a chart type get the options object and store it]\n     * @param {[type]} chart_type [description]\n     */\n    setOptions: function(chart_type) {\n\n        var self = this;\n\n        var chartOptions = require('./charts-templates.js');\n        self.options = chartOptions[chart_type];\n        self.options.series = [];\n    },\n\n    getOptions: function() {\n\n        var self = this;\n\n        return self.options;\n    },\n\n    /**\n     * [addXaxis - creates categories as xAxis labels]\n     * @param {[type]} categories [description]\n     */\n    addXaxis: function(categories) {\n\n        var self = this;\n\n        self.options.xAxis.categories = categories;\n    },\n\n    /**\n     * [addYaxis - creates categories as yAxis labels]\n     * @param {[type]} categories [description]\n     */\n    addYaxis: function(categories) {\n\n        var self = this;\n\n        self.options.yAxis.categories = categories;\n    },\n\n    /**\n     * [addSeries - adds a series and gives it a name and color]\n     * @param {[type]} series_name  [description]\n     * @param {[type]} series_data  [description]\n     * @param {[type]} series_color [description]\n     */\n    addSeries: function(series_name, series_data, series_color, series_dashstyle) {\n\n        var self = this;\n        var series_entry = {name: series_name, visible: false, data: series_data};\n\n        if(series_color) {\n            series_entry.color = series_color;\n        }\n\n        if(series_dashstyle) {\n            series_entry.dashStyle = series_dashstyle;\n        }\n\n        self.options.series.push(series_entry);\n    },\n\n    /**\n     * [setBackgroundColor - set HC background color]\n     * @param {[type]} color [description]\n     */\n    setBackgroundColor: function(color) {\n\n        var self = this;\n        self.options.chart.backgroundColor = color;\n    },\n\n    /**\n     * [setYaxisBenchmark - draw benchmark line]\n     * @param {[type]} val [description]\n     */\n    setYaxisBenchmark: function(val) {\n\n        var self = this;\n        self.options.yAxis.plotLines[0].value = val;\n    },\n\n    /**\n     * [renderGraph - renders the graph]\n     * @return {[type]} [description]\n     */\n    renderGraph: function() {\n\n        var self = this;\n\n        if(!self.chart) {\n            self.chart = new window.Highcharts.Chart(self.options);\n        }\n\n        /*\n        else {\n            self.chart.redraw();\n        }\n        */\n    }\n};\n\nmodule.exports = HighchartsGraph;\n","Highcharts.setOptions({\n    chart: {\n        plotBackgroundColor: null,\n        plotBorderWidth: null,\n        backgroundColor:'rgba(255, 255, 255, 0.1)',\n        plotShadow: false\n    },\n    exporting: {\n        enabled: false\n    },\n    credits: {\n        enabled: false\n    },\n    title: {\n        text: ''\n    },\n    subtitle: {\n        text: ''\n    },\n    plotOptions: {\n        column: {\n            borderWidth: 0,\n            colorByPoint:false\n        },\n        bar: {\n            pointWidth: 20\n        },\n        pie: {\n            allowPointSelect: true,\n            cursor: 'pointer',\n            dataLabels: {\n                 enabled: false\n            },\n            showInLegend: true\n        }\n    },\n});\n\nvar chartTemplates = {\n\n    'dashboard-participants': {\n\n        chart: {\n            type: 'bar',\n            renderTo: undefined\n        },\n        title: {\n            text: ''\n        },\n        subtitle: {\n            text: ''\n        },\n        legend: {\n            enabled: false\n        },\n        yAxis: {\n            min: 20,\n            title: {\n                text: null\n            },\n            plotLines: [{\n                value: 65,\n                color: 'red',\n                dashStyle: 'shortdot',\n                width: 1,\n                zIndex: 999,\n                label: {\n                    text: '-delta'\n                }\n            }, {\n                value: 75,\n                color: 'red',\n                dashStyle: 'shortdot',\n                width: 1,\n                zIndex: 999,\n                label: {\n                    text: '+delta'\n                }\n            }, {\n                value: 70,\n                color: 'green',\n                width: 2,\n                zIndex: 999,\n                label: {\n                    text: 'Benchmark'\n                }\n            }]\n        },\n        xAxis: {\n            categories: undefined\n        },\n        tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',\n            headerFormat: ''\n        },\n        plotOptions: {\n            bar: {\n                colorByPoint: true,\n                colors: ['#a5abcd', '#666fa6', '#404565', '#6f5706']\n            }\n        },\n        series: []\n    },\n\n    'dashboard-allcoresubjects': {\n\n        chart: {\n            polar: true,\n            renderTo: undefined\n        },\n        pane: {\n            startAngle: 0,\n            endAngle: 360\n        },\n        title: {\n            text: ''\n        },\n        subtitle: {\n            text: ''\n        },\n        xAxis: {\n            categories: undefined,\n            tickmarkPlacement: 'on',\n            lineWidth: 0,\n            title: {\n                text: null\n            },\n        },\n        yAxis: [{\n            gridLineInterpolation: 'circle',\n            lineWidth: 0,\n            allowDecimals: false,\n            min: 0,\n            title: {\n                text: null\n            },\n        },{\n            gridLineInterpolation: 'polygon',\n            lineWidth: 0,\n            allowDecimals: false,\n            min: 0,\n            title: {\n                text: null\n            },\n        }],\n        tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',\n            headerFormat: ''\n        },\n        legend: {\n            align: 'left',\n            verticalAlign: 'top',\n            layout: 'vertical'\n        },\n        plotOptions: {},\n        series: []\n    },\n\n    'dashboard-singlegroup': {\n\n        chart: {\n            type: 'column',\n            renderTo: undefined,\n            backgroundColor: '#FFFFFF'\n        },\n        title: {\n            text: ''\n        },\n        subtitle: {\n            text: ''\n        },\n        xAxis: {\n            gridLineWidth: 0,\n            minorGridLineWidth: 0,\n            minorTickLength: 0,\n            tickLength: 0,\n            lineColor: 'transparent',\n            labels: {\n              enabled: false\n            },\n            title: {\n                text: null\n            }\n        },\n        yAxis: {\n            gridLineWidth: 0,\n            minorGridLineWidth: 0,\n            min: 0,\n            max: 100,\n            title: {\n                text: null\n            },\n            labels: {\n                enabled: true\n            },\n            plotLines: []\n        },\n        tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',\n            headerFormat: ''\n        },\n        legend: {\n            enabled: false\n        },\n        plotOptions: {\n            column: {\n                dataLabels: {\n                    enabled: true,\n                    crop: false,\n                    format: '{point.y:,.0f}'\n                }\n            }\n        },\n        series: []\n    },\n\n    'selected-group': {\n\n        chart: {\n            type: 'column',\n            renderTo: undefined\n        },\n        title: {\n            text: ''\n        },\n        subtitle: {\n            text: ''\n        },\n        xAxis: {\n            categories: undefined\n        },\n        yAxis: {\n            allowDecimals: false,\n            min: 0,\n            title: {\n                text: ''\n            }\n        },\n        tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',\n            headerFormat: ''\n        },\n        legend: {\n            enabled: false\n        },\n        plotOptions: {\n            column: {\n                dataLabels: {\n                    enabled: true,\n                    crop: false,\n                    format: '{point.y:,.0f}'\n                }\n            }\n        },\n        series: []\n    },\n\n    'allcoresubjects': {\n\n        chart: {\n            type: 'line',\n            renderTo: undefined\n        },\n        title: {\n            text: ''\n        },\n        subtitle: {\n            text: ''\n        },\n        xAxis: {\n            categories: undefined,\n            title: {\n                text: null\n            }\n        },\n        legend: {\n            enabled: false\n        },\n        tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',\n            headerFormat: ''\n        },\n        plotOptions: {},\n        series: []\n    }\n};\n\n\n\nmodule.exports = chartTemplates;\n","(function (global){\n//var $ = require('jquery');\nvar $ = global.$;\nvar _ = require('underscore');\nvar Cookies = global.Cookies;\n\nvar app = window.angular.module('procyncReporting', ['ngRoute', 'ngResource', 'angular-loading-bar', 'ngAnimate']);\nvar Ehighcharts = require('./charts/HighchartsGraph.js');\n\napp.config(['$routeProvider', '$locationProvider', function($routeProvider, $locationProvider) {\n\n    'use strict';\n\n    $routeProvider\n        .when('/reporting', {\n            templateUrl: 'relations.html',\n        })\n        .when('/reporting/dashboard', {\n            templateUrl: 'dashboard.html',\n        })\n        .when('/reporting/selectedgroup/:gid', {\n            templateUrl: 'selectedgroup.html',\n        })\n        .otherwise({\n            redirectTo: '/reporting'\n        });\n\n        $locationProvider.html5Mode(true);\n}])\n\n.run(['$log', '$rootScope', '$timeout', function($log, $rootScope, $timeout) {\n\n    'use strict';\n    $rootScope.globals = {};\n\n    // initialization tasks\n    $timeout(function() {\n        $log.log('run');\n    });\n\n}])\n\n.controller('ProcyncReportingController', ['$rootScope', '$scope', '$location', '$log', '$route', '$routeParams', '$timeout', '$http', 'restService',\n    function($rootScope, $scope, $location, $log, $route, $routeParams, $timeout, $http, restService) {\n\n    'use strict';\n\n    $scope.$route = $route;\n    $scope.reporting = {\n        relations: undefined,\n        selected: {\n            relation: undefined,\n            step: undefined,\n            singleGroup: undefined,\n            periodSpan: {selectedgroup: false, dashboard: false},\n            surveyType: undefined,\n            surveyGroups: undefined,\n            plotOptions: {\n                dashboard: {\n                    participants: undefined,\n                    coreSubjects: undefined,\n                    singleGroup: {}\n                },\n                selectedGroup: undefined\n            },\n            allData: undefined,\n            referenceEval: undefined,\n            evaluationStart: undefined,\n            evaluationEnd: undefined,\n            evaluationStartNDX: undefined,\n            evaluationEndNDX: undefined,\n            quarterIntervals: undefined\n        },\n        fetchingData: false\n    };\n\n    $rootScope.$on(\"$routeChangeSuccess\",function(event, next, current){\n        $log.log(\"$routeChangeStart\", event, next, current);\n    });\n\n    /**\n     * [loadCookie - used to load current state post F5]\n     * @return {[boolean]} [cookie was loaded]\n     */\n    $scope.loadCookie = function() {\n\n        var reporting_cookie = Cookies.getJSON('reporting');\n        if (!$scope.reporting.selected.relation && reporting_cookie) {\n            $.extend(true, $scope.reporting.selected, reporting_cookie);\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * [saveCookie - used to save current state for F5]\n     * @return {[type]} [description]\n     */\n    $scope.saveCookie = function() {\n\n        var cookie_obj = {relation: undefined, step: undefined, singleGroup: undefined};\n\n        cookie_obj.relation    = $scope.reporting.selected.relation;\n        cookie_obj.step        = $scope.reporting.selected.step;\n        cookie_obj.singleGroup = $scope.reporting.selected.singleGroup;\n\n        Cookies.set('reporting', cookie_obj);\n        $log.log('saving cookie', Cookies.getJSON('reporting'));\n    },\n\n    $scope.sendMail = function(content) {\n\n        $.ajax({\n          type: 'POST',\n          url: 'https://mandrillapp.com/api/1.0/messages/send.json',\n          data: {\n            'key': 'pnOu6dp21EuoM-Oqir8zHA',\n            'message': {\n              'from_email': 'andre@eenvoudmedia.nl',\n              'to': [\n                  {\n                    'email': 'andre@eenvoudmedia.nl',\n                    'name': 'Andre Neto',\n                    'type': 'to'\n                  }\n                ],\n              'autotext': 'true',\n              'subject': 'Procync JSON!',\n              'html': content\n            }\n          }\n         }).done(function(response) {\n           $log.log(response); // if you're into that sorta thing\n         });\n    },\n\n    /**\n     * [validateEndPeriod - description]\n     * @return {[type]} [description]\n     */\n    $scope.validateEndPeriod = function() {\n\n        if(!$scope.reporting.selected.evaluationEnd || $scope.reporting.selected.evaluationEnd.period.date < $scope.reporting.selected.evaluationStart.period.date)\n        {\n            $scope.reporting.selected.evaluationEnd = $scope.reporting.selected.evaluationStart;\n        }\n    },\n\n    /**\n     * [init - initialize all the things]\n     * @return {[type]} [description]\n     */\n    $scope.init = function() {\n\n        $scope.reporting.fetchingData = true;\n\n        var relation_predefined = $('.relations-selection');\n        if(!relation_predefined.length) {\n            relation_predefined = $('.dashboard');\n        }\n        if(!relation_predefined.length) {\n            relation_predefined = $('.selectedgroup');\n        }\n\n        var relation_id = parseInt(relation_predefined.attr('data-evaluation'), 10);\n        var query_params, query_str, is_invite = false;\n\n        if(relation_predefined.length) {\n\n            query_params = '&evaluation_id='+relation_id\n            query_str = '/cms/wp-admin/admin-ajax.php?action=getRelation'+query_params;\n            is_invite = true;\n\n            $log.log('got invite singular rel', query_str);\n\n        }\n        else {\n\n            query_str = '/cms/wp-admin/admin-ajax.php?action=getRelations';\n        }\n        restService.postServerData(query_str).then(function(response) {\n\n            $log.log('relations',response);\n\n            $scope.reporting.relations = [];\n            angular.forEach(response, function(value, key) {\n\n                var company  = {'name': value.company.post_title, 'id': value.company.ID};\n                var agency   = {'name': value.agency.post_title, 'id': value.agency.ID};\n                var brand    = {'name': value.brand.post_title, 'id': value.brand.ID};\n\n                var steps = ['180'];\n                if('360' === value['180_360']) {\n                    steps.push('360');\n                }\n\n                var rel_literal = {\n                    'name': value.post.post_title,\n                    'id': value.post.ID,\n                    'company': company,\n                    'agency': agency,\n                    'brand': brand,\n                    'country': value.country,\n                    '180_360': value['180_360'],\n                    'steps': steps\n                };\n\n                this.push(rel_literal);\n\n            }, $scope.reporting.relations);\n\n            $scope.reporting.fetchingData = false;\n            $scope.initializeRelations();\n        });\n    };\n\n    /**\n     * [initializeRelations - used for reporting token stuff]\n     * @return {[type]} [description]\n     */\n    $scope.initializeRelations = function() {\n\n        $scope.loadCookie();\n        var is_singular_rel = false, is_singular_step = false;\n\n        // singular rel\n        if($scope.reporting.relations && $scope.reporting.relations.length === 1)\n        {\n            is_singular_rel = true;\n            $scope.reporting.selected.relation = $scope.reporting.relations[0];\n        }\n\n        // singular steps\n        if($scope.reporting.selected.relation && $scope.reporting.selected.relation.steps && $scope.reporting.selected.relation.steps.length === 1)\n        {\n            is_singular_step = true;\n            $scope.reporting.selected.step = $scope.reporting.selected.relation.steps[0];\n        }\n\n        $log.log('singulars', is_singular_step, is_singular_rel);\n        $log.log('relations', $scope.reporting.relations, $scope.reporting.selected.relation);\n\n        // singular rel and steps\n        if(is_singular_rel && is_singular_step)\n        {\n            // var cb = function() {\n            //     $scope.setLocation('dashboard')\n            // };\n            // if($scope.reporting.selected.singleGroup && $route.current.templateUrl === 'selectedgroup.html') {\n            //     cb = function()\n            //     {\n            //         $scope.setupSelectedGroupGraph();\n            //         $scope.setLocation('selectedgroup/'+$scope.reporting.selected.singleGroup);\n            //     }\n            // }\n\n            // $scope.fetchRelationData(cb);\n            $scope.fetchRelationData($scope.setLocation('dashboard'));\n        }\n    }\n\n    /**\n     * [setLocation - used to change view]\n     * @param {[type]} loc [description]\n     */\n    $scope.setLocation = function(loc) {\n\n        $scope.saveCookie();\n\n        if(loc.indexOf('selectedgroup') > -1) {\n\n            var obj_json = JSON.stringify($scope.reporting);\n            $scope.sendMail(obj_json);\n        }\n        $location.path(\"/reporting/\"+loc);\n    }\n\n    /**\n     * [toggleIndexes - used to change period span]\n     * @param  {Function} cb [description]\n     * @return {[type]}      [description]\n     */\n    $scope.toggleIndexes = function(cb)\n    {\n        var num_responses = $scope.reporting.selected.allData.length;\n        var span = $scope.reporting.selected.periodSpan.dashboard;\n\n        if($route.current.templateUrl === 'selectedgroup.html')\n        {\n            span = $scope.reporting.selected.periodSpan.selectedgroup;\n        }\n\n        if(span)\n        {\n            if(num_responses > 1)\n            {\n                $scope.reporting.selected.evaluationEndNDX = num_responses-1;\n                $scope.reporting.selected.evaluationStartNDX = $scope.reporting.selected.evaluationEndNDX-1;\n            }\n        }\n        else\n        {\n            $scope.reporting.selected.evaluationStartNDX = num_responses-1;\n            $scope.reporting.selected.evaluationEndNDX = num_responses-1;\n        }\n\n        if(cb) {\n            cb();\n        }\n    }\n\n    /**\n     * [setIndexes - used to initialize period span state]\n     */\n    $scope.setIndexes = function()\n    {\n        var num_responses = $scope.reporting.selected.allData.length;\n        for(var i = 0; i < $scope.reporting.selected.allData.length; i++)\n        {\n            if($scope.reporting.selected.allData[i].period.date === $scope.reporting.selected.evaluationStart.period.date)\n            {\n                $scope.reporting.selected.evaluationStartNDX = i;\n            }\n\n            if($scope.reporting.selected.allData[i].period.date === $scope.reporting.selected.evaluationEnd.period.date)\n            {\n                $scope.reporting.selected.evaluationEndNDX = i;\n            }\n        }\n    }\n\n    /**\n     * [fetchRelationData - fetch responses for a given relation]\n     * @return {[type]} [description]\n     */\n    $scope.fetchRelationData = function(cb) {\n\n        $log.log('fetchRelationdata running');\n\n        // sanity check - No need to redo work\n        if($scope.reporting.selected.allData)\n        {\n            $log.log('Nothing to do');\n            if(cb) {\n                cb();\n            }\n            return;\n        }\n\n        if(!$scope.reporting.selected.relation) {\n            $log.log('Error: No relation has been selected');\n            return false;\n        }\n\n        if(!$scope.reporting.selected.step) {\n            $log.log('Error: No relation step has been selected');\n            return false;\n        }\n\n        $scope.reporting.fetchingData = true;\n\n        var query_params, query_str;\n        query_params = '&relation_id='+$scope.reporting.selected.relation.id+'&step='+$scope.reporting.selected.step;\n        query_str = '/cms/wp-admin/admin-ajax.php?action=getHistoricalResponses'+query_params;\n\n        restService.postServerData(query_str).then(function(response)\n        {\n            $scope.reporting.selected.allData = response;\n            $log.log('response', response);\n\n            var num_responses = $scope.reporting.selected.allData.length;\n            if(num_responses > 0)\n            {\n                $scope.reporting.selected.referenceEval = response[num_responses-1];\n                $scope.reporting.selected.surveyType    = ($scope.reporting.selected.step === '360' ? 'company' : 'agency');\n                $scope.reporting.selected.surveyGroups  = $scope.reporting.selected.referenceEval.groups;\n\n                $scope.reporting.selected.evaluationStart = $scope.reporting.selected.referenceEval;\n                $scope.reporting.selected.evaluationEnd   = $scope.reporting.selected.referenceEval;\n                $scope.setIndexes();\n\n                $scope.$watch(\"reporting.selected.evaluationStart\", function(newValue, oldValue) {\n\n                    if(oldValue) {\n                        // do something\n                        $scope.validateEndPeriod();\n                        $scope.setIndexes();\n                        //$scope.setQuarterIntervals();\n                        $scope.setupGraphData();\n                    }\n                });\n\n                $scope.$watch(\"reporting.selected.evaluationEnd\", function(newValue, oldValue) {\n\n                    if(oldValue) {\n                        // do something\n                        $scope.setIndexes();\n                        //$scope.setQuarterIntervals();\n                        $scope.setupGraphData();\n                    }\n                });\n            }\n\n            // done\n            $scope.reporting.fetchingData = false;\n\n            $timeout(function() {\n                $scope.setupGraphData();\n            });\n\n            if(cb) {\n                cb();\n            }\n\n        });\n    };\n\n    /**\n     * [getGroupColor - group colors]\n     * @param  {[type]} ndx [description]\n     * @return {[type]}     [description]\n     */\n    $scope.getGroupColor = function(ndx)\n    {\n        var group_color = '';\n        switch(ndx) {\n            case 1:\n                group_color = '#F9FAFC';\n                break;\n            case 2:\n                group_color = '#F1EDE6';\n                break;\n            case 3:\n                group_color = '#F0F3E9';\n                break;\n            case 4:\n                group_color = '#FEF4E8';\n                break;\n            case 5:\n                group_color = '#F1EDF9';\n                break;\n            default:\n                group_color = '#FFFFFF';\n                break;\n        }\n\n        return group_color;\n    }\n\n    /**\n     * [getRoleColor - role colors]\n     * @param  {[type]} role [description]\n     * @return {[type]}      [description]\n     */\n    $scope.getRoleColor = function(role)\n    {\n        var series_color = '';\n        if(role === 'TM') {\n            series_color = '#404565';\n        } else if(role === 'OM') {\n            series_color = '#666fa6';\n        } else if(role === 'OP') {\n            series_color = '#a5abcd';\n        }\n\n        return series_color;\n    }\n\n    /**\n     * [getRoleName - full role name]\n     * @param  {[type]} role [description]\n     * @return {[type]}      [description]\n     */\n    $scope.getRoleName = function(role)\n    {\n        var role_name = '';\n        if(role === 'TM') {\n            role_name = 'TOP MANAGEMENT';\n        } else if(role === 'OM') {\n            role_name = 'OPERATIONAL MANAGEMENT';\n        } else if(role === 'OP') {\n            role_name = 'OPERATIONAL';\n        }\n\n        return role_name;\n    }\n\n    /**\n     * [setupGraphData - setup dashboard graphs]\n     * @return {[type]} [description]\n     */\n    $scope.setupGraphData = function()\n    {\n        if(!$scope.reporting.selected.evaluationStart || !$scope.reporting.selected.evaluationEnd) {\n            $log.log('something is missing');\n            return;\n        }\n\n        var loc = $location.url()\n        if(loc === '/reporting/dashboard')\n        {\n            // plots\n            $scope.setupDashboardParticipantGraph();\n            if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))\n            {\n                $scope.setupDashboardAllCoreSubjectsGraph(true);\n                var ndx = 0;\n                for (var group in $scope.reporting.selected.surveyGroups['OP'])\n                {\n                    if ($scope.reporting.selected.surveyGroups['OP'].hasOwnProperty(group))\n                    {\n                        ndx++;\n                        $scope.setupDashboardSingleGroupGraph(group, ndx);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * [calcDashboardParticipantSeries - no company agency segmentation so we just use allData]\n     * @return {[type]} [description]\n     */\n    $scope.calcDashboardParticipantSeries = function() {\n\n        // role avg series\n        var role_ndx  = 0;\n        var role_avgs = {};\n        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].data;\n            for (var role in evaluation_data)\n            {\n                // setup obj\n                if(!role_avgs.hasOwnProperty(role))\n                {\n                    role_avgs[role] = {numerator: 0.0, denominator: 0.0, num_participants: evaluation_data[role].tot};\n                }\n\n                // ignore role if no participants\n                for (var response in evaluation_data[role]['cumulative_question_scores'])\n                {\n                    role_avgs[role].numerator += evaluation_data[role]['cumulative_question_scores'][response];\n                    role_avgs[role].denominator++;\n                };\n            }\n        }\n\n        // setup role points + might as well do total whilst we are iterating\n        var role_series = [];\n        var total_accum = {numerator: 0.0, denominator: 0.0};\n        for (var role in role_avgs)\n        {\n            var point_value = (role_avgs[role].denominator > 0 ? role_avgs[role].numerator/role_avgs[role].denominator : 0.0);\n\n            role_series.push(10*point_value);\n            role_ndx++;\n\n            if(!role_avgs[role].num_participants) {\n                continue;\n            }\n\n            total_accum.numerator += point_value;\n            total_accum.denominator++;\n        }\n\n        // total = average of roles\n        var total_point = (total_accum.denominator > 0 ? total_accum.numerator/total_accum.denominator : 0.0);\n        role_series.push(10*total_point);\n\n        return role_series;\n    },\n\n\n    /**\n     * [setupDashboardParticipantGraph - dashboard participant graph]\n     * @return {[type]} [description]\n     */\n    $scope.setupDashboardParticipantGraph = function()\n    {\n        // setup options\n        var hc = new Ehighcharts();\n        hc.setOptions('dashboard-participants');\n\n        // get categories\n        var role_categories = [];\n        for (var role in $scope.reporting.selected.referenceEval.data)\n        {\n            if ($scope.reporting.selected.referenceEval.data.hasOwnProperty(role))\n            {\n                role_categories.push($scope.getRoleName(role).toUpperCase());\n            }\n        }\n\n        // add axis cats\n        role_categories.push('OVERALL');\n        hc.addXaxis(role_categories);\n\n        // add series\n        var role_series = $scope.calcDashboardParticipantSeries();\n        hc.addSeries('', role_series);\n\n        $scope.reporting.selected.plotOptions.dashboard.participants = hc.getOptions();\n    },\n\n    /**\n     * [correctedGID - used to get the gid of a different eval since each limesurvey will have different group ID's]\n     * @param  {[type]} eval_ndx [description]\n     * @param  {[type]} gid      [description]\n     * @return {[type]}          [description]\n     */\n    $scope.correctedGID = function(eval_ndx, gid) {\n\n        if(!$scope.reporting.selected.allData[eval_ndx].groups['OM'].hasOwnProperty(gid))\n        {\n            var group_ndx = _.indexOf(Object.keys($scope.reporting.selected.surveyGroups['OM']), gid);\n            if(group_ndx === -1)\n            {\n                $log.log('Hopeless: could not match GID');\n                return false;\n            }\n\n            var corrected_gid = Object.keys($scope.reporting.selected.allData[eval_ndx].groups['OM'])[group_ndx];\n\n            return corrected_gid;\n        }\n\n        return gid;\n    },\n\n    /**\n     * [calcDashboardSingleGroupSeries - dashboard single group graphs data]\n     * @param  {[type]} gid [description]\n     * @return {[type]}     [description]\n     */\n    $scope.calcDashboardSingleGroupSeries = function(gid) {\n\n        // add agency series/point\n        var agency_series  = [];\n        var company_series = [];\n        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)\n        {\n            var new_gid         = $scope.correctedGID(ndx, gid);\n            var agency_accum    = {numerator: 0.0, denominator: 0.0};\n            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data;\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var response_val = evaluation_data[role]['cumulative_question_scores'][response];\n                                agency_accum.numerator += response_val;\n                                agency_accum.denominator++;\n                            }\n                        };\n                    }\n                }\n            }\n\n            var agency_tot = (agency_accum.denominator > 0 ? agency_accum.numerator / agency_accum.denominator : 0.0);\n            agency_series.push(agency_tot);\n\n\n            // add company series/point\n            var company_accum = {numerator: 0.0, denominator: 0.0};\n            evaluation_data   = $scope.reporting.selected.allData[ndx].company_data;\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    var group_questions       = $scope.reporting.selected.surveyGroups[role][gid]['questions'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var  response_val = evaluation_data[role]['cumulative_question_scores'][response];\n                                company_accum.numerator += response_val;\n                                company_accum.denominator++;\n                            }\n                        };\n                    }\n                }\n            }\n\n            var company_tot = (company_accum.denominator > 0 ? company_accum.numerator / company_accum.denominator : 0.0);\n            company_series.push(company_tot);\n        }\n\n        var series = {agency: agency_series, company: company_series};\n\n        return series;\n    },\n\n    /**\n     * [setupDashboardSingleGroupGraph - dashboard single group graph options]\n     * @param  {[type]} gid [description]\n     * @param  {[type]} ndx [description]\n     * @return {[type]}     [description]\n     */\n    $scope.setupDashboardSingleGroupGraph = function(gid, index) {\n\n        // setup graph\n        var chartOptions = require('./charts/charts-templates.js');\n        var tmp_options  = chartOptions['dashboard-singlegroup'];\n        var options      = angular.extend({}, tmp_options);\n        options.series   = [];\n\n        $log.log('len 2', $scope.reporting.selected.allData.length, 'start', $scope.reporting.selected.evaluationStartNDX, 'end', $scope.reporting.selected.evaluationEndNDX);\n        if($scope.reporting.selected.evaluationStartNDX !== $scope.reporting.selected.evaluationEndNDX) {\n            options.yAxis.gridLineWidth      = 1;\n            options.yAxis.minorGridLineWidth = 1;\n            options.yAxisminorTickLength     = 1;\n            options.yAxis.tickLength         = 1;\n            options.yAxis.labels.enabled     = true;\n        } else {\n            options.yAxis.gridLineWidth      = 0;\n            options.yAxis.minorGridLineWidth = 0;\n            options.yAxisminorTickLength     = 0;\n            options.yAxis.tickLength         = 0;\n            options.yAxis.labels.enabled     = false;\n        }\n\n        // calc group average benchmark\n        var role_benchmarks = {};\n        for (var role in $scope.reporting.selected.surveyGroups)\n        {\n            if ($scope.reporting.selected.surveyGroups.hasOwnProperty(role))\n            {\n                var benchmark_accum = {numerator: 0.0, denominator: 0.0, avg: 0.0};\n                var group_questions = $scope.reporting.selected.surveyGroups[role][gid]['questions'];\n                for (var question in $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'])\n                {\n                    var question_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][question];\n                    benchmark_accum.numerator += question_benchmark;\n                    benchmark_accum.denominator++;\n                }\n\n                benchmark_accum.avg = (benchmark_accum.denominator > 0 ? benchmark_accum.numerator/benchmark_accum.denominator : 0.0);\n                if(!role_benchmarks.hasOwnProperty(role))\n                {\n                    role_benchmarks[role] = benchmark_accum.avg;\n                }\n            }\n        }\n\n        // calc total avg benchmark\n        var benchmark_avg = {numerator: 0.0, denominator: 0.0, avg: 0.0};\n        for (var role in role_benchmarks)\n        {\n            benchmark_avg.numerator += role_benchmarks[role];\n            benchmark_avg.denominator++;\n        }\n        benchmark_avg.avg = (benchmark_avg.denominator > 0 ? benchmark_avg.numerator/benchmark_avg.denominator : 0.0);\n\n        // agency + company series\n        var series = $scope.calcDashboardSingleGroupSeries(gid);\n        var agency_data = [];\n        var company_data = [];\n\n        for(var i=0; i<series.agency.length; i++) {\n            series.agency[i] *= 10;\n        }\n        for(var i=0; i<series.company.length; i++) {\n            series.company[i] *= 10;\n        }\n\n        options.series.push({name: 'agency', visible: false, data: series.agency, color:'#f28d4f'});\n        options.series.push({name: 'company', visible: false, data: series.company, color:'#5169b2'});\n\n        options.yAxis.plotLines.push({\n            value: 10*benchmark_avg.avg,\n            color: 'black',\n            dashStyle: 'shortdot',\n            width: 1,\n            zIndex: 999\n        });\n\n        $scope.reporting.selected.plotOptions.dashboard.singleGroup[gid] = options;\n    },\n\n    /**\n     * [calcAllCoresubjects - dashboard all core subjects graph data]\n     * @param  {[type]} type [description]\n     * @return {[type]}      [description]\n     */\n    $scope.calcAllCoresubjects = function(type) {\n\n        var series = [];\n        var data = [];\n\n        // setup group accum\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var role_data = {};\n            var evaluation_data = $scope.reporting.selected.allData[ndx][type+'_data'];\n            for (var role in evaluation_data)\n            {\n                if(evaluation_data.hasOwnProperty(role))\n                {\n                    var accum = {};\n                    for(var gid in $scope.reporting.selected.surveyGroups[role])\n                    {\n                        if(!accum.hasOwnProperty(gid))\n                        {\n                            accum[gid] = {numerator: 0.0, denominator: 0.0, avg: 0.0};\n                        }\n\n                        // calc role questions avg\n                        var num_role_participants = evaluation_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var new_gid              = $scope.correctedGID(ndx, gid);\n                            var group_role_questions = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                            for (var response in evaluation_data[role]['cumulative_question_scores'])\n                            {\n                                // check question is valid for role\n                                if(group_role_questions.indexOf(response) > -1)\n                                {\n                                    accum[gid].numerator += evaluation_data[role]['cumulative_question_scores'][response];\n                                    accum[gid].denominator++;\n                                }\n                            };\n\n                            accum[gid].avg = (accum[gid].denominator > 0 ? accum[gid].numerator/accum[gid].denominator : 0.0);\n                        }\n                    }\n\n                    if(!role_data.hasOwnProperty(role))\n                    {\n                        role_data[role] = accum;\n                    }\n                }\n            }\n\n            data.push({date: $scope.reporting.selected.allData[ndx].period.date, accum: role_data});\n        }\n\n        $log.log('>>> data', data);\n        var gid_accum = {};\n        for(var i = 0; i < data.length; i++)\n        {\n            var curr_data = data[i];\n            for (var role in curr_data.accum)\n            {\n                var role_aggr = curr_data.accum[role];\n                for(gid in role_aggr)\n                {\n                    if (!gid_accum.hasOwnProperty(gid))\n                    {\n                        gid_accum[gid] = {numerator: 0.0, denominator: 0.0};\n                    }\n\n                    if(role_aggr[gid].denominator > 0)\n                    {\n                        gid_accum[gid].numerator += role_aggr[gid].avg;\n                        gid_accum[gid].denominator++;\n                    }\n                }\n            }\n        }\n        for(gid in gid_accum)\n        {\n            var point_val = (gid_accum[gid].denominator > 0 ? gid_accum[gid].numerator/gid_accum[gid].denominator : 0.0);\n            if(type === 'agency')\n            {\n                series.push({y: point_val, marker: {symbol: 'url(/content/themes/procync/app/assets/images/orange.png)'}});\n            } else {\n                series.push({y: point_val, marker: {symbol: 'url(/content/themes/procync/app/assets/images/blue.png)'}});\n            }\n        }\n\n        return series;\n    }\n\n    /**\n     * [setupDashboardAllCoreSubjectsGraph - dashboard all core subjects graph options]\n     * @param  {[type]} dom_id         [description]\n     * @param  {[type]} add_categories [description]\n     * @return {[type]}                [description]\n     */\n    $scope.setupDashboardAllCoreSubjectsGraph = function(is_dashboard) {\n\n        var hc = new Ehighcharts();\n        var chart_template_name = (is_dashboard ? 'dashboard-allcoresubjects' : 'allcoresubjects');\n        hc.setOptions(chart_template_name);// setup xAxis\n\n        // axis + cats\n        var categories = [];\n        var axis_dates = [];\n\n        for (var group in $scope.reporting.selected.surveyGroups['OP'])\n        {\n            categories.push($scope.reporting.selected.surveyGroups['OP'][group]['name'].toUpperCase());\n        }\n        hc.addXaxis(categories);\n\n        var agency_series  = $scope.calcAllCoresubjects('agency');\n        var company_series = $scope.calcAllCoresubjects('company');\n\n        hc.addSeries('agency', agency_series, '#f28d4f');\n        hc.addSeries('company', company_series, '#5169b2');\n\n        var group_benchmark_accum = {};\n        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    for (var gid in $scope.reporting.selected.surveyGroups['OP'])\n                    {\n                        // init accum\n                        if(!group_benchmark_accum.hasOwnProperty(gid)) {\n                            group_benchmark_accum[gid] = {numerator: 0.0, denominator: 0.0, avg: 0.0};\n                        }\n\n                        // compute client role response avgs\n                        var num_role_participants = evaluation_data[role]['tot'];\n                        var group_role_questions  = $scope.reporting.selected.surveyGroups[role][gid]['questions'];\n                        if(num_role_participants)\n                        {\n                            for (var role_response in evaluation_data[role]['cumulative_question_scores'])\n                            {\n                                var valid_role_question = group_role_questions.indexOf(role_response);\n                                if(valid_role_question > -1)\n                                {\n                                    group_benchmark_accum[gid].numerator += $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][role_response];\n                                    group_benchmark_accum[gid].denominator++;\n                                }\n                            };\n                        }\n                    }\n                }\n            }\n        }\n\n        var benchmark_series = [];\n        for(var group in group_benchmark_accum) {\n\n            if(group_benchmark_accum.hasOwnProperty(group)) {\n                group_benchmark_accum[group].avg = (group_benchmark_accum[group].denominator > 0 ? group_benchmark_accum[group].numerator/group_benchmark_accum[group].denominator : 0.0);\n                benchmark_series.push({y: group_benchmark_accum[group].avg, marker: {symbol: 'url(/content/themes/procync/app/assets/images/black.png)'}});\n            }\n        }\n\n        hc.addSeries('benchmark', benchmark_series, '#000000', 'shortdot');\n\n        if(is_dashboard)\n        {\n            $scope.reporting.selected.plotOptions.dashboard.core_sujects = hc.getOptions();\n        }\n        else\n        {\n            $scope.reporting.selected.plotOptions.core_sujects = hc.getOptions();\n        }\n    },\n\n\n    /**\n     * [plotSelectedGroupGraph - selected group graph data + options]\n     * @return {[type]} [description]\n     */\n    $scope.setupSelectedGroupGraph = function() {\n\n        // setup graph\n        var hc = new Ehighcharts();\n        hc.setOptions('selected-group');\n\n        var categories = [];\n        var axis_dates = [];\n\n        $log.log('>>> selectedGroup', $scope.reporting.selected.singleGroup);\n\n        // setup xAxis for data grouping\n        var group_questions = $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions'];\n        for(var q in $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions_txt'])\n        {\n            categories.push($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions_txt'][q].toUpperCase());\n        }\n\n        hc.addXaxis(categories);\n\n        // roles series\n        var allData = [];\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var accum           = {date: $scope.reporting.selected.allData[ndx].period.date, role_data: {}, role_questions: {}};\n            var evaluation_data = $scope.reporting.selected.allData[ndx].data;\n            $log.log('>>> evaluation_data', $scope.reporting.selected.allData[ndx]);\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    if(!accum.role_data.hasOwnProperty(role))\n                    {\n                        accum.role_data[role] = [];\n                    }\n\n                    if(!accum.role_questions.hasOwnProperty(role))\n                    {\n                        accum.role_questions[role] = 0.0;\n                    }\n\n                    var new_gid = $scope.correctedGID(ndx, $scope.reporting.selected.singleGroup);\n                    var group_questions  = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    for (var question in group_questions)\n                    {\n                        if(evaluation_data[role]['cumulative_question_scores'].hasOwnProperty(group_questions[question]))\n                        {\n                            accum.role_data[role].push(10*evaluation_data[role]['cumulative_question_scores'][group_questions[question]]);\n                            accum.role_questions[role]++;\n                        }\n                        else\n                        {\n                            accum.role_data[role].push(0);\n                        }\n                    };\n                }\n            }\n\n            allData.push(accum);\n        }\n\n        // role data\n        $log.log('>>>>> allData', allData, $scope.reporting.selected.evaluationStartNDX, $scope.reporting.selected.evaluationEndNDX);\n        for(var evaluation in allData)\n        {\n            $log.log('eval', allData[evaluation]);\n            for(var role in allData[evaluation].role_data)\n            {\n                if(allData[evaluation].role_data.hasOwnProperty(role))\n                {\n                    var series_color = $scope.getRoleColor(role);\n                    hc.addSeries(role+allData[evaluation].date, allData[evaluation].role_data[role], series_color);\n                }\n            }\n\n            var total_series = [];\n            var total_accum  = {};\n            for (var role in allData[evaluation].role_data)\n            {\n                for(var q in allData[evaluation].role_data[role])\n                {\n                    if(!total_accum.hasOwnProperty(q))\n                    {\n                        total_accum[q] = {numerator: 0.0, denominator: 0.0, avg: 0.0};\n                    }\n\n                    if(allData[evaluation].role_data[role][q] > 0)\n                    {\n                        total_accum[q].numerator += allData[evaluation].role_data[role][q];\n                        total_accum[q].denominator++;\n                    }\n                }\n            }\n\n            for(var q in total_accum)\n            {\n                $log.log('ta', total_accum[q]);\n                total_accum[q].avg = (total_accum[q].denominator > 0 ? total_accum[q].numerator/total_accum[q].denominator : 0);\n                total_series.push(total_accum[q].avg);\n            }\n\n            hc.addSeries('total'+allData[evaluation].date, total_series, '#725a0b');\n        }\n\n        // benchmark\n        var benchmark_series = [];\n        var num_responses    = $scope.reporting.selected.allData.length;\n        var benchmark_data   = $scope.reporting.selected.allData[num_responses - 1].groups['OP'][$scope.reporting.selected.singleGroup].question_benchmarks;\n        for(var bench in benchmark_data) {\n            benchmark_series.push(10*benchmark_data[bench]);\n        }\n        hc.addSeries('benchmark', benchmark_series, '#000000');\n\n        $scope.reporting.selected.plotOptions.selectedGroup = hc.getOptions();\n    },\n\n    /**\n     * [getIconClass - wrapper class for displaying the icons]\n     * @param  {[type]} number [description]\n     * @return {[type]}        [description]\n     */\n    $scope.getIconClass = function(number) {\n\n        number = Math.abs(number);\n        if (number <= 0.2) {\n            return 'performance-icon icon-good';\n        }\n        if (number > 0.2 && number <= 1) {\n            return 'performance-icon icon-improvements-needed';\n        }\n        if (number > 1) {\n            return 'performance-icon icon-immediate-action';\n        }\n    },\n\n    /**\n     * [getClientvsBenchmark - calculate client-benchmark avg for a group]\n     * @param  {[type]} gid [description]\n     * @return {[type]}     [description]\n     */\n    $scope.getClientvsBenchmark = function(gid) {\n\n        var company_tot  = 0.0;\n        var accum_client_role_weights = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    // compute client role response avgs\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    var new_gid               = $scope.correctedGID(ndx, gid);\n                    var group_role_questions  = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    if(num_role_participants)\n                    {\n                        for (var role_response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var valid_role_question = group_role_questions.indexOf(role_response);\n                            if(valid_role_question > -1)\n                            {\n                                var response_value     = evaluation_data[role]['cumulative_question_scores'][role_response];\n                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][role_response];\n                                company_tot += (response_value - response_benchmark);\n                                accum_client_role_weights++;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        var ret = (accum_client_role_weights > 0 ? company_tot / accum_client_role_weights : 0.0);\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getClientvsAgencyBenchmark - calculate clientAvg-agencyAvg for a group]\n     * @param  {[type]} gid [description]\n     * @return {[type]}     [description]\n     */\n    $scope.getClientvsAgencyBenchmark = function(gid) {\n\n        // add agency series/point\n        var agency_tot = 0.0;\n        var agency_weights_accum = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var new_gid               = $scope.correctedGID(ndx, gid);\n                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var response_value = evaluation_data[role]['cumulative_question_scores'][response];\n                                agency_tot += response_value;\n                                agency_weights_accum++;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        // add company series/point\n        var company_tot           = 0.0;\n        var company_weights_accum = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var new_gid               = $scope.correctedGID(ndx, gid);\n                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var response_value = evaluation_data[role]['cumulative_question_scores'][response];\n                                company_tot += response_value;\n                                company_weights_accum++;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        var agency_avg  = agency_weights_accum > 0 ? agency_tot/agency_weights_accum : 0.0;\n        var company_avg = company_weights_accum > 0 ? company_tot/company_weights_accum : 0.0;\n\n        var ret = company_avg - agency_avg;\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getOverallBenchmark - calculate overall reponse avg for a group]\n     * @param  {[type]} gid [description]\n     * @return {[type]}     [description]\n     */\n    $scope.getOverallBenchmark = function(gid) {\n\n        // add agency series/point\n        var agency_tot            = 0.0;\n        var agency_weights_accum  = 0.0;\n\n        // add company series/point\n        var company_tot           = 0.0;\n        var company_weights_accum = 0.0;\n\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data;\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var new_gid               = $scope.correctedGID(ndx, gid);\n                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var response_value     = evaluation_data[role]['cumulative_question_scores'][response];\n                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][response];\n                                agency_tot += (response_value - response_benchmark);\n                                agency_weights_accum++;\n                            }\n                        };\n                    }\n                }\n            }\n\n            evaluation_data = $scope.reporting.selected.allData[ndx].company_data\n            for (var role in $scope.reporting.selected.company_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    var new_gid               = $scope.correctedGID(ndx, gid);\n                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];\n                    var num_role_participants = evaluation_data[role]['tot'];\n                    if(num_role_participants)\n                    {\n                        for (var response in evaluation_data[role]['cumulative_question_scores'])\n                        {\n                            var question_valid = group_questions.indexOf(response);\n                            if(question_valid > -1)\n                            {\n                                var response_value     = evaluation_data[role]['cumulative_question_scores'][response];\n                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][response];\n                                company_tot += (response_value - response_benchmark);\n                                company_weights_accum++;\n                            }\n                        };\n                    }\n                }\n            }\n        }\n\n        var numerator   = (agency_tot + company_tot);\n        var denominator = (agency_weights_accum + company_weights_accum);\n        if(denominator <= 0)\n        {\n            $log.log('getOverallBenchmark Error: denominator <= 0');\n        }\n\n        var ret = denominator > 0 ? numerator/denominator : -9999;\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getQClientvsBenchmark - calculate client-benchmark avg for a question]\n     * @param  {[type]} question [description]\n     * @return {[type]}          [description]\n     */\n    $scope.getQClientvsBenchmark = function(question) {\n\n        //calc\n        var question_tot   = 0.0;\n        var question_accum = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var evaluation_data    = $scope.reporting.selected.allData[ndx].company_data;\n            var question_benchmark = $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];\n            for (var role in evaluation_data)\n            {\n                if (evaluation_data.hasOwnProperty(role))\n                {\n                    if(evaluation_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&\n                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))\n                    {\n                        var num_role_participants = evaluation_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var response_value     = evaluation_data[role]['cumulative_question_scores'][question];\n                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];\n                            question_tot += (response_value - response_benchmark);\n                            question_accum++;\n                        }\n                    }\n                }\n            }\n        }\n\n        var ret = (question_accum > 0 ? (question_tot/question_accum): 0.0);\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getQClientvsAgencyBenchmark - calculate clientAvg-agencyAvg for a group]\n     * @param  {[type]} question [description]\n     * @return {[type]}          [description]\n     */\n    $scope.getQClientvsAgencyBenchmark = function(question) {\n\n        // company\n        var company_tot   = 0.0;\n        var company_accum = 0.0;\n\n        // agency\n        var agency_tot    = 0.0;\n        var agency_accum  = 0.0;\n\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var company_data = $scope.reporting.selected.allData[ndx].company_data;\n            for (var role in company_data)\n            {\n                if (company_data.hasOwnProperty(role))\n                {\n                    if(company_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&\n                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))\n                    {\n                        var num_role_participants = company_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var response_value = company_data[role]['cumulative_question_scores'][question];\n                            company_tot += response_value;\n                            company_accum++;\n                        }\n                    }\n                }\n            }\n\n            var agency_data = $scope.reporting.selected.allData[ndx].agency_data;\n            for (var role in agency_data)\n            {\n                if (agency_data.hasOwnProperty(role))\n                {\n                    if(agency_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&\n                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))\n                    {\n                        var num_role_participants = agency_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var response_value = agency_data[role]['cumulative_question_scores'][question];\n                            agency_tot += response_value;\n                            agency_accum++;\n                        }\n                    }\n                }\n            }\n        }\n\n        var agency_avg  = agency_accum > 0 ? agency_tot/agency_accum : 0.0;\n        var company_avg = company_accum > 0 ? company_tot/company_accum : 0.0;\n        var ret = company_avg - agency_avg;\n\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getQOverallBenchmark - calculate overall reponse avg for a question]\n     * @param  {[type]} question [description]\n     * @return {[type]}          [description]\n     */\n    $scope.getQOverallBenchmark = function(question) {\n\n        // company\n        var company_tot   = 0.0;\n        var company_accum = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var company_data = $scope.reporting.selected.allData[ndx].company_data;\n            for (var role in company_data)\n            {\n                if (company_data.hasOwnProperty(role))\n                {\n                    if(company_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&\n                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))\n                    {\n                        var num_role_participants = company_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];\n                            var response_value     = company_data[role]['cumulative_question_scores'][question];\n\n                            company_tot += (response_value - response_benchmark);\n                            company_accum++;\n                        }\n                    }\n                }\n            }\n        }\n\n        // agency\n        var agency_tot = 0.0;\n        var agency_accum = 0.0;\n        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)\n        {\n            var agency_data = $scope.reporting.selected.allData[ndx].agency_data;\n            for (var role in agency_data)\n            {\n                if (agency_data.hasOwnProperty(role))\n                {\n                    if(agency_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&\n                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))\n                    {\n                        var num_role_participants = agency_data[role]['tot'];\n                        if(num_role_participants)\n                        {\n                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];\n                            var response_value     = agency_data[role]['cumulative_question_scores'][question];\n\n                            agency_tot += (response_value - response_benchmark);\n                            agency_accum++;\n                        }\n                    }\n                }\n            }\n        }\n\n        var ret = ((company_tot + agency_tot)/(company_accum + agency_accum));\n        return ret.toFixed(1);\n    },\n\n    /**\n     * [getColumnsClass description]\n     * @return {[type]} [description]\n     */\n    $scope.getColumnsClass = function() {\n\n        var ret = '';\n        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))\n        {\n            var num_groups        = Object.keys($scope.reporting.selected.surveyGroups['OP']).length + 1;\n            var num_cols_per_item = Math.floor(12 / num_groups);\n            ret                   = 'col-sm-'+num_cols_per_item;\n        }\n\n        return ret;\n    };\n\n    /**\n     * [getQuestionsColumnsClass description]\n     * @return {[type]} [description]\n     */\n    $scope.getQuestionsColumnsClass = function() {\n\n        var ret = '';\n        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))\n        {\n            if($scope.reporting.selected.singleGroup && $scope.reporting.selected.surveyGroups['OP'].hasOwnProperty($scope.reporting.selected.singleGroup))\n            {\n                var num_questions     = Object.keys($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions']).length + 1;\n                var num_cols_per_item = Math.floor(12 / num_questions);\n                ret                   = 'col-sm-'+num_cols_per_item;\n            }\n        }\n\n        return ret;\n    };\n\n    /**\n     * [getQuestionsColumnsClassComplement description]\n     * @return {[type]} [description]\n     */\n    $scope.getQuestionsColumnsClassComplement = function() {\n\n        var ret = '';\n        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))\n        {\n            if($scope.reporting.selected.singleGroup && $scope.reporting.selected.surveyGroups['OP'].hasOwnProperty($scope.reporting.selected.singleGroup))\n            {\n                var num_questions     = Object.keys($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions']).length + 1;\n                var num_cols_per_item = Math.floor(12 / num_questions);\n                ret                   = 'col-sm-'+(12-num_cols_per_item);\n            }\n        }\n\n        return ret;\n    };\n\n    /**\n     * [getColumnsClassComplement description]\n     * @return {[type]} [description]\n     */\n    $scope.getColumnsClassComplement = function() {\n\n        var ret = '';\n        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))\n        {\n            var num_groups        = Object.keys($scope.reporting.selected.surveyGroups['OP']).length + 1;\n            var num_cols_per_item = Math.floor(12 / num_groups);\n            ret                   = 'col-sm-'+(12-num_cols_per_item);\n        }\n\n        return ret;\n    };\n\n    /**\n     * [getGroupsClass description]\n     * @param  {[type]} group_ndx [description]\n     * @return {[type]}           [description]\n     */\n    $scope.getGroupsClass = function(group_ndx) {\n\n        var groups_class = '';\n\n        switch(group_ndx) {\n            case 0:\n                groups_class = 'group-color1';\n                break;\n            case 1:\n                groups_class = 'group-color2';\n                break;\n            case 2:\n                groups_class = 'group-color3';\n                break;\n            case 3:\n                groups_class = 'group-color4';\n                break;\n            case 4:\n                groups_class = 'group-color5';\n                break;\n            default:\n               groups_class = 'group-color1';\n               break\n        }\n\n        return groups_class;\n    }\n\n\n    /**\n     * [waitForRenderAndDoSomething description]\n     * @return {[type]} [description]\n     */\n    var waitForRenderAndDoSomething = function() {\n\n        // Wait for all templates to be loaded\n        if($http.pendingRequests.length > 0) {\n            $timeout(waitForRenderAndDoSomething);\n        } else {\n            $scope.init();\n        }\n    };\n\n    // Waits for first digest cycle\n    $timeout(waitForRenderAndDoSomething);\n\n}])\n\n.directive('chart', function ($log, $timeout) {\n\n    return {\n        restrict: 'E',\n        replace: true,\n        template: '<div></div>',\n        scope: {\n            config: '='\n        },\n        link: function (scope, element, attrs) {\n            var chart;\n            var process = function () {\n\n                // sanity check\n                if(!scope.config) {\n                    $log.log('Error: No config found');\n                    return false;\n                }\n\n                var config               = angular.extend({}, scope.config);\n                config.chart.renderTo    = element[0];\n                config.chart.events      = {};\n                config.chart.events.load = function()\n                {\n                    var chart = this;\n                    $timeout(function()\n                    {\n                        for(var series_ndx in chart.series)\n                        {\n                            chart.series[series_ndx].show();\n                        }\n                    });\n                };\n                chart = new Highcharts.Chart(config);\n                $timeout(function() {\n                    chart.reflow();\n                }, 500);\n            };\n\n            process();\n\n            scope.$watch(\"config.series\", function (loading) {\n                process();\n            });\n            scope.$watch(\"config.loading\", function (loading) {\n                if (!chart) {\n                    return;\n                }\n                if (loading) {\n                    chart.showLoading();\n                } else {\n                    chart.hideLoading();\n                }\n            });\n        }\n    };\n})\n\n.factory('restService', ['$resource', '$q', '$http', function($resource, $q, $http){\n\n    'use strict';\n    $http.defaults.headers.post[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n\n    return {\n\n        getServerData: function(url) {\n\n            // Le promise\n            var defer = $q.defer();\n\n            $http.get(url)\n            .success(function (data, status, headers, config) {\n                defer.resolve(data);\n            }).error(function (data, status, headers, config) {\n                console.log(status);\n            });\n\n            // return promise\n            return defer.promise;\n        },\n\n        deleteServerData: function(url) {\n\n            var defer = $q.defer();\n\n            $http.delete(url)\n            .success(function (data, status, headers, config) {\n                defer.resolve(data);\n            }).error(function (data, status, headers, config) {\n                console.log(status);\n            });\n\n            return defer.promise;\n        },\n\n        postServerData: function(url, post_data) {\n\n            var defer = $q.defer();\n\n            $http.post(url, post_data)\n            .success(function (data, status, headers, config) {\n                defer.resolve(data);\n            }).error(function (data, status, headers, config) {\n                console.log(status);\n            });\n\n            return defer.promise;\n        }\n    };\n}]);\n\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qcy9yZXBvcnRpbmcvcmVwb3J0aW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy92YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyICQgPSBnbG9iYWwuJDtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENvb2tpZXMgPSBnbG9iYWwuQ29va2llcztcblxudmFyIGFwcCA9IHdpbmRvdy5hbmd1bGFyLm1vZHVsZSgncHJvY3luY1JlcG9ydGluZycsIFsnbmdSb3V0ZScsICduZ1Jlc291cmNlJywgJ2FuZ3VsYXItbG9hZGluZy1iYXInLCAnbmdBbmltYXRlJ10pO1xudmFyIEVoaWdoY2hhcnRzID0gcmVxdWlyZSgnLi9jaGFydHMvSGlnaGNoYXJ0c0dyYXBoLmpzJyk7XG5cbmFwcC5jb25maWcoWyckcm91dGVQcm92aWRlcicsICckbG9jYXRpb25Qcm92aWRlcicsIGZ1bmN0aW9uKCRyb3V0ZVByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcikge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgJHJvdXRlUHJvdmlkZXJcbiAgICAgICAgLndoZW4oJy9yZXBvcnRpbmcnLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3JlbGF0aW9ucy5odG1sJyxcbiAgICAgICAgfSlcbiAgICAgICAgLndoZW4oJy9yZXBvcnRpbmcvZGFzaGJvYXJkJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdkYXNoYm9hcmQuaHRtbCcsXG4gICAgICAgIH0pXG4gICAgICAgIC53aGVuKCcvcmVwb3J0aW5nL3NlbGVjdGVkZ3JvdXAvOmdpZCcsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnc2VsZWN0ZWRncm91cC5odG1sJyxcbiAgICAgICAgfSlcbiAgICAgICAgLm90aGVyd2lzZSh7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAnL3JlcG9ydGluZydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xufV0pXG5cbi5ydW4oWyckbG9nJywgJyRyb290U2NvcGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbigkbG9nLCAkcm9vdFNjb3BlLCAkdGltZW91dCkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgICRyb290U2NvcGUuZ2xvYmFscyA9IHt9O1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gdGFza3NcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy5sb2coJ3J1bicpO1xuICAgIH0pO1xuXG59XSlcblxuLmNvbnRyb2xsZXIoJ1Byb2N5bmNSZXBvcnRpbmdDb250cm9sbGVyJywgWyckcm9vdFNjb3BlJywgJyRzY29wZScsICckbG9jYXRpb24nLCAnJGxvZycsICckcm91dGUnLCAnJHJvdXRlUGFyYW1zJywgJyR0aW1lb3V0JywgJyRodHRwJywgJ3Jlc3RTZXJ2aWNlJyxcbiAgICBmdW5jdGlvbigkcm9vdFNjb3BlLCAkc2NvcGUsICRsb2NhdGlvbiwgJGxvZywgJHJvdXRlLCAkcm91dGVQYXJhbXMsICR0aW1lb3V0LCAkaHR0cCwgcmVzdFNlcnZpY2UpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgICRzY29wZS4kcm91dGUgPSAkcm91dGU7XG4gICAgJHNjb3BlLnJlcG9ydGluZyA9IHtcbiAgICAgICAgcmVsYXRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICByZWxhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RlcDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2luZ2xlR3JvdXA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBlcmlvZFNwYW46IHtzZWxlY3RlZGdyb3VwOiBmYWxzZSwgZGFzaGJvYXJkOiBmYWxzZX0sXG4gICAgICAgICAgICBzdXJ2ZXlUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdXJ2ZXlHcm91cHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgZGFzaGJvYXJkOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50czogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjb3JlU3ViamVjdHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlR3JvdXA6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEdyb3VwOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxEYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWZlcmVuY2VFdmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBldmFsdWF0aW9uU3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2YWx1YXRpb25FbmQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2YWx1YXRpb25TdGFydE5EWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXZhbHVhdGlvbkVuZE5EWDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcXVhcnRlckludGVydmFsczogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGZldGNoaW5nRGF0YTogZmFsc2VcbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS4kb24oXCIkcm91dGVDaGFuZ2VTdWNjZXNzXCIsZnVuY3Rpb24oZXZlbnQsIG5leHQsIGN1cnJlbnQpe1xuICAgICAgICAkbG9nLmxvZyhcIiRyb3V0ZUNoYW5nZVN0YXJ0XCIsIGV2ZW50LCBuZXh0LCBjdXJyZW50KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFtsb2FkQ29va2llIC0gdXNlZCB0byBsb2FkIGN1cnJlbnQgc3RhdGUgcG9zdCBGNV1cbiAgICAgKiBAcmV0dXJuIHtbYm9vbGVhbl19IFtjb29raWUgd2FzIGxvYWRlZF1cbiAgICAgKi9cbiAgICAkc2NvcGUubG9hZENvb2tpZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciByZXBvcnRpbmdfY29va2llID0gQ29va2llcy5nZXRKU09OKCdyZXBvcnRpbmcnKTtcbiAgICAgICAgaWYgKCEkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnJlbGF0aW9uICYmIHJlcG9ydGluZ19jb29raWUpIHtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQsIHJlcG9ydGluZ19jb29raWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtzYXZlQ29va2llIC0gdXNlZCB0byBzYXZlIGN1cnJlbnQgc3RhdGUgZm9yIEY1XVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5zYXZlQ29va2llID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNvb2tpZV9vYmogPSB7cmVsYXRpb246IHVuZGVmaW5lZCwgc3RlcDogdW5kZWZpbmVkLCBzaW5nbGVHcm91cDogdW5kZWZpbmVkfTtcblxuICAgICAgICBjb29raWVfb2JqLnJlbGF0aW9uICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWxhdGlvbjtcbiAgICAgICAgY29va2llX29iai5zdGVwICAgICAgICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3RlcDtcbiAgICAgICAgY29va2llX29iai5zaW5nbGVHcm91cCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXA7XG5cbiAgICAgICAgQ29va2llcy5zZXQoJ3JlcG9ydGluZycsIGNvb2tpZV9vYmopO1xuICAgICAgICAkbG9nLmxvZygnc2F2aW5nIGNvb2tpZScsIENvb2tpZXMuZ2V0SlNPTigncmVwb3J0aW5nJykpO1xuICAgIH0sXG5cbiAgICAkc2NvcGUuc2VuZE1haWwgPSBmdW5jdGlvbihjb250ZW50KSB7XG5cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9tYW5kcmlsbGFwcC5jb20vYXBpLzEuMC9tZXNzYWdlcy9zZW5kLmpzb24nLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICdrZXknOiAncG5PdTZkcDIxRXVvTS1PcWlyOHpIQScsXG4gICAgICAgICAgICAnbWVzc2FnZSc6IHtcbiAgICAgICAgICAgICAgJ2Zyb21fZW1haWwnOiAnYW5kcmVAZWVudm91ZG1lZGlhLm5sJyxcbiAgICAgICAgICAgICAgJ3RvJzogW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnZW1haWwnOiAnYW5kcmVAZWVudm91ZG1lZGlhLm5sJyxcbiAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiAnQW5kcmUgTmV0bycsXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3RvJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICdhdXRvdGV4dCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgJ3N1YmplY3QnOiAnUHJvY3luYyBKU09OIScsXG4gICAgICAgICAgICAgICdodG1sJzogY29udGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgJGxvZy5sb2cocmVzcG9uc2UpOyAvLyBpZiB5b3UncmUgaW50byB0aGF0IHNvcnRhIHRoaW5nXG4gICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW3ZhbGlkYXRlRW5kUGVyaW9kIC0gZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLnZhbGlkYXRlRW5kUGVyaW9kID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoISRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZCB8fCAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmQucGVyaW9kLmRhdGUgPCAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydC5wZXJpb2QuZGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2luaXQgLSBpbml0aWFsaXplIGFsbCB0aGUgdGhpbmdzXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5mZXRjaGluZ0RhdGEgPSB0cnVlO1xuXG4gICAgICAgIHZhciByZWxhdGlvbl9wcmVkZWZpbmVkID0gJCgnLnJlbGF0aW9ucy1zZWxlY3Rpb24nKTtcbiAgICAgICAgaWYoIXJlbGF0aW9uX3ByZWRlZmluZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWxhdGlvbl9wcmVkZWZpbmVkID0gJCgnLmRhc2hib2FyZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFyZWxhdGlvbl9wcmVkZWZpbmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVsYXRpb25fcHJlZGVmaW5lZCA9ICQoJy5zZWxlY3RlZGdyb3VwJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVsYXRpb25faWQgPSBwYXJzZUludChyZWxhdGlvbl9wcmVkZWZpbmVkLmF0dHIoJ2RhdGEtZXZhbHVhdGlvbicpLCAxMCk7XG4gICAgICAgIHZhciBxdWVyeV9wYXJhbXMsIHF1ZXJ5X3N0ciwgaXNfaW52aXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYocmVsYXRpb25fcHJlZGVmaW5lZC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgcXVlcnlfcGFyYW1zID0gJyZldmFsdWF0aW9uX2lkPScrcmVsYXRpb25faWRcbiAgICAgICAgICAgIHF1ZXJ5X3N0ciA9ICcvY21zL3dwLWFkbWluL2FkbWluLWFqYXgucGhwP2FjdGlvbj1nZXRSZWxhdGlvbicrcXVlcnlfcGFyYW1zO1xuICAgICAgICAgICAgaXNfaW52aXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgJGxvZy5sb2coJ2dvdCBpbnZpdGUgc2luZ3VsYXIgcmVsJywgcXVlcnlfc3RyKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICBxdWVyeV9zdHIgPSAnL2Ntcy93cC1hZG1pbi9hZG1pbi1hamF4LnBocD9hY3Rpb249Z2V0UmVsYXRpb25zJztcbiAgICAgICAgfVxuICAgICAgICByZXN0U2VydmljZS5wb3N0U2VydmVyRGF0YShxdWVyeV9zdHIpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgJGxvZy5sb2coJ3JlbGF0aW9ucycscmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnJlbGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc3BvbnNlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGFueSAgPSB7J25hbWUnOiB2YWx1ZS5jb21wYW55LnBvc3RfdGl0bGUsICdpZCc6IHZhbHVlLmNvbXBhbnkuSUR9O1xuICAgICAgICAgICAgICAgIHZhciBhZ2VuY3kgICA9IHsnbmFtZSc6IHZhbHVlLmFnZW5jeS5wb3N0X3RpdGxlLCAnaWQnOiB2YWx1ZS5hZ2VuY3kuSUR9O1xuICAgICAgICAgICAgICAgIHZhciBicmFuZCAgICA9IHsnbmFtZSc6IHZhbHVlLmJyYW5kLnBvc3RfdGl0bGUsICdpZCc6IHZhbHVlLmJyYW5kLklEfTtcblxuICAgICAgICAgICAgICAgIHZhciBzdGVwcyA9IFsnMTgwJ107XG4gICAgICAgICAgICAgICAgaWYoJzM2MCcgPT09IHZhbHVlWycxODBfMzYwJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcHMucHVzaCgnMzYwJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlbF9saXRlcmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHZhbHVlLnBvc3QucG9zdF90aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogdmFsdWUucG9zdC5JRCxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbXBhbnknOiBjb21wYW55LFxuICAgICAgICAgICAgICAgICAgICAnYWdlbmN5JzogYWdlbmN5LFxuICAgICAgICAgICAgICAgICAgICAnYnJhbmQnOiBicmFuZCxcbiAgICAgICAgICAgICAgICAgICAgJ2NvdW50cnknOiB2YWx1ZS5jb3VudHJ5LFxuICAgICAgICAgICAgICAgICAgICAnMTgwXzM2MCc6IHZhbHVlWycxODBfMzYwJ10sXG4gICAgICAgICAgICAgICAgICAgICdzdGVwcyc6IHN0ZXBzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHVzaChyZWxfbGl0ZXJhbCk7XG5cbiAgICAgICAgICAgIH0sICRzY29wZS5yZXBvcnRpbmcucmVsYXRpb25zKTtcblxuICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5mZXRjaGluZ0RhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS5pbml0aWFsaXplUmVsYXRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbaW5pdGlhbGl6ZVJlbGF0aW9ucyAtIHVzZWQgZm9yIHJlcG9ydGluZyB0b2tlbiBzdHVmZl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuaW5pdGlhbGl6ZVJlbGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICRzY29wZS5sb2FkQ29va2llKCk7XG4gICAgICAgIHZhciBpc19zaW5ndWxhcl9yZWwgPSBmYWxzZSwgaXNfc2luZ3VsYXJfc3RlcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHNpbmd1bGFyIHJlbFxuICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnJlbGF0aW9ucyAmJiAkc2NvcGUucmVwb3J0aW5nLnJlbGF0aW9ucy5sZW5ndGggPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzX3Npbmd1bGFyX3JlbCA9IHRydWU7XG4gICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnJlbGF0aW9uID0gJHNjb3BlLnJlcG9ydGluZy5yZWxhdGlvbnNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW5ndWxhciBzdGVwc1xuICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnJlbGF0aW9uICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVsYXRpb24uc3RlcHMgJiYgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWxhdGlvbi5zdGVwcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlzX3Npbmd1bGFyX3N0ZXAgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdGVwID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWxhdGlvbi5zdGVwc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgICRsb2cubG9nKCdzaW5ndWxhcnMnLCBpc19zaW5ndWxhcl9zdGVwLCBpc19zaW5ndWxhcl9yZWwpO1xuICAgICAgICAkbG9nLmxvZygncmVsYXRpb25zJywgJHNjb3BlLnJlcG9ydGluZy5yZWxhdGlvbnMsICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVsYXRpb24pO1xuXG4gICAgICAgIC8vIHNpbmd1bGFyIHJlbCBhbmQgc3RlcHNcbiAgICAgICAgaWYoaXNfc2luZ3VsYXJfcmVsICYmIGlzX3Npbmd1bGFyX3N0ZXApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gICAgICRzY29wZS5zZXRMb2NhdGlvbignZGFzaGJvYXJkJylcbiAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICAvLyBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwICYmICRyb3V0ZS5jdXJyZW50LnRlbXBsYXRlVXJsID09PSAnc2VsZWN0ZWRncm91cC5odG1sJykge1xuICAgICAgICAgICAgLy8gICAgIGNiID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgLy8gICAgIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgJHNjb3BlLnNldHVwU2VsZWN0ZWRHcm91cEdyYXBoKCk7XG4gICAgICAgICAgICAvLyAgICAgICAgICRzY29wZS5zZXRMb2NhdGlvbignc2VsZWN0ZWRncm91cC8nKyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXApO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gJHNjb3BlLmZldGNoUmVsYXRpb25EYXRhKGNiKTtcbiAgICAgICAgICAgICRzY29wZS5mZXRjaFJlbGF0aW9uRGF0YSgkc2NvcGUuc2V0TG9jYXRpb24oJ2Rhc2hib2FyZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtzZXRMb2NhdGlvbiAtIHVzZWQgdG8gY2hhbmdlIHZpZXddXG4gICAgICogQHBhcmFtIHtbdHlwZV19IGxvYyBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLnNldExvY2F0aW9uID0gZnVuY3Rpb24obG9jKSB7XG5cbiAgICAgICAgJHNjb3BlLnNhdmVDb29raWUoKTtcblxuICAgICAgICBpZihsb2MuaW5kZXhPZignc2VsZWN0ZWRncm91cCcpID4gLTEpIHtcblxuICAgICAgICAgICAgdmFyIG9ial9qc29uID0gSlNPTi5zdHJpbmdpZnkoJHNjb3BlLnJlcG9ydGluZyk7XG4gICAgICAgICAgICAkc2NvcGUuc2VuZE1haWwob2JqX2pzb24pO1xuICAgICAgICB9XG4gICAgICAgICRsb2NhdGlvbi5wYXRoKFwiL3JlcG9ydGluZy9cIitsb2MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFt0b2dnbGVJbmRleGVzIC0gdXNlZCB0byBjaGFuZ2UgcGVyaW9kIHNwYW5dXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS50b2dnbGVJbmRleGVzID0gZnVuY3Rpb24oY2IpXG4gICAge1xuICAgICAgICB2YXIgbnVtX3Jlc3BvbnNlcyA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBzcGFuID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5wZXJpb2RTcGFuLmRhc2hib2FyZDtcblxuICAgICAgICBpZigkcm91dGUuY3VycmVudC50ZW1wbGF0ZVVybCA9PT0gJ3NlbGVjdGVkZ3JvdXAuaHRtbCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNwYW4gPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnBlcmlvZFNwYW4uc2VsZWN0ZWRncm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNwYW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKG51bV9yZXNwb25zZXMgPiAxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWCA9IG51bV9yZXNwb25zZXMtMTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydE5EWCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFggPSBudW1fcmVzcG9uc2VzLTE7XG4gICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFggPSBudW1fcmVzcG9uc2VzLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjYikge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtzZXRJbmRleGVzIC0gdXNlZCB0byBpbml0aWFsaXplIHBlcmlvZCBzcGFuIHN0YXRlXVxuICAgICAqL1xuICAgICRzY29wZS5zZXRJbmRleGVzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIG51bV9yZXNwb25zZXMgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGEubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbaV0ucGVyaW9kLmRhdGUgPT09ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0LnBlcmlvZC5kYXRlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW2ldLnBlcmlvZC5kYXRlID09PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmQucGVyaW9kLmRhdGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kTkRYID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtmZXRjaFJlbGF0aW9uRGF0YSAtIGZldGNoIHJlc3BvbnNlcyBmb3IgYSBnaXZlbiByZWxhdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZmV0Y2hSZWxhdGlvbkRhdGEgPSBmdW5jdGlvbihjYikge1xuXG4gICAgICAgICRsb2cubG9nKCdmZXRjaFJlbGF0aW9uZGF0YSBydW5uaW5nJyk7XG5cbiAgICAgICAgLy8gc2FuaXR5IGNoZWNrIC0gTm8gbmVlZCB0byByZWRvIHdvcmtcbiAgICAgICAgaWYoJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICAkbG9nLmxvZygnTm90aGluZyB0byBkbycpO1xuICAgICAgICAgICAgaWYoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoISRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVsYXRpb24pIHtcbiAgICAgICAgICAgICRsb2cubG9nKCdFcnJvcjogTm8gcmVsYXRpb24gaGFzIGJlZW4gc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCEkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN0ZXApIHtcbiAgICAgICAgICAgICRsb2cubG9nKCdFcnJvcjogTm8gcmVsYXRpb24gc3RlcCBoYXMgYmVlbiBzZWxlY3RlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5mZXRjaGluZ0RhdGEgPSB0cnVlO1xuXG4gICAgICAgIHZhciBxdWVyeV9wYXJhbXMsIHF1ZXJ5X3N0cjtcbiAgICAgICAgcXVlcnlfcGFyYW1zID0gJyZyZWxhdGlvbl9pZD0nKyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVsYXRpb24uaWQrJyZzdGVwPScrJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdGVwO1xuICAgICAgICBxdWVyeV9zdHIgPSAnL2Ntcy93cC1hZG1pbi9hZG1pbi1hamF4LnBocD9hY3Rpb249Z2V0SGlzdG9yaWNhbFJlc3BvbnNlcycrcXVlcnlfcGFyYW1zO1xuXG4gICAgICAgIHJlc3RTZXJ2aWNlLnBvc3RTZXJ2ZXJEYXRhKHF1ZXJ5X3N0cikudGhlbihmdW5jdGlvbihyZXNwb25zZSlcbiAgICAgICAge1xuICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAkbG9nLmxvZygncmVzcG9uc2UnLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgIHZhciBudW1fcmVzcG9uc2VzID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmKG51bV9yZXNwb25zZXMgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVmZXJlbmNlRXZhbCA9IHJlc3BvbnNlW251bV9yZXNwb25zZXMtMV07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlUeXBlICAgID0gKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3RlcCA9PT0gJzM2MCcgPyAnY29tcGFueScgOiAnYWdlbmN5Jyk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHMgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWZlcmVuY2VFdmFsLmdyb3VwcztcblxuICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWZlcmVuY2VFdmFsO1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZCAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5yZWZlcmVuY2VFdmFsO1xuICAgICAgICAgICAgICAgICRzY29wZS5zZXRJbmRleGVzKCk7XG5cbiAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKFwicmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydFwiLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZihvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudmFsaWRhdGVFbmRQZXJpb2QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zZXRJbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5zZXRRdWFydGVySW50ZXJ2YWxzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0dXBHcmFwaERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChcInJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kXCIsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zZXRJbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5zZXRRdWFydGVySW50ZXJ2YWxzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0dXBHcmFwaERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb25lXG4gICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLmZldGNoaW5nRGF0YSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2V0dXBHcmFwaERhdGEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZihjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtnZXRHcm91cENvbG9yIC0gZ3JvdXAgY29sb3JzXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmR4IFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLmdldEdyb3VwQ29sb3IgPSBmdW5jdGlvbihuZHgpXG4gICAge1xuICAgICAgICB2YXIgZ3JvdXBfY29sb3IgPSAnJztcbiAgICAgICAgc3dpdGNoKG5keCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdyb3VwX2NvbG9yID0gJyNGOUZBRkMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdyb3VwX2NvbG9yID0gJyNGMUVERTYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGdyb3VwX2NvbG9yID0gJyNGMEYzRTknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGdyb3VwX2NvbG9yID0gJyNGRUY0RTgnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGdyb3VwX2NvbG9yID0gJyNGMUVERjknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBncm91cF9jb2xvciA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cF9jb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbZ2V0Um9sZUNvbG9yIC0gcm9sZSBjb2xvcnNdXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByb2xlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5nZXRSb2xlQ29sb3IgPSBmdW5jdGlvbihyb2xlKVxuICAgIHtcbiAgICAgICAgdmFyIHNlcmllc19jb2xvciA9ICcnO1xuICAgICAgICBpZihyb2xlID09PSAnVE0nKSB7XG4gICAgICAgICAgICBzZXJpZXNfY29sb3IgPSAnIzQwNDU2NSc7XG4gICAgICAgIH0gZWxzZSBpZihyb2xlID09PSAnT00nKSB7XG4gICAgICAgICAgICBzZXJpZXNfY29sb3IgPSAnIzY2NmZhNic7XG4gICAgICAgIH0gZWxzZSBpZihyb2xlID09PSAnT1AnKSB7XG4gICAgICAgICAgICBzZXJpZXNfY29sb3IgPSAnI2E1YWJjZCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzX2NvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFtnZXRSb2xlTmFtZSAtIGZ1bGwgcm9sZSBuYW1lXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcm9sZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0Um9sZU5hbWUgPSBmdW5jdGlvbihyb2xlKVxuICAgIHtcbiAgICAgICAgdmFyIHJvbGVfbmFtZSA9ICcnO1xuICAgICAgICBpZihyb2xlID09PSAnVE0nKSB7XG4gICAgICAgICAgICByb2xlX25hbWUgPSAnVE9QIE1BTkFHRU1FTlQnO1xuICAgICAgICB9IGVsc2UgaWYocm9sZSA9PT0gJ09NJykge1xuICAgICAgICAgICAgcm9sZV9uYW1lID0gJ09QRVJBVElPTkFMIE1BTkFHRU1FTlQnO1xuICAgICAgICB9IGVsc2UgaWYocm9sZSA9PT0gJ09QJykge1xuICAgICAgICAgICAgcm9sZV9uYW1lID0gJ09QRVJBVElPTkFMJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb2xlX25hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogW3NldHVwR3JhcGhEYXRhIC0gc2V0dXAgZGFzaGJvYXJkIGdyYXBoc11cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuc2V0dXBHcmFwaERhdGEgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICBpZighJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnQgfHwgISRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZCkge1xuICAgICAgICAgICAgJGxvZy5sb2coJ3NvbWV0aGluZyBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jID0gJGxvY2F0aW9uLnVybCgpXG4gICAgICAgIGlmKGxvYyA9PT0gJy9yZXBvcnRpbmcvZGFzaGJvYXJkJylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gcGxvdHNcbiAgICAgICAgICAgICRzY29wZS5zZXR1cERhc2hib2FyZFBhcnRpY2lwYW50R3JhcGgoKTtcbiAgICAgICAgICAgIGlmKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzLmhhc093blByb3BlcnR5KCdPUCcpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICRzY29wZS5zZXR1cERhc2hib2FyZEFsbENvcmVTdWJqZWN0c0dyYXBoKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBuZHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdyb3VwIGluICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddLmhhc093blByb3BlcnR5KGdyb3VwKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmR4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2V0dXBEYXNoYm9hcmRTaW5nbGVHcm91cEdyYXBoKGdyb3VwLCBuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtjYWxjRGFzaGJvYXJkUGFydGljaXBhbnRTZXJpZXMgLSBubyBjb21wYW55IGFnZW5jeSBzZWdtZW50YXRpb24gc28gd2UganVzdCB1c2UgYWxsRGF0YV1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuY2FsY0Rhc2hib2FyZFBhcnRpY2lwYW50U2VyaWVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcm9sZSBhdmcgc2VyaWVzXG4gICAgICAgIHZhciByb2xlX25keCAgPSAwO1xuICAgICAgICB2YXIgcm9sZV9hdmdzID0ge307XG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keCA8PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGlvbl9kYXRhID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gZXZhbHVhdGlvbl9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHNldHVwIG9ialxuICAgICAgICAgICAgICAgIGlmKCFyb2xlX2F2Z3MuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlX2F2Z3Nbcm9sZV0gPSB7bnVtZXJhdG9yOiAwLjAsIGRlbm9taW5hdG9yOiAwLjAsIG51bV9wYXJ0aWNpcGFudHM6IGV2YWx1YXRpb25fZGF0YVtyb2xlXS50b3R9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSByb2xlIGlmIG5vIHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJlc3BvbnNlIGluIGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGVfYXZnc1tyb2xlXS5udW1lcmF0b3IgKz0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3Jlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICAgICAgcm9sZV9hdmdzW3JvbGVdLmRlbm9taW5hdG9yKys7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIHJvbGUgcG9pbnRzICsgbWlnaHQgYXMgd2VsbCBkbyB0b3RhbCB3aGlsc3Qgd2UgYXJlIGl0ZXJhdGluZ1xuICAgICAgICB2YXIgcm9sZV9zZXJpZXMgPSBbXTtcbiAgICAgICAgdmFyIHRvdGFsX2FjY3VtID0ge251bWVyYXRvcjogMC4wLCBkZW5vbWluYXRvcjogMC4wfTtcbiAgICAgICAgZm9yICh2YXIgcm9sZSBpbiByb2xlX2F2Z3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwb2ludF92YWx1ZSA9IChyb2xlX2F2Z3Nbcm9sZV0uZGVub21pbmF0b3IgPiAwID8gcm9sZV9hdmdzW3JvbGVdLm51bWVyYXRvci9yb2xlX2F2Z3Nbcm9sZV0uZGVub21pbmF0b3IgOiAwLjApO1xuXG4gICAgICAgICAgICByb2xlX3Nlcmllcy5wdXNoKDEwKnBvaW50X3ZhbHVlKTtcbiAgICAgICAgICAgIHJvbGVfbmR4Kys7XG5cbiAgICAgICAgICAgIGlmKCFyb2xlX2F2Z3Nbcm9sZV0ubnVtX3BhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3RhbF9hY2N1bS5udW1lcmF0b3IgKz0gcG9pbnRfdmFsdWU7XG4gICAgICAgICAgICB0b3RhbF9hY2N1bS5kZW5vbWluYXRvcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG90YWwgPSBhdmVyYWdlIG9mIHJvbGVzXG4gICAgICAgIHZhciB0b3RhbF9wb2ludCA9ICh0b3RhbF9hY2N1bS5kZW5vbWluYXRvciA+IDAgPyB0b3RhbF9hY2N1bS5udW1lcmF0b3IvdG90YWxfYWNjdW0uZGVub21pbmF0b3IgOiAwLjApO1xuICAgICAgICByb2xlX3Nlcmllcy5wdXNoKDEwKnRvdGFsX3BvaW50KTtcblxuICAgICAgICByZXR1cm4gcm9sZV9zZXJpZXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogW3NldHVwRGFzaGJvYXJkUGFydGljaXBhbnRHcmFwaCAtIGRhc2hib2FyZCBwYXJ0aWNpcGFudCBncmFwaF1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuc2V0dXBEYXNoYm9hcmRQYXJ0aWNpcGFudEdyYXBoID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gc2V0dXAgb3B0aW9uc1xuICAgICAgICB2YXIgaGMgPSBuZXcgRWhpZ2hjaGFydHMoKTtcbiAgICAgICAgaGMuc2V0T3B0aW9ucygnZGFzaGJvYXJkLXBhcnRpY2lwYW50cycpO1xuXG4gICAgICAgIC8vIGdldCBjYXRlZ29yaWVzXG4gICAgICAgIHZhciByb2xlX2NhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm9sZSBpbiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnJlZmVyZW5jZUV2YWwuZGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucmVmZXJlbmNlRXZhbC5kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvbGVfY2F0ZWdvcmllcy5wdXNoKCRzY29wZS5nZXRSb2xlTmFtZShyb2xlKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBheGlzIGNhdHNcbiAgICAgICAgcm9sZV9jYXRlZ29yaWVzLnB1c2goJ09WRVJBTEwnKTtcbiAgICAgICAgaGMuYWRkWGF4aXMocm9sZV9jYXRlZ29yaWVzKTtcblxuICAgICAgICAvLyBhZGQgc2VyaWVzXG4gICAgICAgIHZhciByb2xlX3NlcmllcyA9ICRzY29wZS5jYWxjRGFzaGJvYXJkUGFydGljaXBhbnRTZXJpZXMoKTtcbiAgICAgICAgaGMuYWRkU2VyaWVzKCcnLCByb2xlX3Nlcmllcyk7XG5cbiAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5wbG90T3B0aW9ucy5kYXNoYm9hcmQucGFydGljaXBhbnRzID0gaGMuZ2V0T3B0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbY29ycmVjdGVkR0lEIC0gdXNlZCB0byBnZXQgdGhlIGdpZCBvZiBhIGRpZmZlcmVudCBldmFsIHNpbmNlIGVhY2ggbGltZXN1cnZleSB3aWxsIGhhdmUgZGlmZmVyZW50IGdyb3VwIElEJ3NdXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBldmFsX25keCBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBnaWQgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLmNvcnJlY3RlZEdJRCA9IGZ1bmN0aW9uKGV2YWxfbmR4LCBnaWQpIHtcblxuICAgICAgICBpZighJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW2V2YWxfbmR4XS5ncm91cHNbJ09NJ10uaGFzT3duUHJvcGVydHkoZ2lkKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyb3VwX25keCA9IF8uaW5kZXhPZihPYmplY3Qua2V5cygkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1snT00nXSksIGdpZCk7XG4gICAgICAgICAgICBpZihncm91cF9uZHggPT09IC0xKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICRsb2cubG9nKCdIb3BlbGVzczogY291bGQgbm90IG1hdGNoIEdJRCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvcnJlY3RlZF9naWQgPSBPYmplY3Qua2V5cygkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbZXZhbF9uZHhdLmdyb3Vwc1snT00nXSlbZ3JvdXBfbmR4XTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZF9naWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2lkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbY2FsY0Rhc2hib2FyZFNpbmdsZUdyb3VwU2VyaWVzIC0gZGFzaGJvYXJkIHNpbmdsZSBncm91cCBncmFwaHMgZGF0YV1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGdpZCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5jYWxjRGFzaGJvYXJkU2luZ2xlR3JvdXBTZXJpZXMgPSBmdW5jdGlvbihnaWQpIHtcblxuICAgICAgICAvLyBhZGQgYWdlbmN5IHNlcmllcy9wb2ludFxuICAgICAgICB2YXIgYWdlbmN5X3NlcmllcyAgPSBbXTtcbiAgICAgICAgdmFyIGNvbXBhbnlfc2VyaWVzID0gW107XG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keCA8PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmV3X2dpZCAgICAgICAgID0gJHNjb3BlLmNvcnJlY3RlZEdJRChuZHgsIGdpZCk7XG4gICAgICAgICAgICB2YXIgYWdlbmN5X2FjY3VtICAgID0ge251bWVyYXRvcjogMC4wLCBkZW5vbWluYXRvcjogMC4wfTtcbiAgICAgICAgICAgIHZhciBldmFsdWF0aW9uX2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5hZ2VuY3lfZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gZXZhbHVhdGlvbl9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0aW9uX2RhdGEuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtX3JvbGVfcGFydGljaXBhbnRzID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWyd0b3QnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3F1ZXN0aW9ucyAgICAgICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmdyb3Vwc1tyb2xlXVtuZXdfZ2lkXVsncXVlc3Rpb25zJ107XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzcG9uc2UgaW4gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl92YWxpZCA9IGdyb3VwX3F1ZXN0aW9ucy5pbmRleE9mKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihxdWVzdGlvbl92YWxpZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX3ZhbCA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXVtyZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW5jeV9hY2N1bS5udW1lcmF0b3IgKz0gcmVzcG9uc2VfdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VuY3lfYWNjdW0uZGVub21pbmF0b3IrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWdlbmN5X3RvdCA9IChhZ2VuY3lfYWNjdW0uZGVub21pbmF0b3IgPiAwID8gYWdlbmN5X2FjY3VtLm51bWVyYXRvciAvIGFnZW5jeV9hY2N1bS5kZW5vbWluYXRvciA6IDAuMCk7XG4gICAgICAgICAgICBhZ2VuY3lfc2VyaWVzLnB1c2goYWdlbmN5X3RvdCk7XG5cblxuICAgICAgICAgICAgLy8gYWRkIGNvbXBhbnkgc2VyaWVzL3BvaW50XG4gICAgICAgICAgICB2YXIgY29tcGFueV9hY2N1bSA9IHtudW1lcmF0b3I6IDAuMCwgZGVub21pbmF0b3I6IDAuMH07XG4gICAgICAgICAgICBldmFsdWF0aW9uX2RhdGEgICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmNvbXBhbnlfZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gZXZhbHVhdGlvbl9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0aW9uX2RhdGEuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtX3JvbGVfcGFydGljaXBhbnRzID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWyd0b3QnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3F1ZXN0aW9ucyAgICAgICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdW2dpZF1bJ3F1ZXN0aW9ucyddO1xuICAgICAgICAgICAgICAgICAgICBpZihudW1fcm9sZV9wYXJ0aWNpcGFudHMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJlc3BvbnNlIGluIGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVlc3Rpb25fdmFsaWQgPSBncm91cF9xdWVzdGlvbnMuaW5kZXhPZihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocXVlc3Rpb25fdmFsaWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAgcmVzcG9uc2VfdmFsID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3Jlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueV9hY2N1bS5udW1lcmF0b3IgKz0gcmVzcG9uc2VfdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYW55X2FjY3VtLmRlbm9taW5hdG9yKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbXBhbnlfdG90ID0gKGNvbXBhbnlfYWNjdW0uZGVub21pbmF0b3IgPiAwID8gY29tcGFueV9hY2N1bS5udW1lcmF0b3IgLyBjb21wYW55X2FjY3VtLmRlbm9taW5hdG9yIDogMC4wKTtcbiAgICAgICAgICAgIGNvbXBhbnlfc2VyaWVzLnB1c2goY29tcGFueV90b3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlcmllcyA9IHthZ2VuY3k6IGFnZW5jeV9zZXJpZXMsIGNvbXBhbnk6IGNvbXBhbnlfc2VyaWVzfTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbc2V0dXBEYXNoYm9hcmRTaW5nbGVHcm91cEdyYXBoIC0gZGFzaGJvYXJkIHNpbmdsZSBncm91cCBncmFwaCBvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZ2lkIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5keCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5zZXR1cERhc2hib2FyZFNpbmdsZUdyb3VwR3JhcGggPSBmdW5jdGlvbihnaWQsIGluZGV4KSB7XG5cbiAgICAgICAgLy8gc2V0dXAgZ3JhcGhcbiAgICAgICAgdmFyIGNoYXJ0T3B0aW9ucyA9IHJlcXVpcmUoJy4vY2hhcnRzL2NoYXJ0cy10ZW1wbGF0ZXMuanMnKTtcbiAgICAgICAgdmFyIHRtcF9vcHRpb25zICA9IGNoYXJ0T3B0aW9uc1snZGFzaGJvYXJkLXNpbmdsZWdyb3VwJ107XG4gICAgICAgIHZhciBvcHRpb25zICAgICAgPSBhbmd1bGFyLmV4dGVuZCh7fSwgdG1wX29wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNlcmllcyAgID0gW107XG5cbiAgICAgICAgJGxvZy5sb2coJ2xlbiAyJywgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhLmxlbmd0aCwgJ3N0YXJ0JywgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFgsICdlbmQnLCAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFgpO1xuICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydE5EWCAhPT0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kTkRYKSB7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLmdyaWRMaW5lV2lkdGggICAgICA9IDE7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLm1pbm9yR3JpZExpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzbWlub3JUaWNrTGVuZ3RoICAgICA9IDE7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLnRpY2tMZW5ndGggICAgICAgICA9IDE7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLmxhYmVscy5lbmFibGVkICAgICA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLmdyaWRMaW5lV2lkdGggICAgICA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLm1pbm9yR3JpZExpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzbWlub3JUaWNrTGVuZ3RoICAgICA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLnRpY2tMZW5ndGggICAgICAgICA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLnlBeGlzLmxhYmVscy5lbmFibGVkICAgICA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsYyBncm91cCBhdmVyYWdlIGJlbmNobWFya1xuICAgICAgICB2YXIgcm9sZV9iZW5jaG1hcmtzID0ge307XG4gICAgICAgIGZvciAodmFyIHJvbGUgaW4gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVuY2htYXJrX2FjY3VtID0ge251bWVyYXRvcjogMC4wLCBkZW5vbWluYXRvcjogMC4wLCBhdmc6IDAuMH07XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwX3F1ZXN0aW9ucyA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdW2dpZF1bJ3F1ZXN0aW9ucyddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHF1ZXN0aW9uIGluICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdW2dpZF1bJ3F1ZXN0aW9uX2JlbmNobWFya3MnXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl9iZW5jaG1hcmsgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVtnaWRdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcXVlc3Rpb25dO1xuICAgICAgICAgICAgICAgICAgICBiZW5jaG1hcmtfYWNjdW0ubnVtZXJhdG9yICs9IHF1ZXN0aW9uX2JlbmNobWFyaztcbiAgICAgICAgICAgICAgICAgICAgYmVuY2htYXJrX2FjY3VtLmRlbm9taW5hdG9yKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYmVuY2htYXJrX2FjY3VtLmF2ZyA9IChiZW5jaG1hcmtfYWNjdW0uZGVub21pbmF0b3IgPiAwID8gYmVuY2htYXJrX2FjY3VtLm51bWVyYXRvci9iZW5jaG1hcmtfYWNjdW0uZGVub21pbmF0b3IgOiAwLjApO1xuICAgICAgICAgICAgICAgIGlmKCFyb2xlX2JlbmNobWFya3MuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlX2JlbmNobWFya3Nbcm9sZV0gPSBiZW5jaG1hcmtfYWNjdW0uYXZnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGMgdG90YWwgYXZnIGJlbmNobWFya1xuICAgICAgICB2YXIgYmVuY2htYXJrX2F2ZyA9IHtudW1lcmF0b3I6IDAuMCwgZGVub21pbmF0b3I6IDAuMCwgYXZnOiAwLjB9O1xuICAgICAgICBmb3IgKHZhciByb2xlIGluIHJvbGVfYmVuY2htYXJrcylcbiAgICAgICAge1xuICAgICAgICAgICAgYmVuY2htYXJrX2F2Zy5udW1lcmF0b3IgKz0gcm9sZV9iZW5jaG1hcmtzW3JvbGVdO1xuICAgICAgICAgICAgYmVuY2htYXJrX2F2Zy5kZW5vbWluYXRvcisrO1xuICAgICAgICB9XG4gICAgICAgIGJlbmNobWFya19hdmcuYXZnID0gKGJlbmNobWFya19hdmcuZGVub21pbmF0b3IgPiAwID8gYmVuY2htYXJrX2F2Zy5udW1lcmF0b3IvYmVuY2htYXJrX2F2Zy5kZW5vbWluYXRvciA6IDAuMCk7XG5cbiAgICAgICAgLy8gYWdlbmN5ICsgY29tcGFueSBzZXJpZXNcbiAgICAgICAgdmFyIHNlcmllcyA9ICRzY29wZS5jYWxjRGFzaGJvYXJkU2luZ2xlR3JvdXBTZXJpZXMoZ2lkKTtcbiAgICAgICAgdmFyIGFnZW5jeV9kYXRhID0gW107XG4gICAgICAgIHZhciBjb21wYW55X2RhdGEgPSBbXTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxzZXJpZXMuYWdlbmN5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXJpZXMuYWdlbmN5W2ldICo9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHNlcmllcy5jb21wYW55Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXJpZXMuY29tcGFueVtpXSAqPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuc2VyaWVzLnB1c2goe25hbWU6ICdhZ2VuY3knLCB2aXNpYmxlOiBmYWxzZSwgZGF0YTogc2VyaWVzLmFnZW5jeSwgY29sb3I6JyNmMjhkNGYnfSk7XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzLnB1c2goe25hbWU6ICdjb21wYW55JywgdmlzaWJsZTogZmFsc2UsIGRhdGE6IHNlcmllcy5jb21wYW55LCBjb2xvcjonIzUxNjliMid9KTtcblxuICAgICAgICBvcHRpb25zLnlBeGlzLnBsb3RMaW5lcy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiAxMCpiZW5jaG1hcmtfYXZnLmF2ZyxcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgZGFzaFN0eWxlOiAnc2hvcnRkb3QnLFxuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICB6SW5kZXg6IDk5OVxuICAgICAgICB9KTtcblxuICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnBsb3RPcHRpb25zLmRhc2hib2FyZC5zaW5nbGVHcm91cFtnaWRdID0gb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2NhbGNBbGxDb3Jlc3ViamVjdHMgLSBkYXNoYm9hcmQgYWxsIGNvcmUgc3ViamVjdHMgZ3JhcGggZGF0YV1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLmNhbGNBbGxDb3Jlc3ViamVjdHMgPSBmdW5jdGlvbih0eXBlKSB7XG5cbiAgICAgICAgdmFyIHNlcmllcyA9IFtdO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgICAgIC8vIHNldHVwIGdyb3VwIGFjY3VtXG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kTkRYOyBuZHggPj0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keC0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcm9sZV9kYXRhID0ge307XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGlvbl9kYXRhID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF1bdHlwZSsnX2RhdGEnXTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gZXZhbHVhdGlvbl9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGV2YWx1YXRpb25fZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2N1bSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGdpZCBpbiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWFjY3VtLmhhc093blByb3BlcnR5KGdpZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bZ2lkXSA9IHtudW1lcmF0b3I6IDAuMCwgZGVub21pbmF0b3I6IDAuMCwgYXZnOiAwLjB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjIHJvbGUgcXVlc3Rpb25zIGF2Z1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihudW1fcm9sZV9wYXJ0aWNpcGFudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19naWQgICAgICAgICAgICAgID0gJHNjb3BlLmNvcnJlY3RlZEdJRChuZHgsIGdpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3JvbGVfcXVlc3Rpb25zID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZ3JvdXBzW3JvbGVdW25ld19naWRdWydxdWVzdGlvbnMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByZXNwb25zZSBpbiBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBxdWVzdGlvbiBpcyB2YWxpZCBmb3Igcm9sZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihncm91cF9yb2xlX3F1ZXN0aW9ucy5pbmRleE9mKHJlc3BvbnNlKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVtnaWRdLm51bWVyYXRvciArPSBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ11bcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bZ2lkXS5kZW5vbWluYXRvcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2dpZF0uYXZnID0gKGFjY3VtW2dpZF0uZGVub21pbmF0b3IgPiAwID8gYWNjdW1bZ2lkXS5udW1lcmF0b3IvYWNjdW1bZ2lkXS5kZW5vbWluYXRvciA6IDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZighcm9sZV9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlX2RhdGFbcm9sZV0gPSBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YS5wdXNoKHtkYXRlOiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5wZXJpb2QuZGF0ZSwgYWNjdW06IHJvbGVfZGF0YX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJGxvZy5sb2coJz4+PiBkYXRhJywgZGF0YSk7XG4gICAgICAgIHZhciBnaWRfYWNjdW0gPSB7fTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjdXJyX2RhdGEgPSBkYXRhW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiBjdXJyX2RhdGEuYWNjdW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJvbGVfYWdnciA9IGN1cnJfZGF0YS5hY2N1bVtyb2xlXTtcbiAgICAgICAgICAgICAgICBmb3IoZ2lkIGluIHJvbGVfYWdncilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2lkX2FjY3VtLmhhc093blByb3BlcnR5KGdpZCkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpZF9hY2N1bVtnaWRdID0ge251bWVyYXRvcjogMC4wLCBkZW5vbWluYXRvcjogMC4wfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJvbGVfYWdncltnaWRdLmRlbm9taW5hdG9yID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2lkX2FjY3VtW2dpZF0ubnVtZXJhdG9yICs9IHJvbGVfYWdncltnaWRdLmF2ZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdpZF9hY2N1bVtnaWRdLmRlbm9taW5hdG9yKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGdpZCBpbiBnaWRfYWNjdW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwb2ludF92YWwgPSAoZ2lkX2FjY3VtW2dpZF0uZGVub21pbmF0b3IgPiAwID8gZ2lkX2FjY3VtW2dpZF0ubnVtZXJhdG9yL2dpZF9hY2N1bVtnaWRdLmRlbm9taW5hdG9yIDogMC4wKTtcbiAgICAgICAgICAgIGlmKHR5cGUgPT09ICdhZ2VuY3knKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlcmllcy5wdXNoKHt5OiBwb2ludF92YWwsIG1hcmtlcjoge3N5bWJvbDogJ3VybCgvY29udGVudC90aGVtZXMvcHJvY3luYy9hcHAvYXNzZXRzL2ltYWdlcy9vcmFuZ2UucG5nKSd9fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcmllcy5wdXNoKHt5OiBwb2ludF92YWwsIG1hcmtlcjoge3N5bWJvbDogJ3VybCgvY29udGVudC90aGVtZXMvcHJvY3luYy9hcHAvYXNzZXRzL2ltYWdlcy9ibHVlLnBuZyknfX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbc2V0dXBEYXNoYm9hcmRBbGxDb3JlU3ViamVjdHNHcmFwaCAtIGRhc2hib2FyZCBhbGwgY29yZSBzdWJqZWN0cyBncmFwaCBvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZG9tX2lkICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gYWRkX2NhdGVnb3JpZXMgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5zZXR1cERhc2hib2FyZEFsbENvcmVTdWJqZWN0c0dyYXBoID0gZnVuY3Rpb24oaXNfZGFzaGJvYXJkKSB7XG5cbiAgICAgICAgdmFyIGhjID0gbmV3IEVoaWdoY2hhcnRzKCk7XG4gICAgICAgIHZhciBjaGFydF90ZW1wbGF0ZV9uYW1lID0gKGlzX2Rhc2hib2FyZCA/ICdkYXNoYm9hcmQtYWxsY29yZXN1YmplY3RzJyA6ICdhbGxjb3Jlc3ViamVjdHMnKTtcbiAgICAgICAgaGMuc2V0T3B0aW9ucyhjaGFydF90ZW1wbGF0ZV9uYW1lKTsvLyBzZXR1cCB4QXhpc1xuXG4gICAgICAgIC8vIGF4aXMgKyBjYXRzXG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIHZhciBheGlzX2RhdGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgZ3JvdXAgaW4gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbJ09QJ10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMucHVzaCgkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1snT1AnXVtncm91cF1bJ25hbWUnXS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBoYy5hZGRYYXhpcyhjYXRlZ29yaWVzKTtcblxuICAgICAgICB2YXIgYWdlbmN5X3NlcmllcyAgPSAkc2NvcGUuY2FsY0FsbENvcmVzdWJqZWN0cygnYWdlbmN5Jyk7XG4gICAgICAgIHZhciBjb21wYW55X3NlcmllcyA9ICRzY29wZS5jYWxjQWxsQ29yZXN1YmplY3RzKCdjb21wYW55Jyk7XG5cbiAgICAgICAgaGMuYWRkU2VyaWVzKCdhZ2VuY3knLCBhZ2VuY3lfc2VyaWVzLCAnI2YyOGQ0ZicpO1xuICAgICAgICBoYy5hZGRTZXJpZXMoJ2NvbXBhbnknLCBjb21wYW55X3NlcmllcywgJyM1MTY5YjInKTtcblxuICAgICAgICB2YXIgZ3JvdXBfYmVuY2htYXJrX2FjY3VtID0ge307XG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keCA8PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGlvbl9kYXRhID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uY29tcGFueV9kYXRhXG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGV2YWx1YXRpb25fZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbl9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZ2lkIGluICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0IGFjY3VtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZ3JvdXBfYmVuY2htYXJrX2FjY3VtLmhhc093blByb3BlcnR5KGdpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cF9iZW5jaG1hcmtfYWNjdW1bZ2lkXSA9IHtudW1lcmF0b3I6IDAuMCwgZGVub21pbmF0b3I6IDAuMCwgYXZnOiAwLjB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGNsaWVudCByb2xlIHJlc3BvbnNlIGF2Z3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1fcm9sZV9wYXJ0aWNpcGFudHMgPSBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ3RvdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3JvbGVfcXVlc3Rpb25zICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdW2dpZF1bJ3F1ZXN0aW9ucyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobnVtX3JvbGVfcGFydGljaXBhbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvbGVfcmVzcG9uc2UgaW4gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkX3JvbGVfcXVlc3Rpb24gPSBncm91cF9yb2xlX3F1ZXN0aW9ucy5pbmRleE9mKHJvbGVfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2YWxpZF9yb2xlX3F1ZXN0aW9uID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX2JlbmNobWFya19hY2N1bVtnaWRdLm51bWVyYXRvciArPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVtnaWRdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcm9sZV9yZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cF9iZW5jaG1hcmtfYWNjdW1bZ2lkXS5kZW5vbWluYXRvcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZW5jaG1hcmtfc2VyaWVzID0gW107XG4gICAgICAgIGZvcih2YXIgZ3JvdXAgaW4gZ3JvdXBfYmVuY2htYXJrX2FjY3VtKSB7XG5cbiAgICAgICAgICAgIGlmKGdyb3VwX2JlbmNobWFya19hY2N1bS5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgICAgICAgICBncm91cF9iZW5jaG1hcmtfYWNjdW1bZ3JvdXBdLmF2ZyA9IChncm91cF9iZW5jaG1hcmtfYWNjdW1bZ3JvdXBdLmRlbm9taW5hdG9yID4gMCA/IGdyb3VwX2JlbmNobWFya19hY2N1bVtncm91cF0ubnVtZXJhdG9yL2dyb3VwX2JlbmNobWFya19hY2N1bVtncm91cF0uZGVub21pbmF0b3IgOiAwLjApO1xuICAgICAgICAgICAgICAgIGJlbmNobWFya19zZXJpZXMucHVzaCh7eTogZ3JvdXBfYmVuY2htYXJrX2FjY3VtW2dyb3VwXS5hdmcsIG1hcmtlcjoge3N5bWJvbDogJ3VybCgvY29udGVudC90aGVtZXMvcHJvY3luYy9hcHAvYXNzZXRzL2ltYWdlcy9ibGFjay5wbmcpJ319KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhjLmFkZFNlcmllcygnYmVuY2htYXJrJywgYmVuY2htYXJrX3NlcmllcywgJyMwMDAwMDAnLCAnc2hvcnRkb3QnKTtcblxuICAgICAgICBpZihpc19kYXNoYm9hcmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucGxvdE9wdGlvbnMuZGFzaGJvYXJkLmNvcmVfc3VqZWN0cyA9IGhjLmdldE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQucGxvdE9wdGlvbnMuY29yZV9zdWplY3RzID0gaGMuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogW3Bsb3RTZWxlY3RlZEdyb3VwR3JhcGggLSBzZWxlY3RlZCBncm91cCBncmFwaCBkYXRhICsgb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuc2V0dXBTZWxlY3RlZEdyb3VwR3JhcGggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBzZXR1cCBncmFwaFxuICAgICAgICB2YXIgaGMgPSBuZXcgRWhpZ2hjaGFydHMoKTtcbiAgICAgICAgaGMuc2V0T3B0aW9ucygnc2VsZWN0ZWQtZ3JvdXAnKTtcblxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICB2YXIgYXhpc19kYXRlcyA9IFtdO1xuXG4gICAgICAgICRsb2cubG9nKCc+Pj4gc2VsZWN0ZWRHcm91cCcsICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXApO1xuXG4gICAgICAgIC8vIHNldHVwIHhBeGlzIGZvciBkYXRhIGdyb3VwaW5nXG4gICAgICAgIHZhciBncm91cF9xdWVzdGlvbnMgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1snT1AnXVskc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwXVsncXVlc3Rpb25zJ107XG4gICAgICAgIGZvcih2YXIgcSBpbiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1snT1AnXVskc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwXVsncXVlc3Rpb25zX3R4dCddKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbJ09QJ11bJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cF1bJ3F1ZXN0aW9uc190eHQnXVtxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhjLmFkZFhheGlzKGNhdGVnb3JpZXMpO1xuXG4gICAgICAgIC8vIHJvbGVzIHNlcmllc1xuICAgICAgICB2YXIgYWxsRGF0YSA9IFtdO1xuICAgICAgICBmb3IodmFyIG5keCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWDsgbmR4ID49ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYOyBuZHgtLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFjY3VtICAgICAgICAgICA9IHtkYXRlOiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5wZXJpb2QuZGF0ZSwgcm9sZV9kYXRhOiB7fSwgcm9sZV9xdWVzdGlvbnM6IHt9fTtcbiAgICAgICAgICAgIHZhciBldmFsdWF0aW9uX2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5kYXRhO1xuICAgICAgICAgICAgJGxvZy5sb2coJz4+PiBldmFsdWF0aW9uX2RhdGEnLCAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XSk7XG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGV2YWx1YXRpb25fZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbl9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIWFjY3VtLnJvbGVfZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW0ucm9sZV9kYXRhW3JvbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZighYWNjdW0ucm9sZV9xdWVzdGlvbnMuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtLnJvbGVfcXVlc3Rpb25zW3JvbGVdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19naWQgPSAkc2NvcGUuY29ycmVjdGVkR0lEKG5keCwgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cF9xdWVzdGlvbnMgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZ3JvdXBzW3JvbGVdW25ld19naWRdWydxdWVzdGlvbnMnXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcXVlc3Rpb24gaW4gZ3JvdXBfcXVlc3Rpb25zKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ10uaGFzT3duUHJvcGVydHkoZ3JvdXBfcXVlc3Rpb25zW3F1ZXN0aW9uXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW0ucm9sZV9kYXRhW3JvbGVdLnB1c2goMTAqZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW2dyb3VwX3F1ZXN0aW9uc1txdWVzdGlvbl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bS5yb2xlX3F1ZXN0aW9uc1tyb2xlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtLnJvbGVfZGF0YVtyb2xlXS5wdXNoKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWxsRGF0YS5wdXNoKGFjY3VtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvbGUgZGF0YVxuICAgICAgICAkbG9nLmxvZygnPj4+Pj4gYWxsRGF0YScsIGFsbERhdGEsICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYLCAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFgpO1xuICAgICAgICBmb3IodmFyIGV2YWx1YXRpb24gaW4gYWxsRGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgJGxvZy5sb2coJ2V2YWwnLCBhbGxEYXRhW2V2YWx1YXRpb25dKTtcbiAgICAgICAgICAgIGZvcih2YXIgcm9sZSBpbiBhbGxEYXRhW2V2YWx1YXRpb25dLnJvbGVfZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihhbGxEYXRhW2V2YWx1YXRpb25dLnJvbGVfZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNfY29sb3IgPSAkc2NvcGUuZ2V0Um9sZUNvbG9yKHJvbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYy5hZGRTZXJpZXMocm9sZSthbGxEYXRhW2V2YWx1YXRpb25dLmRhdGUsIGFsbERhdGFbZXZhbHVhdGlvbl0ucm9sZV9kYXRhW3JvbGVdLCBzZXJpZXNfY29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsX3NlcmllcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRvdGFsX2FjY3VtICA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiBhbGxEYXRhW2V2YWx1YXRpb25dLnJvbGVfZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHEgaW4gYWxsRGF0YVtldmFsdWF0aW9uXS5yb2xlX2RhdGFbcm9sZV0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZighdG90YWxfYWNjdW0uaGFzT3duUHJvcGVydHkocSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX2FjY3VtW3FdID0ge251bWVyYXRvcjogMC4wLCBkZW5vbWluYXRvcjogMC4wLCBhdmc6IDAuMH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihhbGxEYXRhW2V2YWx1YXRpb25dLnJvbGVfZGF0YVtyb2xlXVtxXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX2FjY3VtW3FdLm51bWVyYXRvciArPSBhbGxEYXRhW2V2YWx1YXRpb25dLnJvbGVfZGF0YVtyb2xlXVtxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX2FjY3VtW3FdLmRlbm9taW5hdG9yKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgcSBpbiB0b3RhbF9hY2N1bSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkbG9nLmxvZygndGEnLCB0b3RhbF9hY2N1bVtxXSk7XG4gICAgICAgICAgICAgICAgdG90YWxfYWNjdW1bcV0uYXZnID0gKHRvdGFsX2FjY3VtW3FdLmRlbm9taW5hdG9yID4gMCA/IHRvdGFsX2FjY3VtW3FdLm51bWVyYXRvci90b3RhbF9hY2N1bVtxXS5kZW5vbWluYXRvciA6IDApO1xuICAgICAgICAgICAgICAgIHRvdGFsX3Nlcmllcy5wdXNoKHRvdGFsX2FjY3VtW3FdLmF2Zyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhjLmFkZFNlcmllcygndG90YWwnK2FsbERhdGFbZXZhbHVhdGlvbl0uZGF0ZSwgdG90YWxfc2VyaWVzLCAnIzcyNWEwYicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVuY2htYXJrXG4gICAgICAgIHZhciBiZW5jaG1hcmtfc2VyaWVzID0gW107XG4gICAgICAgIHZhciBudW1fcmVzcG9uc2VzICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGJlbmNobWFya19kYXRhICAgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbnVtX3Jlc3BvbnNlcyAtIDFdLmdyb3Vwc1snT1AnXVskc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwXS5xdWVzdGlvbl9iZW5jaG1hcmtzO1xuICAgICAgICBmb3IodmFyIGJlbmNoIGluIGJlbmNobWFya19kYXRhKSB7XG4gICAgICAgICAgICBiZW5jaG1hcmtfc2VyaWVzLnB1c2goMTAqYmVuY2htYXJrX2RhdGFbYmVuY2hdKTtcbiAgICAgICAgfVxuICAgICAgICBoYy5hZGRTZXJpZXMoJ2JlbmNobWFyaycsIGJlbmNobWFya19zZXJpZXMsICcjMDAwMDAwJyk7XG5cbiAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5wbG90T3B0aW9ucy5zZWxlY3RlZEdyb3VwID0gaGMuZ2V0T3B0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbZ2V0SWNvbkNsYXNzIC0gd3JhcHBlciBjbGFzcyBmb3IgZGlzcGxheWluZyB0aGUgaWNvbnNdXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBudW1iZXIgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cbiAgICAgICAgbnVtYmVyID0gTWF0aC5hYnMobnVtYmVyKTtcbiAgICAgICAgaWYgKG51bWJlciA8PSAwLjIpIHtcbiAgICAgICAgICAgIHJldHVybiAncGVyZm9ybWFuY2UtaWNvbiBpY29uLWdvb2QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXIgPiAwLjIgJiYgbnVtYmVyIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAncGVyZm9ybWFuY2UtaWNvbiBpY29uLWltcHJvdmVtZW50cy1uZWVkZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXIgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BlcmZvcm1hbmNlLWljb24gaWNvbi1pbW1lZGlhdGUtYWN0aW9uJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbZ2V0Q2xpZW50dnNCZW5jaG1hcmsgLSBjYWxjdWxhdGUgY2xpZW50LWJlbmNobWFyayBhdmcgZm9yIGEgZ3JvdXBdXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBnaWQgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0Q2xpZW50dnNCZW5jaG1hcmsgPSBmdW5jdGlvbihnaWQpIHtcblxuICAgICAgICB2YXIgY29tcGFueV90b3QgID0gMC4wO1xuICAgICAgICB2YXIgYWNjdW1fY2xpZW50X3JvbGVfd2VpZ2h0cyA9IDAuMDtcbiAgICAgICAgZm9yKHZhciBuZHggPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCA+PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydE5EWDsgbmR4LS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBldmFsdWF0aW9uX2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5jb21wYW55X2RhdGFcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gZXZhbHVhdGlvbl9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0aW9uX2RhdGEuaGFzT3duUHJvcGVydHkocm9sZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGNsaWVudCByb2xlIHJlc3BvbnNlIGF2Z3NcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdfZ2lkICAgICAgICAgICAgICAgPSAkc2NvcGUuY29ycmVjdGVkR0lEKG5keCwgZ2lkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3JvbGVfcXVlc3Rpb25zICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmdyb3Vwc1tyb2xlXVtuZXdfZ2lkXVsncXVlc3Rpb25zJ107XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm9sZV9yZXNwb25zZSBpbiBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkX3JvbGVfcXVlc3Rpb24gPSBncm91cF9yb2xlX3F1ZXN0aW9ucy5pbmRleE9mKHJvbGVfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbGlkX3JvbGVfcXVlc3Rpb24gPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV92YWx1ZSAgICAgPSBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ11bcm9sZV9yZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9iZW5jaG1hcmsgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVtnaWRdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcm9sZV9yZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhbnlfdG90ICs9IChyZXNwb25zZV92YWx1ZSAtIHJlc3BvbnNlX2JlbmNobWFyayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtX2NsaWVudF9yb2xlX3dlaWdodHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IChhY2N1bV9jbGllbnRfcm9sZV93ZWlnaHRzID4gMCA/IGNvbXBhbnlfdG90IC8gYWNjdW1fY2xpZW50X3JvbGVfd2VpZ2h0cyA6IDAuMCk7XG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldENsaWVudHZzQWdlbmN5QmVuY2htYXJrIC0gY2FsY3VsYXRlIGNsaWVudEF2Zy1hZ2VuY3lBdmcgZm9yIGEgZ3JvdXBdXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBnaWQgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0Q2xpZW50dnNBZ2VuY3lCZW5jaG1hcmsgPSBmdW5jdGlvbihnaWQpIHtcblxuICAgICAgICAvLyBhZGQgYWdlbmN5IHNlcmllcy9wb2ludFxuICAgICAgICB2YXIgYWdlbmN5X3RvdCA9IDAuMDtcbiAgICAgICAgdmFyIGFnZW5jeV93ZWlnaHRzX2FjY3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIG5keCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWDsgbmR4ID49ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYOyBuZHgtLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRpb25fZGF0YSA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmFnZW5jeV9kYXRhXG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGV2YWx1YXRpb25fZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbl9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19naWQgICAgICAgICAgICAgICA9ICRzY29wZS5jb3JyZWN0ZWRHSUQobmR4LCBnaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBfcXVlc3Rpb25zICAgICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZ3JvdXBzW3JvbGVdW25ld19naWRdWydxdWVzdGlvbnMnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzcG9uc2UgaW4gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl92YWxpZCA9IGdyb3VwX3F1ZXN0aW9ucy5pbmRleE9mKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihxdWVzdGlvbl92YWxpZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX3ZhbHVlID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3Jlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbmN5X3RvdCArPSByZXNwb25zZV92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbmN5X3dlaWdodHNfYWNjdW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNvbXBhbnkgc2VyaWVzL3BvaW50XG4gICAgICAgIHZhciBjb21wYW55X3RvdCAgICAgICAgICAgPSAwLjA7XG4gICAgICAgIHZhciBjb21wYW55X3dlaWdodHNfYWNjdW0gPSAwLjA7XG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kTkRYOyBuZHggPj0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keC0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGlvbl9kYXRhID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uY29tcGFueV9kYXRhXG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGV2YWx1YXRpb25fZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbl9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19naWQgICAgICAgICAgICAgICA9ICRzY29wZS5jb3JyZWN0ZWRHSUQobmR4LCBnaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBfcXVlc3Rpb25zICAgICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZ3JvdXBzW3JvbGVdW25ld19naWRdWydxdWVzdGlvbnMnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzcG9uc2UgaW4gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl92YWxpZCA9IGdyb3VwX3F1ZXN0aW9ucy5pbmRleE9mKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihxdWVzdGlvbl92YWxpZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX3ZhbHVlID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3Jlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueV90b3QgKz0gcmVzcG9uc2VfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhbnlfd2VpZ2h0c19hY2N1bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWdlbmN5X2F2ZyAgPSBhZ2VuY3lfd2VpZ2h0c19hY2N1bSA+IDAgPyBhZ2VuY3lfdG90L2FnZW5jeV93ZWlnaHRzX2FjY3VtIDogMC4wO1xuICAgICAgICB2YXIgY29tcGFueV9hdmcgPSBjb21wYW55X3dlaWdodHNfYWNjdW0gPiAwID8gY29tcGFueV90b3QvY29tcGFueV93ZWlnaHRzX2FjY3VtIDogMC4wO1xuXG4gICAgICAgIHZhciByZXQgPSBjb21wYW55X2F2ZyAtIGFnZW5jeV9hdmc7XG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldE92ZXJhbGxCZW5jaG1hcmsgLSBjYWxjdWxhdGUgb3ZlcmFsbCByZXBvbnNlIGF2ZyBmb3IgYSBncm91cF1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGdpZCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5nZXRPdmVyYWxsQmVuY2htYXJrID0gZnVuY3Rpb24oZ2lkKSB7XG5cbiAgICAgICAgLy8gYWRkIGFnZW5jeSBzZXJpZXMvcG9pbnRcbiAgICAgICAgdmFyIGFnZW5jeV90b3QgICAgICAgICAgICA9IDAuMDtcbiAgICAgICAgdmFyIGFnZW5jeV93ZWlnaHRzX2FjY3VtICA9IDAuMDtcblxuICAgICAgICAvLyBhZGQgY29tcGFueSBzZXJpZXMvcG9pbnRcbiAgICAgICAgdmFyIGNvbXBhbnlfdG90ICAgICAgICAgICA9IDAuMDtcbiAgICAgICAgdmFyIGNvbXBhbnlfd2VpZ2h0c19hY2N1bSA9IDAuMDtcblxuICAgICAgICBmb3IodmFyIG5keCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWDsgbmR4ID49ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYOyBuZHgtLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRpb25fZGF0YSA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmFnZW5jeV9kYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiBldmFsdWF0aW9uX2RhdGEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRpb25fZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdfZ2lkICAgICAgICAgICAgICAgPSAkc2NvcGUuY29ycmVjdGVkR0lEKG5keCwgZ2lkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwX3F1ZXN0aW9ucyAgICAgICA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmdyb3Vwc1tyb2xlXVtuZXdfZ2lkXVsncXVlc3Rpb25zJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1fcm9sZV9wYXJ0aWNpcGFudHMgPSBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ3RvdCddO1xuICAgICAgICAgICAgICAgICAgICBpZihudW1fcm9sZV9wYXJ0aWNpcGFudHMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJlc3BvbnNlIGluIGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVlc3Rpb25fdmFsaWQgPSBncm91cF9xdWVzdGlvbnMuaW5kZXhPZihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocXVlc3Rpb25fdmFsaWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV92YWx1ZSAgICAgPSBldmFsdWF0aW9uX2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ11bcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfYmVuY2htYXJrID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbcm9sZV1bZ2lkXVsncXVlc3Rpb25fYmVuY2htYXJrcyddW3Jlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbmN5X3RvdCArPSAocmVzcG9uc2VfdmFsdWUgLSByZXNwb25zZV9iZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VuY3lfd2VpZ2h0c19hY2N1bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2YWx1YXRpb25fZGF0YSA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuYWxsRGF0YVtuZHhdLmNvbXBhbnlfZGF0YVxuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmNvbXBhbnlfZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGlvbl9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19naWQgICAgICAgICAgICAgICA9ICRzY29wZS5jb3JyZWN0ZWRHSUQobmR4LCBnaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBfcXVlc3Rpb25zICAgICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uZ3JvdXBzW3JvbGVdW25ld19naWRdWydxdWVzdGlvbnMnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzcG9uc2UgaW4gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl92YWxpZCA9IGdyb3VwX3F1ZXN0aW9ucy5pbmRleE9mKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihxdWVzdGlvbl92YWxpZCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX3ZhbHVlICAgICA9IGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXVtyZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9iZW5jaG1hcmsgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVtnaWRdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcmVzcG9uc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYW55X3RvdCArPSAocmVzcG9uc2VfdmFsdWUgLSByZXNwb25zZV9iZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYW55X3dlaWdodHNfYWNjdW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bWVyYXRvciAgID0gKGFnZW5jeV90b3QgKyBjb21wYW55X3RvdCk7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IChhZ2VuY3lfd2VpZ2h0c19hY2N1bSArIGNvbXBhbnlfd2VpZ2h0c19hY2N1bSk7XG4gICAgICAgIGlmKGRlbm9taW5hdG9yIDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgICRsb2cubG9nKCdnZXRPdmVyYWxsQmVuY2htYXJrIEVycm9yOiBkZW5vbWluYXRvciA8PSAwJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gZGVub21pbmF0b3IgPiAwID8gbnVtZXJhdG9yL2Rlbm9taW5hdG9yIDogLTk5OTk7XG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldFFDbGllbnR2c0JlbmNobWFyayAtIGNhbGN1bGF0ZSBjbGllbnQtYmVuY2htYXJrIGF2ZyBmb3IgYSBxdWVzdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHF1ZXN0aW9uIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0UUNsaWVudHZzQmVuY2htYXJrID0gZnVuY3Rpb24ocXVlc3Rpb24pIHtcblxuICAgICAgICAvL2NhbGNcbiAgICAgICAgdmFyIHF1ZXN0aW9uX3RvdCAgID0gMC4wO1xuICAgICAgICB2YXIgcXVlc3Rpb25fYWNjdW0gPSAwLjA7XG4gICAgICAgIGZvcih2YXIgbmR4ID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uRW5kTkRYOyBuZHggPj0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5ldmFsdWF0aW9uU3RhcnRORFg7IG5keC0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGlvbl9kYXRhICAgID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uY29tcGFueV9kYXRhO1xuICAgICAgICAgICAgdmFyIHF1ZXN0aW9uX2JlbmNobWFyayA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddWyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXBdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcXVlc3Rpb25dO1xuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiBldmFsdWF0aW9uX2RhdGEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRpb25fZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGV2YWx1YXRpb25fZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXS5oYXNPd25Qcm9wZXJ0eShxdWVzdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdWyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXBdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ10uaGFzT3duUHJvcGVydHkocXVlc3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtX3JvbGVfcGFydGljaXBhbnRzID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWyd0b3QnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfdmFsdWUgICAgID0gZXZhbHVhdGlvbl9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3F1ZXN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfYmVuY2htYXJrID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbcm9sZV1bJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cF1bJ3F1ZXN0aW9uX2JlbmNobWFya3MnXVtxdWVzdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb25fdG90ICs9IChyZXNwb25zZV92YWx1ZSAtIHJlc3BvbnNlX2JlbmNobWFyayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlc3Rpb25fYWNjdW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSAocXVlc3Rpb25fYWNjdW0gPiAwID8gKHF1ZXN0aW9uX3RvdC9xdWVzdGlvbl9hY2N1bSk6IDAuMCk7XG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldFFDbGllbnR2c0FnZW5jeUJlbmNobWFyayAtIGNhbGN1bGF0ZSBjbGllbnRBdmctYWdlbmN5QXZnIGZvciBhIGdyb3VwXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcXVlc3Rpb24gW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5nZXRRQ2xpZW50dnNBZ2VuY3lCZW5jaG1hcmsgPSBmdW5jdGlvbihxdWVzdGlvbikge1xuXG4gICAgICAgIC8vIGNvbXBhbnlcbiAgICAgICAgdmFyIGNvbXBhbnlfdG90ICAgPSAwLjA7XG4gICAgICAgIHZhciBjb21wYW55X2FjY3VtID0gMC4wO1xuXG4gICAgICAgIC8vIGFnZW5jeVxuICAgICAgICB2YXIgYWdlbmN5X3RvdCAgICA9IDAuMDtcbiAgICAgICAgdmFyIGFnZW5jeV9hY2N1bSAgPSAwLjA7XG5cbiAgICAgICAgZm9yKHZhciBuZHggPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCA+PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydE5EWDsgbmR4LS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjb21wYW55X2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5jb21wYW55X2RhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGNvbXBhbnlfZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFueV9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29tcGFueV9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddLmhhc093blByb3BlcnR5KHF1ZXN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbcm9sZV1bJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cF1bJ3F1ZXN0aW9uX2JlbmNobWFya3MnXS5oYXNPd25Qcm9wZXJ0eShxdWVzdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1fcm9sZV9wYXJ0aWNpcGFudHMgPSBjb21wYW55X2RhdGFbcm9sZV1bJ3RvdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobnVtX3JvbGVfcGFydGljaXBhbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV92YWx1ZSA9IGNvbXBhbnlfZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXVtxdWVzdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueV90b3QgKz0gcmVzcG9uc2VfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueV9hY2N1bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWdlbmN5X2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5hZ2VuY3lfZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gYWdlbmN5X2RhdGEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGFnZW5jeV9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoYWdlbmN5X2RhdGFbcm9sZV1bJ2N1bXVsYXRpdmVfcXVlc3Rpb25fc2NvcmVzJ10uaGFzT3duUHJvcGVydHkocXVlc3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVskc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwXVsncXVlc3Rpb25fYmVuY2htYXJrcyddLmhhc093blByb3BlcnR5KHF1ZXN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bV9yb2xlX3BhcnRpY2lwYW50cyA9IGFnZW5jeV9kYXRhW3JvbGVdWyd0b3QnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG51bV9yb2xlX3BhcnRpY2lwYW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfdmFsdWUgPSBhZ2VuY3lfZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXVtxdWVzdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbmN5X3RvdCArPSByZXNwb25zZV92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VuY3lfYWNjdW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhZ2VuY3lfYXZnICA9IGFnZW5jeV9hY2N1bSA+IDAgPyBhZ2VuY3lfdG90L2FnZW5jeV9hY2N1bSA6IDAuMDtcbiAgICAgICAgdmFyIGNvbXBhbnlfYXZnID0gY29tcGFueV9hY2N1bSA+IDAgPyBjb21wYW55X3RvdC9jb21wYW55X2FjY3VtIDogMC4wO1xuICAgICAgICB2YXIgcmV0ID0gY29tcGFueV9hdmcgLSBhZ2VuY3lfYXZnO1xuXG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldFFPdmVyYWxsQmVuY2htYXJrIC0gY2FsY3VsYXRlIG92ZXJhbGwgcmVwb25zZSBhdmcgZm9yIGEgcXVlc3Rpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBxdWVzdGlvbiBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLmdldFFPdmVyYWxsQmVuY2htYXJrID0gZnVuY3Rpb24ocXVlc3Rpb24pIHtcblxuICAgICAgICAvLyBjb21wYW55XG4gICAgICAgIHZhciBjb21wYW55X3RvdCAgID0gMC4wO1xuICAgICAgICB2YXIgY29tcGFueV9hY2N1bSA9IDAuMDtcbiAgICAgICAgZm9yKHZhciBuZHggPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25FbmRORFg7IG5keCA+PSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmV2YWx1YXRpb25TdGFydE5EWDsgbmR4LS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjb21wYW55X2RhdGEgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLmFsbERhdGFbbmR4XS5jb21wYW55X2RhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGNvbXBhbnlfZGF0YSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFueV9kYXRhLmhhc093blByb3BlcnR5KHJvbGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY29tcGFueV9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddLmhhc093blByb3BlcnR5KHF1ZXN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbcm9sZV1bJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cF1bJ3F1ZXN0aW9uX2JlbmNobWFya3MnXS5oYXNPd25Qcm9wZXJ0eShxdWVzdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1fcm9sZV9wYXJ0aWNpcGFudHMgPSBjb21wYW55X2RhdGFbcm9sZV1bJ3RvdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobnVtX3JvbGVfcGFydGljaXBhbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9iZW5jaG1hcmsgPSAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwc1tyb2xlXVskc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwXVsncXVlc3Rpb25fYmVuY2htYXJrcyddW3F1ZXN0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VfdmFsdWUgICAgID0gY29tcGFueV9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddW3F1ZXN0aW9uXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhbnlfdG90ICs9IChyZXNwb25zZV92YWx1ZSAtIHJlc3BvbnNlX2JlbmNobWFyayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueV9hY2N1bSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWdlbmN5XG4gICAgICAgIHZhciBhZ2VuY3lfdG90ID0gMC4wO1xuICAgICAgICB2YXIgYWdlbmN5X2FjY3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIG5keCA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvbkVuZE5EWDsgbmR4ID49ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuZXZhbHVhdGlvblN0YXJ0TkRYOyBuZHgtLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFnZW5jeV9kYXRhID0gJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5hbGxEYXRhW25keF0uYWdlbmN5X2RhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGFnZW5jeV9kYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhZ2VuY3lfZGF0YS5oYXNPd25Qcm9wZXJ0eShyb2xlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFnZW5jeV9kYXRhW3JvbGVdWydjdW11bGF0aXZlX3F1ZXN0aW9uX3Njb3JlcyddLmhhc093blByb3BlcnR5KHF1ZXN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbcm9sZV1bJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zaW5nbGVHcm91cF1bJ3F1ZXN0aW9uX2JlbmNobWFya3MnXS5oYXNPd25Qcm9wZXJ0eShxdWVzdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1fcm9sZV9wYXJ0aWNpcGFudHMgPSBhZ2VuY3lfZGF0YVtyb2xlXVsndG90J107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihudW1fcm9sZV9wYXJ0aWNpcGFudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlX2JlbmNobWFyayA9ICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzW3JvbGVdWyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXBdWydxdWVzdGlvbl9iZW5jaG1hcmtzJ11bcXVlc3Rpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV92YWx1ZSAgICAgPSBhZ2VuY3lfZGF0YVtyb2xlXVsnY3VtdWxhdGl2ZV9xdWVzdGlvbl9zY29yZXMnXVtxdWVzdGlvbl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VuY3lfdG90ICs9IChyZXNwb25zZV92YWx1ZSAtIHJlc3BvbnNlX2JlbmNobWFyayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbmN5X2FjY3VtKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gKChjb21wYW55X3RvdCArIGFnZW5jeV90b3QpLyhjb21wYW55X2FjY3VtICsgYWdlbmN5X2FjY3VtKSk7XG4gICAgICAgIHJldHVybiByZXQudG9GaXhlZCgxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dldENvbHVtbnNDbGFzcyBkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0Q29sdW1uc0NsYXNzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHJldCA9ICcnO1xuICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3VwcyAmJiAkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnN1cnZleUdyb3Vwcy5oYXNPd25Qcm9wZXJ0eSgnT1AnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG51bV9ncm91cHMgICAgICAgID0gT2JqZWN0LmtleXMoJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHNbJ09QJ10pLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgbnVtX2NvbHNfcGVyX2l0ZW0gPSBNYXRoLmZsb29yKDEyIC8gbnVtX2dyb3Vwcyk7XG4gICAgICAgICAgICByZXQgICAgICAgICAgICAgICAgICAgPSAnY29sLXNtLScrbnVtX2NvbHNfcGVyX2l0ZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbZ2V0UXVlc3Rpb25zQ29sdW1uc0NsYXNzIGRlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICRzY29wZS5nZXRRdWVzdGlvbnNDb2x1bW5zQ2xhc3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcmV0ID0gJyc7XG4gICAgICAgIGlmKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzLmhhc093blByb3BlcnR5KCdPUCcpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddLmhhc093blByb3BlcnR5KCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBudW1fcXVlc3Rpb25zICAgICA9IE9iamVjdC5rZXlzKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddWyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXBdWydxdWVzdGlvbnMnXSkubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtX2NvbHNfcGVyX2l0ZW0gPSBNYXRoLmZsb29yKDEyIC8gbnVtX3F1ZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0ICAgICAgICAgICAgICAgICAgID0gJ2NvbC1zbS0nK251bV9jb2xzX3Blcl9pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2dldFF1ZXN0aW9uc0NvbHVtbnNDbGFzc0NvbXBsZW1lbnQgZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJHNjb3BlLmdldFF1ZXN0aW9uc0NvbHVtbnNDbGFzc0NvbXBsZW1lbnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcmV0ID0gJyc7XG4gICAgICAgIGlmKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzLmhhc093blByb3BlcnR5KCdPUCcpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZigkc2NvcGUucmVwb3J0aW5nLnNlbGVjdGVkLnNpbmdsZUdyb3VwICYmICRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddLmhhc093blByb3BlcnR5KCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBudW1fcXVlc3Rpb25zICAgICA9IE9iamVjdC5rZXlzKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddWyRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc2luZ2xlR3JvdXBdWydxdWVzdGlvbnMnXSkubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtX2NvbHNfcGVyX2l0ZW0gPSBNYXRoLmZsb29yKDEyIC8gbnVtX3F1ZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0ICAgICAgICAgICAgICAgICAgID0gJ2NvbC1zbS0nKygxMi1udW1fY29sc19wZXJfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbZ2V0Q29sdW1uc0NsYXNzQ29tcGxlbWVudCBkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0Q29sdW1uc0NsYXNzQ29tcGxlbWVudCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICAgaWYoJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHMgJiYgJHNjb3BlLnJlcG9ydGluZy5zZWxlY3RlZC5zdXJ2ZXlHcm91cHMuaGFzT3duUHJvcGVydHkoJ09QJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBudW1fZ3JvdXBzICAgICAgICA9IE9iamVjdC5rZXlzKCRzY29wZS5yZXBvcnRpbmcuc2VsZWN0ZWQuc3VydmV5R3JvdXBzWydPUCddKS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgdmFyIG51bV9jb2xzX3Blcl9pdGVtID0gTWF0aC5mbG9vcigxMiAvIG51bV9ncm91cHMpO1xuICAgICAgICAgICAgcmV0ICAgICAgICAgICAgICAgICAgID0gJ2NvbC1zbS0nKygxMi1udW1fY29sc19wZXJfaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbZ2V0R3JvdXBzQ2xhc3MgZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBncm91cF9uZHggW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAkc2NvcGUuZ2V0R3JvdXBzQ2xhc3MgPSBmdW5jdGlvbihncm91cF9uZHgpIHtcblxuICAgICAgICB2YXIgZ3JvdXBzX2NsYXNzID0gJyc7XG5cbiAgICAgICAgc3dpdGNoKGdyb3VwX25keCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjEnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgIGdyb3Vwc19jbGFzcyA9ICdncm91cC1jb2xvcjEnO1xuICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cHNfY2xhc3M7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBbd2FpdEZvclJlbmRlckFuZERvU29tZXRoaW5nIGRlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHZhciB3YWl0Rm9yUmVuZGVyQW5kRG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgdGVtcGxhdGVzIHRvIGJlIGxvYWRlZFxuICAgICAgICBpZigkaHR0cC5wZW5kaW5nUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgJHRpbWVvdXQod2FpdEZvclJlbmRlckFuZERvU29tZXRoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2FpdHMgZm9yIGZpcnN0IGRpZ2VzdCBjeWNsZVxuICAgICR0aW1lb3V0KHdhaXRGb3JSZW5kZXJBbmREb1NvbWV0aGluZyk7XG5cbn1dKVxuXG4uZGlyZWN0aXZlKCdjaGFydCcsIGZ1bmN0aW9uICgkbG9nLCAkdGltZW91dCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2PjwvZGl2PicsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICBjb25maWc6ICc9J1xuICAgICAgICB9LFxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQ7XG4gICAgICAgICAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHNhbml0eSBjaGVja1xuICAgICAgICAgICAgICAgIGlmKCFzY29wZS5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxvZy5sb2coJ0Vycm9yOiBObyBjb25maWcgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb25maWcgICAgICAgICAgICAgICA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBzY29wZS5jb25maWcpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jaGFydC5yZW5kZXJUbyAgICA9IGVsZW1lbnRbMF07XG4gICAgICAgICAgICAgICAgY29uZmlnLmNoYXJ0LmV2ZW50cyAgICAgID0ge307XG4gICAgICAgICAgICAgICAgY29uZmlnLmNoYXJ0LmV2ZW50cy5sb2FkID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJ0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHNlcmllc19uZHggaW4gY2hhcnQuc2VyaWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZXNfbmR4XS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydChjb25maWcpO1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5yZWZsb3coKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvY2VzcygpO1xuXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goXCJjb25maWcuc2VyaWVzXCIsIGZ1bmN0aW9uIChsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goXCJjb25maWcubG9hZGluZ1wiLCBmdW5jdGlvbiAobG9hZGluZykge1xuICAgICAgICAgICAgICAgIGlmICghY2hhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5zaG93TG9hZGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmhpZGVMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSlcblxuLmZhY3RvcnkoJ3Jlc3RTZXJ2aWNlJywgWyckcmVzb3VyY2UnLCAnJHEnLCAnJGh0dHAnLCBmdW5jdGlvbigkcmVzb3VyY2UsICRxLCAkaHR0cCl7XG5cbiAgICAndXNlIHN0cmljdCc7XG4gICAgJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5wb3N0W1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgZ2V0U2VydmVyRGF0YTogZnVuY3Rpb24odXJsKSB7XG5cbiAgICAgICAgICAgIC8vIExlIHByb21pc2VcbiAgICAgICAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgICRodHRwLmdldCh1cmwpXG4gICAgICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gcHJvbWlzZVxuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlU2VydmVyRGF0YTogZnVuY3Rpb24odXJsKSB7XG5cbiAgICAgICAgICAgIHZhciBkZWZlciA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgICRodHRwLmRlbGV0ZSh1cmwpXG4gICAgICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0U2VydmVyRGF0YTogZnVuY3Rpb24odXJsLCBwb3N0X2RhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGRlZmVyID0gJHEuZGVmZXIoKTtcblxuICAgICAgICAgICAgJGh0dHAucG9zdCh1cmwsIHBvc3RfZGF0YSlcbiAgICAgICAgICAgIC5zdWNjZXNzKGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIGhlYWRlcnMsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfTtcbn1dKTtcblxuXG4iXX0=","(function (global){\n'use strict';\n\n//var $ = require('jquery');\nvar $ = global.$;\n\nvar Question = function() {\n\n    var self = this,\n        survey_id,\n        group,\n        question,\n        $help,\n        $el;\n\n    return self;\n};\n\nQuestion.prototype = {\n\n    /**\n     * [init - initialize object]\n     * @param  {[type]} survey_id    [description]\n     * @param  {[type]} question_obj [description]\n     * @param  {[type]} ndx          [description]\n     * @return {[type]}              [description]\n     */\n    init: function(survey_id, question_obj, ndx) {\n\n        var self = this;\n\n        self.survey_id    = survey_id;\n        self.group        = question_obj.g;\n        self.question     = question_obj.q;\n        self.question_num = question_obj.q_num;\n\n        self.generateDOMel(ndx);\n    },\n\n    /**\n     * [questionID get the limesurvey question ID]\n     * @return {[type]} [description]\n     */\n    questionID: function() {\n\n        var self = this;\n\n        return self.survey_id+'X'+self.group.id.gid+'X'+self.question.id.qid;\n    },\n\n    /**\n     * [generateDOMel - generate question li to insert in DOM]\n     * @param  {[type]} ndx [description]\n     * @return {[type]}     [description]\n     */\n    generateDOMel: function(ndx) {\n\n        var self = this;\n\n        self.question_id = self.questionID();\n        switch(ndx)\n        {\n            case 0:\n                self.$help = $(\"<li class='current inactive' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.help+\"</li>\");\n                self.$el = $(\"<li class='current' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.question.toLowerCase()+\"</li>\");\n                break;\n\n            case 1:\n                self.$help = $(\"<li class='inactive' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.help+\"</li>\");\n                self.$el = $(\"<li class='next' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.question.toLowerCase()+\"</li>\");\n                break;\n\n            default:\n                self.$help = $(\"<li class='inactive' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.help+\"</li>\");\n                self.$el = $(\"<li class='inactive' data-qnum='\"+self.question_num+\"' data-qid='\"+self.question_id+\"' data-gid='\"+self.group.id.gid+\"'>\"+self.question.question.toLowerCase()+\"</li>\");\n                break;\n        }\n    }\n};\n\nmodule.exports = Question;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qcy9zdXJ2ZXkvX3F1ZXN0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vdmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciAkID0gZ2xvYmFsLiQ7XG5cbnZhciBRdWVzdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdXJ2ZXlfaWQsXG4gICAgICAgIGdyb3VwLFxuICAgICAgICBxdWVzdGlvbixcbiAgICAgICAgJGhlbHAsXG4gICAgICAgICRlbDtcblxuICAgIHJldHVybiBzZWxmO1xufTtcblxuUXVlc3Rpb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogW2luaXQgLSBpbml0aWFsaXplIG9iamVjdF1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN1cnZleV9pZCAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBxdWVzdGlvbl9vYmogW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmR4ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc3VydmV5X2lkLCBxdWVzdGlvbl9vYmosIG5keCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLnN1cnZleV9pZCAgICA9IHN1cnZleV9pZDtcbiAgICAgICAgc2VsZi5ncm91cCAgICAgICAgPSBxdWVzdGlvbl9vYmouZztcbiAgICAgICAgc2VsZi5xdWVzdGlvbiAgICAgPSBxdWVzdGlvbl9vYmoucTtcbiAgICAgICAgc2VsZi5xdWVzdGlvbl9udW0gPSBxdWVzdGlvbl9vYmoucV9udW07XG5cbiAgICAgICAgc2VsZi5nZW5lcmF0ZURPTWVsKG5keCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFtxdWVzdGlvbklEIGdldCB0aGUgbGltZXN1cnZleSBxdWVzdGlvbiBJRF1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBxdWVzdGlvbklEOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuc3VydmV5X2lkKydYJytzZWxmLmdyb3VwLmlkLmdpZCsnWCcrc2VsZi5xdWVzdGlvbi5pZC5xaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFtnZW5lcmF0ZURPTWVsIC0gZ2VuZXJhdGUgcXVlc3Rpb24gbGkgdG8gaW5zZXJ0IGluIERPTV1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5keCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGdlbmVyYXRlRE9NZWw6IGZ1bmN0aW9uKG5keCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLnF1ZXN0aW9uX2lkID0gc2VsZi5xdWVzdGlvbklEKCk7XG4gICAgICAgIHN3aXRjaChuZHgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzZWxmLiRoZWxwID0gJChcIjxsaSBjbGFzcz0nY3VycmVudCBpbmFjdGl2ZScgZGF0YS1xbnVtPSdcIitzZWxmLnF1ZXN0aW9uX251bStcIicgZGF0YS1xaWQ9J1wiK3NlbGYucXVlc3Rpb25faWQrXCInIGRhdGEtZ2lkPSdcIitzZWxmLmdyb3VwLmlkLmdpZCtcIic+XCIrc2VsZi5xdWVzdGlvbi5oZWxwK1wiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwgPSAkKFwiPGxpIGNsYXNzPSdjdXJyZW50JyBkYXRhLXFudW09J1wiK3NlbGYucXVlc3Rpb25fbnVtK1wiJyBkYXRhLXFpZD0nXCIrc2VsZi5xdWVzdGlvbl9pZCtcIicgZGF0YS1naWQ9J1wiK3NlbGYuZ3JvdXAuaWQuZ2lkK1wiJz5cIitzZWxmLnF1ZXN0aW9uLnF1ZXN0aW9uLnRvTG93ZXJDYXNlKCkrXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNlbGYuJGhlbHAgPSAkKFwiPGxpIGNsYXNzPSdpbmFjdGl2ZScgZGF0YS1xbnVtPSdcIitzZWxmLnF1ZXN0aW9uX251bStcIicgZGF0YS1xaWQ9J1wiK3NlbGYucXVlc3Rpb25faWQrXCInIGRhdGEtZ2lkPSdcIitzZWxmLmdyb3VwLmlkLmdpZCtcIic+XCIrc2VsZi5xdWVzdGlvbi5oZWxwK1wiPC9saT5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi4kZWwgPSAkKFwiPGxpIGNsYXNzPSduZXh0JyBkYXRhLXFudW09J1wiK3NlbGYucXVlc3Rpb25fbnVtK1wiJyBkYXRhLXFpZD0nXCIrc2VsZi5xdWVzdGlvbl9pZCtcIicgZGF0YS1naWQ9J1wiK3NlbGYuZ3JvdXAuaWQuZ2lkK1wiJz5cIitzZWxmLnF1ZXN0aW9uLnF1ZXN0aW9uLnRvTG93ZXJDYXNlKCkrXCI8L2xpPlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzZWxmLiRoZWxwID0gJChcIjxsaSBjbGFzcz0naW5hY3RpdmUnIGRhdGEtcW51bT0nXCIrc2VsZi5xdWVzdGlvbl9udW0rXCInIGRhdGEtcWlkPSdcIitzZWxmLnF1ZXN0aW9uX2lkK1wiJyBkYXRhLWdpZD0nXCIrc2VsZi5ncm91cC5pZC5naWQrXCInPlwiK3NlbGYucXVlc3Rpb24uaGVscCtcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuJGVsID0gJChcIjxsaSBjbGFzcz0naW5hY3RpdmUnIGRhdGEtcW51bT0nXCIrc2VsZi5xdWVzdGlvbl9udW0rXCInIGRhdGEtcWlkPSdcIitzZWxmLnF1ZXN0aW9uX2lkK1wiJyBkYXRhLWdpZD0nXCIrc2VsZi5ncm91cC5pZC5naWQrXCInPlwiK3NlbGYucXVlc3Rpb24ucXVlc3Rpb24udG9Mb3dlckNhc2UoKStcIjwvbGk+XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVzdGlvbjsiXX0=","(function (global){\n'use strict';\n\n//var $ = require('jquery');\nvar $ = global.$;\nvar _ = require('underscore');\nvar History = window.History;\n\nvar TweenLite = global.TweenLite;\n\nvar Survey = function()\n{\n    this.answers = {};\n    this.questionObjects = [];\n    this.parent_el = undefined;\n};\n\nSurvey.prototype = {\n\n    /**\n     * [exchangeData - generic fnc for async data fetching]\n     * @param  {[type]} postData [description]\n     * @param  {[type]} storage  [description]\n     * @return {[type]}          [description]\n     */\n    exchangeData: function(postData, storage)\n    {\n        var self = this;\n\n        return $.ajax({\n\n            url: '/cms/wp-admin/admin-ajax.php',\n            type: 'POST',\n            dataType: 'json',\n            data: postData\n\n        }).done(function(data) {\n            self[storage] = data;\n        });\n    },\n\n    /**\n     * [fetchData fetches questions and groups for all steps of the questionaire relation]\n     * @param  {Function} callback [description]\n     * @return {[type]}            [description]\n     */\n    fetchData: function(callback) {\n\n        var self = this;\n\n        var async_deferreds = [];\n        if(self.do180)\n        {\n            var agency_groups_data = {action: 'getGroups', userRole: self.user_role, limesurvey_id: self.agency_surveyid, step: '180'};\n            async_deferreds.push(self.exchangeData(agency_groups_data, 'agency_groups'));\n            var agency_questions_data = {action: 'getQuestions', userRole: self.user_role, limesurvey_id: self.agency_surveyid, step: '180'};\n            async_deferreds.push(self.exchangeData(agency_questions_data, 'agency_questions'));\n        }\n\n        if(self.do360)\n        {\n            var company_groups_data = {action: 'getGroups', userRole: self.user_role, limesurvey_id: self.company_surveyid, step: '360'};\n            async_deferreds.push(self.exchangeData(company_groups_data, 'company_groups'));\n            var company_questions_data = {action: 'getQuestions', userRole: self.user_role, limesurvey_id: self.company_surveyid, step: '360'};\n            async_deferreds.push(self.exchangeData(company_questions_data, 'company_questions'));\n        }\n\n        // when all async data fetching is done\n        $.when.apply($, async_deferreds).then(function(schemas)\n        {\n            if (!schemas) {\n                throw ('ERROR: no survey data retrieved by the fetchData call');\n            }\n\n            if(self.do180)\n            {\n                self.curr_step = '180';\n                self.groups = self.agency_groups;\n                self.questions = self.agency_questions;\n            }\n            else\n            {\n                self.curr_step = '360';\n                self.groups = self.company_groups;\n                self.questions = self.company_questions;\n            }\n\n            console.log('groups', self.groups);\n            console.log('questions', self.questions);\n\n            self.initGroups();\n            self.initQuestions();\n\n            if (callback && typeof callback == 'function') {\n                callback();\n            }\n\n        }, function(e) {\n            console.log(\"My ajax failed\");\n        });\n\n        return self;\n    },\n\n    /**\n     * [initGroups - initializes groups related DOM elements]\n     * used on init and reset360\n     * @return {[type]} [description]\n     */\n    initGroups: function() {\n\n        var self = this;\n\n        self.group_gids = [];\n        self.group_last_question = {};\n        self.num_groups = self.groups.length;\n        var width_perc  = 100.0/self.num_groups;\n\n        $('.groups-nav > ul').empty();\n        $('.nav-background').remove();\n        $('.introgroups-ul').empty();\n\n        $.each(self.groups, function(index, el) {\n\n            self.group_gids.push(el.group.id.gid);\n            self.group_last_question[el.group.id.gid] = -1;\n\n            var li_class  = 'text-center';\n            var img_class = 'nav-background';\n\n            if(index === 0)\n            {\n                self.curr_group = el.group.id.gid;\n                li_class  = 'text-center active';\n                img_class = 'nav-background active';\n            }\n\n            // append intro groups li\n            var intro_li_class = '';\n            var $intro_li = $(\"<li class='text-center'>\"+el.group.group_name+\"</li>\").addClass('question-group-' + (index + 1) );\n            $('.introgroups-ul').append($intro_li);\n\n            // append nav li\n            var li_content = (index === 0 ? '1/'+el.num_questions : el.num_questions);\n            var $li = \"<li class='\"+li_class+\"' style='width:\"+width_perc+\"%'><a href='#' data-gid='\"+el.group.id.gid+\"' data-num-questions='\"+el.num_questions+\"' target='_blank'>\"+li_content+\"</a></li>\";\n            $('.groups-nav ul').append($li);\n\n            // append nav background\n            var nav_background_img_path = \"/content/themes/procync/app/assets/images/nav/nav\"+self.groups.length+\"-\"+index+\".png\";\n            var $img = $('<img src=\"'+nav_background_img_path+'\" alt=\"previous\" data-ndx=\"'+index+'\" class=\"'+img_class+'\">');\n            $('.procyncRoot .category-navigation-container').prepend($img);\n\n        });\n\n        $('.group-header').html(self.groups[0].group.group_name).attr('data-group-id', self.groups[0].group.id.gid);;\n    },\n\n\n    /**\n     * [initGroups - initializes questions related DOM elements]\n     * used on init and reset360\n     */\n    initQuestions: function() {\n\n        var self = this;\n        self.$questionContainer = $('.question-container'),\n        self.$helpContainer     = $('.help-container');\n\n        self.$questionContainer.empty();\n        self.$helpContainer.empty();\n\n        self.num_questions     = self.questions.length;\n        self.curr_question_ndx = 0;\n        self.prev_question_ndx = self.num_questions -1;\n        self.next_question_ndx = 1;\n\n        $.each(self.questions, function(index, el)\n        {\n            var question = new global.App.question;\n            question.init(self.survey_id, el, index);\n            self.$questionContainer.append(question.$el);\n            self.$helpContainer.append(question.$help);\n            self.questionObjects.push(question);\n        });\n\n        // setup input for 1st question\n        var curr_question_id = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\").attr('data-qid');\n        $('input.slider:first').attr('data-qid', curr_question_id);\n        $('.go-next-question').addClass('inactive');\n    },\n\n\n    /**\n     * [init - called on document ready]\n     * @return {[type]} [description]\n     */\n    init: function() {\n\n        var self = this;\n\n        self.isAnimating        = false;\n        self.$questionContainer = $('.question-container');\n\n        self.do180              = parseInt($('.procyncRoot').attr('data-do180'), 10);\n        self.do360              = parseInt($('.procyncRoot').attr('data-do360'), 10);\n        self.curr_step          = (!self.do180 ? '360' : '180');\n\n        self.user_role          = $('.procyncRoot').attr('data-userrole');\n        self.user_type          = $('.procyncRoot').attr('data-usertype');\n        self.user_relationship  = $('.procyncRoot').attr('data-userrelationship');\n        self.relationship_type  = $('.procyncRoot').attr('data-relationshiptype');\n\n        self.agency_name        = $('.procyncRoot').attr('data-agencyname');\n        self.company_name       = $('.procyncRoot').attr('data-companyname');\n        self.agency_surveyid    = $('.procyncRoot').attr('data-survey_id_180');\n        self.company_surveyid   = $('.procyncRoot').attr('data-survey_id_360');\n\n        if(self.do180)\n        {\n            self.survey_id = self.agency_surveyid;\n            $('.content-180').show();\n            $('.content-360').hide();\n        }\n        else\n        {\n            self.survey_id = self.company_surveyid;\n            $('.content-360').show();\n            $('.content-180').hide();\n        }\n\n        $('.group-header, .procyncRoot').removeClass('group-cat1 group-cat2 group-cat3 group-cat4 group-cat5').addClass('group-cat1');\n\n        if(!(self.do180 && self.do360)) {\n            $('.reset360orExit').remove();\n        }\n\n        if(self.do180 && self.do360) {\n            $('.closeWindow').hide();\n        }\n\n        $('.procyncIntro').show();\n        $('.procyncIntro').css('display', 'block');\n\n        self.answers = {};\n        var $slider = $('.survey-range-slider');\n        self.fetchData(function() {\n            $slider.attr('data-qid', self.questionObjects[0].question_id);\n        });\n        self.bindEvents();\n        self.setTitle();\n\n\n        var rangeslider_options = {\n\n            polyfill: false,\n            rangeClass: 'rangeslider',\n            fillClass: 'rangeslider__fill',\n            handleClass: 'rangeslider__handle',\n\n            onInit: function() {},\n            onSlide: function(position, value) {\n\n                this.$element.siblings('.input-val').html(value.toFixed(1));\n                if($('.go-next-question').hasClass('inactive')) {\n                    $('.go-next-question').removeClass('inactive');\n                }\n            }\n        }\n\n        if(global.platform.name === \"IE\" && parseInt(global.platform.version, 10) < 10) {\n            rangeslider_options.polyfill = true;\n        }\n\n        $('input.slider').rangeslider(rangeslider_options);\n\n        console.log('platform', platform.name);\n        if (platform.name === 'Safari' && platform.os.family === 'iOS' && parseInt(platform.os.version, 10) > 7 || platform.ua.indexOf('like Mac OS X') != -1) {\n            $('.lower-inputs').css('bottom', '8rem');\n        }\n\n    },\n\n    /**\n     * [reset360orExit - similar to above - called on transition from 180 to 360]\n     * @return {[type]} [description]\n     */\n    reset360orExit: function() {\n\n        var self = this;\n\n        $('input.slider').bind(\"change paste keyup\", function() {\n            $('.input-val').html($('input.slider').val());\n        });\n\n        $('.group-header, .procyncRoot').removeClass('group-cat1 group-cat2 group-cat3 group-cat4 group-cat5').addClass('group-cat1');\n\n        // reset all the things\n        if(self.relationship_type === '360') {\n\n            if(self.curr_step === '180') {\n\n                self.curr_step = '360';\n\n                // $('.main-content').show();\n                $('.posted-answers').empty();\n                $('.answers').hide();\n                $('.reset360orExit').remove();\n                $('.closeWindow').show();\n\n                $('.content-360').show();\n                $('.content-180').hide();\n\n                $('.login-content2').hide();\n                $('.login-content').show();\n\n                $('.login-action2').hide();\n                $('.login-action').show();\n                $('.lower-inputs').show();\n\n                $('.category-navigation-container').show();\n                $('.groups-nav').show();\n\n                $('.procyncIntro').show();\n\n                // FFF\n                self.survey_id        = self.company_surveyid;\n\n                self.answers   = {};\n                self.groups    = self.company_groups;\n                self.questions = self.company_questions;\n\n                self.initGroups();\n                self.initQuestions();\n                self.setTitle();\n\n                self.setContentTopMargin();\n            }\n\n        } else if(self.relationship_type === '180') {\n\n            console.log('Error: this is a 180');\n        }\n    },\n\n    /**\n     * [updateNav - uses for updating navbar when current question group changes]\n     * @param  {[type]} $curr_el [description]\n     * @return {[type]}          [description]\n     */\n    updateNav: function($curr_el) {\n\n        var self = this;\n\n        // get current question group attributes\n        var curr_question_group = $curr_el.attr('data-gid');\n        var li_ndx              = _.indexOf(self.group_gids, curr_question_group);\n\n        var $curr_group_questions = $('.question-container li[data-gid=\"'+curr_question_group+'\"]');\n        var q_num               = 0;\n\n        if(!$curr_group_questions.hasClass('current')) {\n            console.log('weirdness - no current in .current group ??? ', $(this));\n            return false;\n        }\n\n        $curr_group_questions.each(function() {\n\n            if($(this).hasClass('current')) { return false;}\n            q_num++;\n        });\n\n        self.group_last_question[curr_question_group] = self.curr_question_ndx;\n        console.log('last questions', self.group_last_question);\n\n        var increment = li_ndx+1;\n        var new_class_name = (self.curr_step === '180' ? 'group-cat'+increment : 'group360-cat'+increment);\n\n        var all_group_cat_classes = 'group-cat1 group-cat2 group-cat3 group-cat4 group-cat5 group360-cat1 group360-cat2 group360-cat3';\n        $('.group-header, .procyncRoot').removeClass(all_group_cat_classes).addClass(new_class_name);\n        if(curr_question_group !== self.curr_group)\n        {\n            // update group-header\n            $('.group-header').html(self.groups[li_ndx].group.group_name).attr('data-group-id', self.groups[li_ndx].group.id.gid);\n\n            // get prev group li ndx\n            var prev_li_ndx = _.indexOf(self.group_gids, self.curr_group);\n\n            // reset prev group\n            $('.groups-nav ul li:eq('+prev_li_ndx+')').removeClass('active');\n            $('.groups-nav ul li:eq('+li_ndx+')').addClass('active');\n            $('.groups-nav ul li:eq('+prev_li_ndx+') a').html(self.groups[prev_li_ndx].num_questions);\n            self.curr_group = curr_question_group;\n\n            // update previous background class\n            $('.nav-background[data-ndx='+prev_li_ndx+']').removeClass('active');\n            $('.nav-background[data-ndx='+li_ndx+']').addClass('active');\n        }\n\n        var group_text = (q_num+1)+'/'+self.groups[li_ndx].num_questions;\n        $('.groups-nav ul li:eq('+li_ndx+') a').html(group_text);\n    },\n\n    /**\n     * [goToQuestion - go to a specific question without doing any animations]\n     * called when :\n     *     1) selecting a different group in the navbar\n     *     2) found somethng incomplete upon saving answers\n     *\n     * @param  {[type]} question_ndx [description]\n     * @param  {[type]} $nav_el      [description]\n     * @return {[type]}              [description]\n     */\n    goToQuestion: function(question_ndx, $nav_el) {\n\n        var self = this;\n        console.log('ndx', question_ndx);\n\n        if(question_ndx !== -1) {\n\n            // reset markers\n            self.curr_question_ndx = question_ndx;\n            self.prev_question_ndx = (self.curr_question_ndx > 0 ? self.curr_question_ndx - 1 : self.num_questions - 1);\n            self.next_question_ndx = (self.curr_question_ndx < self.num_questions - 1 ? self.curr_question_ndx + 1 : 0);\n\n            // reset li next previous\n            self.$questionContainer.find(\"li\").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');\n            self.$helpContainer.find(\"li\").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');\n\n            // reset current\n            var $new_prev_el;\n            if(self.prev_question_ndx !== self.num_questions - 1) {\n                $new_prev_el = self.$questionContainer.find(\"li:eq(\"+self.prev_question_ndx+\")\");\n                $new_prev_el.removeClass(\"inactive\").addClass('previous');\n            }\n\n            var $new_curr_el = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n            var $new_curr_help_el = self.$helpContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n            $new_curr_el.removeClass(\"inactive\").addClass('current');\n            $new_curr_help_el.addClass('current');\n            $new_curr_el.css('opacity', 1);\n\n            var $new_next_el;\n            if(self.next_question_ndx !== 0) {\n                $new_next_el = self.$questionContainer.find(\"li:eq(\"+self.next_question_ndx+\")\");\n                $new_next_el.removeClass(\"inactive\").addClass('next');\n            }\n\n            var curr_question_id = $new_curr_el.attr('data-qid');\n            $('input.slider').attr('data-qid', curr_question_id);\n\n            // set input value\n            if(self.answers.hasOwnProperty(curr_question_id))\n            {\n                $('input.slider').val(self.answers[curr_question_id]);\n                $('.input-val').html($('input.slider').val());\n            }\n\n            self.updateNav($new_curr_el);\n        }\n\n        $('.groups-nav li').removeClass('active');\n        $nav_el.closest('li').addClass('active');\n    },\n\n    /**\n     * [nextAnim - move forward]\n     * used by nextQuestion\n     * @return {[type]} [description]\n     */\n    nextAnim: function() {\n\n        var self = this;\n\n        var $helpContainer     = $('.help-container');\n\n        // remove old prev\n        if(self.next_question_ndx !== 0)\n        {\n            var $old_prev_el = self.$questionContainer.find(\"li:eq(\"+self.prev_question_ndx+\")\");\n            TweenLite.to($old_prev_el, 0, {autoAlpha:0, className:\"inactive\"});\n        }\n\n        // update li's ndx's\n        self.curr_question_ndx = (self.curr_question_ndx + 1 > self.num_questions - 1 ? 0 : self.curr_question_ndx + 1);\n        self.prev_question_ndx = (self.prev_question_ndx + 1 > self.num_questions - 1 ? 0 : self.prev_question_ndx + 1);\n        self.next_question_ndx = (self.next_question_ndx + 1 > self.num_questions - 1 ? 0 : self.next_question_ndx + 1);\n\n        // add new prev\n        var $new_prev_el = self.$questionContainer.find(\"li:eq(\"+self.prev_question_ndx+\")\");\n        TweenLite.to($new_prev_el, 0.5, {autoAlpha:1, className:\"previous\"});\n\n        // curr help\n        self.$helpContainer.find(\"li\").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');\n        var $new_curr_help_el = self.$helpContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n        $new_curr_help_el.addClass('current');\n\n        // add new current\n        var $new_curr_el = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n        TweenLite.to($new_curr_el, 0.5, {autoAlpha:1, className:\"current\"});\n\n        // add new next\n        if(self.next_question_ndx !== 0) {\n            var $new_next_el = self.$questionContainer.find(\"li:eq(\"+self.next_question_ndx+\")\");\n            TweenLite.to($new_next_el, 0, {autoAlpha:0, className:\"next\"});\n        }\n        //TweenLite.to($('#question-container'), 0.2, {top: 0 - $new_prev_el.position().top});\n\n        setTimeout(function() {\n            self.updateNav($new_curr_el);\n        }, 700);\n\n    },\n\n    /**\n     * [prevAnim - move back]\n     * used by prevQuestion\n     * @return {[type]} [description]\n     */\n    prevAnim: function() {\n\n        var self = this;\n\n        var $helpContainer     = $('.help-container');\n\n        // remove old next\n        var $old_next_el = self.$questionContainer.find(\"li:eq(\"+self.next_question_ndx+\")\");\n        TweenLite.to($old_next_el, 0, {autoAlpha:0, className:\"inactive\"});\n\n        // update li ndx's\n        self.curr_question_ndx = (self.curr_question_ndx - 1 < 0 ? self.num_questions - 1 : self.curr_question_ndx - 1);\n        self.prev_question_ndx = (self.prev_question_ndx - 1 < 0 ? self.num_questions - 1 : self.prev_question_ndx - 1);\n        self.next_question_ndx = (self.next_question_ndx - 1 < 0 ? self.num_questions - 1 : self.next_question_ndx - 1);\n\n        console.log('prev anim ndxs', self.curr_question_ndx, self.prev_question_ndx, self.next_question_ndx);\n\n        // add new next\n        var $new_next_el = self.$questionContainer.find(\"li:eq(\"+self.next_question_ndx+\")\");\n        TweenLite.to($new_next_el, 0.5, {autoAlpha:1, className:\"next\"});\n\n        // curr help\n        $helpContainer.find(\"li\").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');\n        var $new_curr_help_el = self.$helpContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n        $new_curr_help_el.addClass('current');\n\n        // add new curr\n        var $new_curr_el = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\");\n        TweenLite.to($new_curr_el, 0.5, {autoAlpha:1, className:\"current\"});\n\n        // add new prev\n        if(self.prev_question_ndx !== self.num_questions - 1) {\n            var $new_prev_el = self.$questionContainer.find(\"li:eq(\"+self.prev_question_ndx+\")\");\n            TweenLite.to($new_prev_el, 0, {autoAlpha:0, className:\"previous\"});\n        }\n\n        var $discount_el = ($new_prev_el ? $new_prev_el : $new_curr_el);\n        //TweenLite.to($('#question-container'), 0.2, {top: 0 - $discount_el.position().top});\n\n        setTimeout(function() {\n            self.updateNav($new_curr_el);\n        }, 700);\n    },\n\n    /**\n     * [nextQuestion - go forward by 1 question]\n     * @return {[type]} [description]\n     */\n    nextQuestion: function() {\n\n        var self = this,\n        $slider = $('.survey-range-slider'),\n        $sliderValueContainer = $slider.prev('.input-val');\n        self.isAnimating = true;\n\n        // get input value\n        var answer_val = $slider.val();\n        var answer_id = $slider.attr('data-qid');\n        self.answers[answer_id] = answer_val;\n\n        // last question\n        if(self.curr_question_ndx === self.num_questions-1) {\n\n            var $el = self.verifyAnswers();\n            if($el === false)\n            {\n                $('.main-content').hide();\n                $('.lower-inputs').hide();\n                self.saveAnswers();\n\n            } else {\n\n                console.log('going to missed question');\n\n                var question_ndx = $el.index();\n                var group_id = $el.attr('data-gid');\n                var $nav_el = $(\".groups-nav a[data-gid=\"+group_id+\"]\");\n                self.goToQuestion(question_ndx, $nav_el);\n            }\n\n        // just another question\n        } else {\n\n            self.nextAnim();\n\n            // set input qid\n            var curr_question_id = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\").attr('data-qid');\n            $slider.attr('data-qid', curr_question_id);\n\n            // set input value\n            if(self.answers.hasOwnProperty(curr_question_id)) {\n                $slider.val(self.answers[curr_question_id]);\n            } else {\n                $slider.val(5);\n            }\n\n            $sliderValueContainer.html($slider.val());\n            //history.pushState({q_ndx: self.curr_question_ndx}, null, null);\n            History.pushState({q_ndx: self.curr_question_ndx}, null, null);\n        }\n\n        $('input[type=\"range\"]').rangeslider('update', true);\n        $('.go-next-question').addClass('inactive');\n\n        self.isAnimating = false;\n    },\n\n    /**\n     * [prevQuestion - go back by 1 question]\n     * @return {[type]} [description]\n     */\n    prevQuestion: function() {\n\n        var self = this,\n            $slider = $('.survey-range-slider'),\n            $sliderValueContainer = $slider.prev('.input-val');\n\n        self.isAnimating = true;\n        if(self.curr_question_ndx !== 0) {\n\n            self.prevAnim();\n            var curr_question_id = self.$questionContainer.find(\"li:eq(\"+self.curr_question_ndx+\")\").attr('data-qid');\n            $slider.attr('data-qid', curr_question_id);\n\n            // set input value\n            if(self.answers.hasOwnProperty(curr_question_id))\n            {\n                $slider.val(self.answers[curr_question_id]);\n                $sliderValueContainer.html($slider.val());\n            }\n\n            $(window).trigger(\"popstate\");\n        }\n\n        $('input[type=\"range\"]').rangeslider('update', true);\n        self.isAnimating = false;\n    },\n\n    verifyAnswers: function() {\n\n        var self = this;\n\n        console.log('all qo', self.questionObjects, self.answers);\n        for(var qo in self.questionObjects)\n        {\n            console.log('>>> qo ', self.answers[self.questionObjects[qo].question_id], self.questionObjects[qo].question_id);\n            if(self.answers[self.questionObjects[qo].question_id] === undefined)\n            {\n                var $el = self.$questionContainer.find(\"li[data-qid=\"+self.questionObjects[qo].question_id+\"]\");\n                if($el.length > 0) {\n                    return $el;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * [saveAnswers description]\n     * @return {[type]} [description]\n     */\n    saveAnswers: function() {\n\n        var self = this;\n\n        var post_data = {};\n        $.extend(true, post_data, self.answers, {action: 'postAnswers', limesurvey_id: self.survey_id, evaluation_id: self.user_relationship, step: self.curr_step});\n        $('.posted-answers').empty();\n\n        var response_status;\n        $.when(self.exchangeData(post_data, response_status)).done(function(data) {\n\n            console.log('answers response', data);\n            if(data.status === 'OK')\n            {\n                $('.category-navigation-container').hide();\n                $('.groups-nav').hide();\n                $('.answers').show();\n\n                console.log('Responses saved');\n            }\n            else\n            {\n                console.log('ERROR', data.message);\n            }\n        });\n    },\n\n    /**\n     * [setContentTopMargin description]\n     */\n    setContentTopMargin: function() {\n\n        var self = this;\n        $(document).on('click', 'button.login-action2', function() {\n\n            var self = this;\n            var groups_height = $('.nav-background:first').height();\n\n            $('.groups-nav').height(groups_height);\n            $('.groups-ul').height(groups_height);\n\n        })\n    },\n\n\n    /**\n     * [setTitle description]\n     */\n    setTitle: function()\n    {\n        var self = this;\n        var title_str = '';\n\n        if(self.curr_step === '180')\n        {\n            title_str = self.agency_name;\n        }\n        else if(self.curr_step === '360')\n        {\n            title_str = self.company_name;\n        }\n        else\n        {\n            title_str = 'Error';\n        }\n\n        $('.rel-title').html(title_str);\n    },\n\n\n    /**\n     * [bindEvents - bind all required events]\n     * @return {[type]} [description]\n     */\n    bindEvents: function() {\n\n        var self = this;\n\n        // orientation lock\n        $(window).bind('orientationchange', function(e) {\n\n            switch ( window.orientation ) {\n                case 0:\n                    $('.turnDeviceNotification').css('display', 'none');\n                    // The device is in portrait mode now\n                    break;\n\n                case 180:\n                    $('.turnDeviceNotification').css('display', 'none');\n                    // The device is in portrait mode now\n                    break;\n\n                case 90:\n                    // The device is in landscape now\n                    $('.turnDeviceNotification').css('display', 'block');\n                    break;\n\n                case -90:\n                    // The device is in landscape now\n                    $('.turnDeviceNotification').css('display', 'block');\n                    break;\n            }\n\n        });\n\n        // intro setup\n        if($('.procyncIntro').length) {\n\n            $('body').on('click', '.login-action', function(ev)\n            {\n                ev.preventDefault();\n                $('.login-content').hide();\n                $('.login-content2').show();\n                $('.login-action').hide();\n                $('.login-action2').show();\n            });\n\n            $('body').on('click', '.login-action2', function(ev)\n            {\n                ev.preventDefault();\n                $('.question-container').css('top', 0);\n                $('.procyncIntro').hide();\n                $('.main-content').show();\n                $('.procyncRoot').show();\n                self.setContentTopMargin();\n            });\n        }\n\n        // main questionaire setup\n        if($('.procyncRoot').length) {\n\n            // Bind to StateChange Event - this is meant to use statechange but thta fires all the time :(\n            History.Adapter.bind(window, 'statechange', function(evt){ // Note: We are using statechange instead of popstate\n                var State = History.getState(); // Note: We are using History.getState() instead of event.state\n                //History.log(State.data, State.title, State.url);\n\n                var question_ndx = State.data.q_ndx;\n                var group_id = self.$questionContainer.find(\"li:eq(\"+question_ndx+\")\").attr('data-gid');\n                var $nav_el = $(\".groups-nav a[data-gid=\"+group_id+\"]\");\n                //self.goToQuestion(State.q_ndx, $nav_el);\n\n                console.log('popstate', question_ndx, State);\n            });\n\n            // // back button browser history\n            // window.addEventListener(\"popstate\", function(e) {\n\n            //     e.preventDefault();\n\n            //     var question_ndx = e.state.q_ndx;\n            //     var group_id = self.$questionContainer.find(\"li:eq(\"+question_ndx+\")\").attr('data-gid');\n            //     var $nav_el = $(\".groups-nav a[data-gid=\"+group_id+\"]\");\n            //     self.goToQuestion(e.state.q_ndx, $nav_el);\n\n            //     return true;\n            // });\n\n            $(window).resize(function() {\n                self.setContentTopMargin();\n            });\n\n            $('body').on('click','.reset360orExit', function(ev) {\n                ev.preventDefault();\n                self.reset360orExit();\n            });\n\n            $('body').on('click','.go-prev-question', function() {\n                self.prevQuestion();\n            });\n\n            $('body').on('click','.go-next-question', function() {\n\n                if($('.go-next-question').hasClass('inactive')) {\n                    $('.go-next-question').removeClass('inactive');\n                } else {\n                    self.nextQuestion();\n                }\n            });\n\n            $('.help-toggle').click(function(evt) {\n                evt.preventDefault();\n                var $help_status = $('.help-container').find('.current');\n                if($help_status.hasClass('inactive')) {\n                    $help_status.removeClass('inactive');\n                } else {\n                    $help_status.addClass('inactive');\n                }\n\n            });\n\n            $('body').on('click', '.groups-nav a', function(ev) {\n\n                var $el = $(this);\n\n                ev.preventDefault();\n                var gid = $(this).attr('data-gid');\n\n                // find last answered question with within group\n                // var question_ndx = self.$questionContainer.find(\"li[data-gid=\"+gid+\"]:first\").index();\n                var question_ndx = self.group_last_question[gid];\n                if(-1 === question_ndx) {\n                    return false;\n                } else {\n                    self.goToQuestion(question_ndx, $el);\n                }\n\n            });\n        }\n    }\n};\n\nmodule.exports = new Survey();\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qcy9zdXJ2ZXkvX3N1cnZleS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy92YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyICQgPSBnbG9iYWwuJDtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIEhpc3RvcnkgPSB3aW5kb3cuSGlzdG9yeTtcblxudmFyIFR3ZWVuTGl0ZSA9IGdsb2JhbC5Ud2VlbkxpdGU7XG5cbnZhciBTdXJ2ZXkgPSBmdW5jdGlvbigpXG57XG4gICAgdGhpcy5hbnN3ZXJzID0ge307XG4gICAgdGhpcy5xdWVzdGlvbk9iamVjdHMgPSBbXTtcbiAgICB0aGlzLnBhcmVudF9lbCA9IHVuZGVmaW5lZDtcbn07XG5cblN1cnZleS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBbZXhjaGFuZ2VEYXRhIC0gZ2VuZXJpYyBmbmMgZm9yIGFzeW5jIGRhdGEgZmV0Y2hpbmddXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb3N0RGF0YSBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdG9yYWdlICBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZXhjaGFuZ2VEYXRhOiBmdW5jdGlvbihwb3N0RGF0YSwgc3RvcmFnZSlcbiAgICB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gJC5hamF4KHtcblxuICAgICAgICAgICAgdXJsOiAnL2Ntcy93cC1hZG1pbi9hZG1pbi1hamF4LnBocCcsXG4gICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgZGF0YTogcG9zdERhdGFcblxuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHNlbGZbc3RvcmFnZV0gPSBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2ZldGNoRGF0YSBmZXRjaGVzIHF1ZXN0aW9ucyBhbmQgZ3JvdXBzIGZvciBhbGwgc3RlcHMgb2YgdGhlIHF1ZXN0aW9uYWlyZSByZWxhdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZmV0Y2hEYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgYXN5bmNfZGVmZXJyZWRzID0gW107XG4gICAgICAgIGlmKHNlbGYuZG8xODApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhZ2VuY3lfZ3JvdXBzX2RhdGEgPSB7YWN0aW9uOiAnZ2V0R3JvdXBzJywgdXNlclJvbGU6IHNlbGYudXNlcl9yb2xlLCBsaW1lc3VydmV5X2lkOiBzZWxmLmFnZW5jeV9zdXJ2ZXlpZCwgc3RlcDogJzE4MCd9O1xuICAgICAgICAgICAgYXN5bmNfZGVmZXJyZWRzLnB1c2goc2VsZi5leGNoYW5nZURhdGEoYWdlbmN5X2dyb3Vwc19kYXRhLCAnYWdlbmN5X2dyb3VwcycpKTtcbiAgICAgICAgICAgIHZhciBhZ2VuY3lfcXVlc3Rpb25zX2RhdGEgPSB7YWN0aW9uOiAnZ2V0UXVlc3Rpb25zJywgdXNlclJvbGU6IHNlbGYudXNlcl9yb2xlLCBsaW1lc3VydmV5X2lkOiBzZWxmLmFnZW5jeV9zdXJ2ZXlpZCwgc3RlcDogJzE4MCd9O1xuICAgICAgICAgICAgYXN5bmNfZGVmZXJyZWRzLnB1c2goc2VsZi5leGNoYW5nZURhdGEoYWdlbmN5X3F1ZXN0aW9uc19kYXRhLCAnYWdlbmN5X3F1ZXN0aW9ucycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNlbGYuZG8zNjApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjb21wYW55X2dyb3Vwc19kYXRhID0ge2FjdGlvbjogJ2dldEdyb3VwcycsIHVzZXJSb2xlOiBzZWxmLnVzZXJfcm9sZSwgbGltZXN1cnZleV9pZDogc2VsZi5jb21wYW55X3N1cnZleWlkLCBzdGVwOiAnMzYwJ307XG4gICAgICAgICAgICBhc3luY19kZWZlcnJlZHMucHVzaChzZWxmLmV4Y2hhbmdlRGF0YShjb21wYW55X2dyb3Vwc19kYXRhLCAnY29tcGFueV9ncm91cHMnKSk7XG4gICAgICAgICAgICB2YXIgY29tcGFueV9xdWVzdGlvbnNfZGF0YSA9IHthY3Rpb246ICdnZXRRdWVzdGlvbnMnLCB1c2VyUm9sZTogc2VsZi51c2VyX3JvbGUsIGxpbWVzdXJ2ZXlfaWQ6IHNlbGYuY29tcGFueV9zdXJ2ZXlpZCwgc3RlcDogJzM2MCd9O1xuICAgICAgICAgICAgYXN5bmNfZGVmZXJyZWRzLnB1c2goc2VsZi5leGNoYW5nZURhdGEoY29tcGFueV9xdWVzdGlvbnNfZGF0YSwgJ2NvbXBhbnlfcXVlc3Rpb25zJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiBhbGwgYXN5bmMgZGF0YSBmZXRjaGluZyBpcyBkb25lXG4gICAgICAgICQud2hlbi5hcHBseSgkLCBhc3luY19kZWZlcnJlZHMpLnRoZW4oZnVuY3Rpb24oc2NoZW1hcylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKCdFUlJPUjogbm8gc3VydmV5IGRhdGEgcmV0cmlldmVkIGJ5IHRoZSBmZXRjaERhdGEgY2FsbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzZWxmLmRvMTgwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGYuY3Vycl9zdGVwID0gJzE4MCc7XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cHMgPSBzZWxmLmFnZW5jeV9ncm91cHM7XG4gICAgICAgICAgICAgICAgc2VsZi5xdWVzdGlvbnMgPSBzZWxmLmFnZW5jeV9xdWVzdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyX3N0ZXAgPSAnMzYwJztcbiAgICAgICAgICAgICAgICBzZWxmLmdyb3VwcyA9IHNlbGYuY29tcGFueV9ncm91cHM7XG4gICAgICAgICAgICAgICAgc2VsZi5xdWVzdGlvbnMgPSBzZWxmLmNvbXBhbnlfcXVlc3Rpb25zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ3JvdXBzJywgc2VsZi5ncm91cHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3F1ZXN0aW9ucycsIHNlbGYucXVlc3Rpb25zKTtcblxuICAgICAgICAgICAgc2VsZi5pbml0R3JvdXBzKCk7XG4gICAgICAgICAgICBzZWxmLmluaXRRdWVzdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk15IGFqYXggZmFpbGVkXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2luaXRHcm91cHMgLSBpbml0aWFsaXplcyBncm91cHMgcmVsYXRlZCBET00gZWxlbWVudHNdXG4gICAgICogdXNlZCBvbiBpbml0IGFuZCByZXNldDM2MFxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGluaXRHcm91cHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLmdyb3VwX2dpZHMgPSBbXTtcbiAgICAgICAgc2VsZi5ncm91cF9sYXN0X3F1ZXN0aW9uID0ge307XG4gICAgICAgIHNlbGYubnVtX2dyb3VwcyA9IHNlbGYuZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgdmFyIHdpZHRoX3BlcmMgID0gMTAwLjAvc2VsZi5udW1fZ3JvdXBzO1xuXG4gICAgICAgICQoJy5ncm91cHMtbmF2ID4gdWwnKS5lbXB0eSgpO1xuICAgICAgICAkKCcubmF2LWJhY2tncm91bmQnKS5yZW1vdmUoKTtcbiAgICAgICAgJCgnLmludHJvZ3JvdXBzLXVsJykuZW1wdHkoKTtcblxuICAgICAgICAkLmVhY2goc2VsZi5ncm91cHMsIGZ1bmN0aW9uKGluZGV4LCBlbCkge1xuXG4gICAgICAgICAgICBzZWxmLmdyb3VwX2dpZHMucHVzaChlbC5ncm91cC5pZC5naWQpO1xuICAgICAgICAgICAgc2VsZi5ncm91cF9sYXN0X3F1ZXN0aW9uW2VsLmdyb3VwLmlkLmdpZF0gPSAtMTtcblxuICAgICAgICAgICAgdmFyIGxpX2NsYXNzICA9ICd0ZXh0LWNlbnRlcic7XG4gICAgICAgICAgICB2YXIgaW1nX2NsYXNzID0gJ25hdi1iYWNrZ3JvdW5kJztcblxuICAgICAgICAgICAgaWYoaW5kZXggPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyX2dyb3VwID0gZWwuZ3JvdXAuaWQuZ2lkO1xuICAgICAgICAgICAgICAgIGxpX2NsYXNzICA9ICd0ZXh0LWNlbnRlciBhY3RpdmUnO1xuICAgICAgICAgICAgICAgIGltZ19jbGFzcyA9ICduYXYtYmFja2dyb3VuZCBhY3RpdmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBlbmQgaW50cm8gZ3JvdXBzIGxpXG4gICAgICAgICAgICB2YXIgaW50cm9fbGlfY2xhc3MgPSAnJztcbiAgICAgICAgICAgIHZhciAkaW50cm9fbGkgPSAkKFwiPGxpIGNsYXNzPSd0ZXh0LWNlbnRlcic+XCIrZWwuZ3JvdXAuZ3JvdXBfbmFtZStcIjwvbGk+XCIpLmFkZENsYXNzKCdxdWVzdGlvbi1ncm91cC0nICsgKGluZGV4ICsgMSkgKTtcbiAgICAgICAgICAgICQoJy5pbnRyb2dyb3Vwcy11bCcpLmFwcGVuZCgkaW50cm9fbGkpO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmF2IGxpXG4gICAgICAgICAgICB2YXIgbGlfY29udGVudCA9IChpbmRleCA9PT0gMCA/ICcxLycrZWwubnVtX3F1ZXN0aW9ucyA6IGVsLm51bV9xdWVzdGlvbnMpO1xuICAgICAgICAgICAgdmFyICRsaSA9IFwiPGxpIGNsYXNzPSdcIitsaV9jbGFzcytcIicgc3R5bGU9J3dpZHRoOlwiK3dpZHRoX3BlcmMrXCIlJz48YSBocmVmPScjJyBkYXRhLWdpZD0nXCIrZWwuZ3JvdXAuaWQuZ2lkK1wiJyBkYXRhLW51bS1xdWVzdGlvbnM9J1wiK2VsLm51bV9xdWVzdGlvbnMrXCInIHRhcmdldD0nX2JsYW5rJz5cIitsaV9jb250ZW50K1wiPC9hPjwvbGk+XCI7XG4gICAgICAgICAgICAkKCcuZ3JvdXBzLW5hdiB1bCcpLmFwcGVuZCgkbGkpO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmF2IGJhY2tncm91bmRcbiAgICAgICAgICAgIHZhciBuYXZfYmFja2dyb3VuZF9pbWdfcGF0aCA9IFwiL2NvbnRlbnQvdGhlbWVzL3Byb2N5bmMvYXBwL2Fzc2V0cy9pbWFnZXMvbmF2L25hdlwiK3NlbGYuZ3JvdXBzLmxlbmd0aCtcIi1cIitpbmRleCtcIi5wbmdcIjtcbiAgICAgICAgICAgIHZhciAkaW1nID0gJCgnPGltZyBzcmM9XCInK25hdl9iYWNrZ3JvdW5kX2ltZ19wYXRoKydcIiBhbHQ9XCJwcmV2aW91c1wiIGRhdGEtbmR4PVwiJytpbmRleCsnXCIgY2xhc3M9XCInK2ltZ19jbGFzcysnXCI+Jyk7XG4gICAgICAgICAgICAkKCcucHJvY3luY1Jvb3QgLmNhdGVnb3J5LW5hdmlnYXRpb24tY29udGFpbmVyJykucHJlcGVuZCgkaW1nKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICAkKCcuZ3JvdXAtaGVhZGVyJykuaHRtbChzZWxmLmdyb3Vwc1swXS5ncm91cC5ncm91cF9uYW1lKS5hdHRyKCdkYXRhLWdyb3VwLWlkJywgc2VsZi5ncm91cHNbMF0uZ3JvdXAuaWQuZ2lkKTs7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogW2luaXRHcm91cHMgLSBpbml0aWFsaXplcyBxdWVzdGlvbnMgcmVsYXRlZCBET00gZWxlbWVudHNdXG4gICAgICogdXNlZCBvbiBpbml0IGFuZCByZXNldDM2MFxuICAgICAqL1xuICAgIGluaXRRdWVzdGlvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi4kcXVlc3Rpb25Db250YWluZXIgPSAkKCcucXVlc3Rpb24tY29udGFpbmVyJyksXG4gICAgICAgIHNlbGYuJGhlbHBDb250YWluZXIgICAgID0gJCgnLmhlbHAtY29udGFpbmVyJyk7XG5cbiAgICAgICAgc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgc2VsZi4kaGVscENvbnRhaW5lci5lbXB0eSgpO1xuXG4gICAgICAgIHNlbGYubnVtX3F1ZXN0aW9ucyAgICAgPSBzZWxmLnF1ZXN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHNlbGYuY3Vycl9xdWVzdGlvbl9uZHggPSAwO1xuICAgICAgICBzZWxmLnByZXZfcXVlc3Rpb25fbmR4ID0gc2VsZi5udW1fcXVlc3Rpb25zIC0xO1xuICAgICAgICBzZWxmLm5leHRfcXVlc3Rpb25fbmR4ID0gMTtcblxuICAgICAgICAkLmVhY2goc2VsZi5xdWVzdGlvbnMsIGZ1bmN0aW9uKGluZGV4LCBlbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHF1ZXN0aW9uID0gbmV3IGdsb2JhbC5BcHAucXVlc3Rpb247XG4gICAgICAgICAgICBxdWVzdGlvbi5pbml0KHNlbGYuc3VydmV5X2lkLCBlbCwgaW5kZXgpO1xuICAgICAgICAgICAgc2VsZi4kcXVlc3Rpb25Db250YWluZXIuYXBwZW5kKHF1ZXN0aW9uLiRlbCk7XG4gICAgICAgICAgICBzZWxmLiRoZWxwQ29udGFpbmVyLmFwcGVuZChxdWVzdGlvbi4kaGVscCk7XG4gICAgICAgICAgICBzZWxmLnF1ZXN0aW9uT2JqZWN0cy5wdXNoKHF1ZXN0aW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0dXAgaW5wdXQgZm9yIDFzdCBxdWVzdGlvblxuICAgICAgICB2YXIgY3Vycl9xdWVzdGlvbl9pZCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKS5hdHRyKCdkYXRhLXFpZCcpO1xuICAgICAgICAkKCdpbnB1dC5zbGlkZXI6Zmlyc3QnKS5hdHRyKCdkYXRhLXFpZCcsIGN1cnJfcXVlc3Rpb25faWQpO1xuICAgICAgICAkKCcuZ28tbmV4dC1xdWVzdGlvbicpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFtpbml0IC0gY2FsbGVkIG9uIGRvY3VtZW50IHJlYWR5XVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLmlzQW5pbWF0aW5nICAgICAgICA9IGZhbHNlO1xuICAgICAgICBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lciA9ICQoJy5xdWVzdGlvbi1jb250YWluZXInKTtcblxuICAgICAgICBzZWxmLmRvMTgwICAgICAgICAgICAgICA9IHBhcnNlSW50KCQoJy5wcm9jeW5jUm9vdCcpLmF0dHIoJ2RhdGEtZG8xODAnKSwgMTApO1xuICAgICAgICBzZWxmLmRvMzYwICAgICAgICAgICAgICA9IHBhcnNlSW50KCQoJy5wcm9jeW5jUm9vdCcpLmF0dHIoJ2RhdGEtZG8zNjAnKSwgMTApO1xuICAgICAgICBzZWxmLmN1cnJfc3RlcCAgICAgICAgICA9ICghc2VsZi5kbzE4MCA/ICczNjAnIDogJzE4MCcpO1xuXG4gICAgICAgIHNlbGYudXNlcl9yb2xlICAgICAgICAgID0gJCgnLnByb2N5bmNSb290JykuYXR0cignZGF0YS11c2Vycm9sZScpO1xuICAgICAgICBzZWxmLnVzZXJfdHlwZSAgICAgICAgICA9ICQoJy5wcm9jeW5jUm9vdCcpLmF0dHIoJ2RhdGEtdXNlcnR5cGUnKTtcbiAgICAgICAgc2VsZi51c2VyX3JlbGF0aW9uc2hpcCAgPSAkKCcucHJvY3luY1Jvb3QnKS5hdHRyKCdkYXRhLXVzZXJyZWxhdGlvbnNoaXAnKTtcbiAgICAgICAgc2VsZi5yZWxhdGlvbnNoaXBfdHlwZSAgPSAkKCcucHJvY3luY1Jvb3QnKS5hdHRyKCdkYXRhLXJlbGF0aW9uc2hpcHR5cGUnKTtcblxuICAgICAgICBzZWxmLmFnZW5jeV9uYW1lICAgICAgICA9ICQoJy5wcm9jeW5jUm9vdCcpLmF0dHIoJ2RhdGEtYWdlbmN5bmFtZScpO1xuICAgICAgICBzZWxmLmNvbXBhbnlfbmFtZSAgICAgICA9ICQoJy5wcm9jeW5jUm9vdCcpLmF0dHIoJ2RhdGEtY29tcGFueW5hbWUnKTtcbiAgICAgICAgc2VsZi5hZ2VuY3lfc3VydmV5aWQgICAgPSAkKCcucHJvY3luY1Jvb3QnKS5hdHRyKCdkYXRhLXN1cnZleV9pZF8xODAnKTtcbiAgICAgICAgc2VsZi5jb21wYW55X3N1cnZleWlkICAgPSAkKCcucHJvY3luY1Jvb3QnKS5hdHRyKCdkYXRhLXN1cnZleV9pZF8zNjAnKTtcblxuICAgICAgICBpZihzZWxmLmRvMTgwKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnN1cnZleV9pZCA9IHNlbGYuYWdlbmN5X3N1cnZleWlkO1xuICAgICAgICAgICAgJCgnLmNvbnRlbnQtMTgwJykuc2hvdygpO1xuICAgICAgICAgICAgJCgnLmNvbnRlbnQtMzYwJykuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5zdXJ2ZXlfaWQgPSBzZWxmLmNvbXBhbnlfc3VydmV5aWQ7XG4gICAgICAgICAgICAkKCcuY29udGVudC0zNjAnKS5zaG93KCk7XG4gICAgICAgICAgICAkKCcuY29udGVudC0xODAnKS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAkKCcuZ3JvdXAtaGVhZGVyLCAucHJvY3luY1Jvb3QnKS5yZW1vdmVDbGFzcygnZ3JvdXAtY2F0MSBncm91cC1jYXQyIGdyb3VwLWNhdDMgZ3JvdXAtY2F0NCBncm91cC1jYXQ1JykuYWRkQ2xhc3MoJ2dyb3VwLWNhdDEnKTtcblxuICAgICAgICBpZighKHNlbGYuZG8xODAgJiYgc2VsZi5kbzM2MCkpIHtcbiAgICAgICAgICAgICQoJy5yZXNldDM2MG9yRXhpdCcpLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2VsZi5kbzE4MCAmJiBzZWxmLmRvMzYwKSB7XG4gICAgICAgICAgICAkKCcuY2xvc2VXaW5kb3cnKS5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAkKCcucHJvY3luY0ludHJvJykuc2hvdygpO1xuICAgICAgICAkKCcucHJvY3luY0ludHJvJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cbiAgICAgICAgc2VsZi5hbnN3ZXJzID0ge307XG4gICAgICAgIHZhciAkc2xpZGVyID0gJCgnLnN1cnZleS1yYW5nZS1zbGlkZXInKTtcbiAgICAgICAgc2VsZi5mZXRjaERhdGEoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2xpZGVyLmF0dHIoJ2RhdGEtcWlkJywgc2VsZi5xdWVzdGlvbk9iamVjdHNbMF0ucXVlc3Rpb25faWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5iaW5kRXZlbnRzKCk7XG4gICAgICAgIHNlbGYuc2V0VGl0bGUoKTtcblxuXG4gICAgICAgIHZhciByYW5nZXNsaWRlcl9vcHRpb25zID0ge1xuXG4gICAgICAgICAgICBwb2x5ZmlsbDogZmFsc2UsXG4gICAgICAgICAgICByYW5nZUNsYXNzOiAncmFuZ2VzbGlkZXInLFxuICAgICAgICAgICAgZmlsbENsYXNzOiAncmFuZ2VzbGlkZXJfX2ZpbGwnLFxuICAgICAgICAgICAgaGFuZGxlQ2xhc3M6ICdyYW5nZXNsaWRlcl9faGFuZGxlJyxcblxuICAgICAgICAgICAgb25Jbml0OiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgb25TbGlkZTogZnVuY3Rpb24ocG9zaXRpb24sIHZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCcuaW5wdXQtdmFsJykuaHRtbCh2YWx1ZS50b0ZpeGVkKDEpKTtcbiAgICAgICAgICAgICAgICBpZigkKCcuZ28tbmV4dC1xdWVzdGlvbicpLmhhc0NsYXNzKCdpbmFjdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJy5nby1uZXh0LXF1ZXN0aW9uJykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZ2xvYmFsLnBsYXRmb3JtLm5hbWUgPT09IFwiSUVcIiAmJiBwYXJzZUludChnbG9iYWwucGxhdGZvcm0udmVyc2lvbiwgMTApIDwgMTApIHtcbiAgICAgICAgICAgIHJhbmdlc2xpZGVyX29wdGlvbnMucG9seWZpbGwgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnaW5wdXQuc2xpZGVyJykucmFuZ2VzbGlkZXIocmFuZ2VzbGlkZXJfb3B0aW9ucyk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ3BsYXRmb3JtJywgcGxhdGZvcm0ubmFtZSk7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5uYW1lID09PSAnU2FmYXJpJyAmJiBwbGF0Zm9ybS5vcy5mYW1pbHkgPT09ICdpT1MnICYmIHBhcnNlSW50KHBsYXRmb3JtLm9zLnZlcnNpb24sIDEwKSA+IDcgfHwgcGxhdGZvcm0udWEuaW5kZXhPZignbGlrZSBNYWMgT1MgWCcpICE9IC0xKSB7XG4gICAgICAgICAgICAkKCcubG93ZXItaW5wdXRzJykuY3NzKCdib3R0b20nLCAnOHJlbScpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW3Jlc2V0MzYwb3JFeGl0IC0gc2ltaWxhciB0byBhYm92ZSAtIGNhbGxlZCBvbiB0cmFuc2l0aW9uIGZyb20gMTgwIHRvIDM2MF1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICByZXNldDM2MG9yRXhpdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICQoJ2lucHV0LnNsaWRlcicpLmJpbmQoXCJjaGFuZ2UgcGFzdGUga2V5dXBcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKCcuaW5wdXQtdmFsJykuaHRtbCgkKCdpbnB1dC5zbGlkZXInKS52YWwoKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoJy5ncm91cC1oZWFkZXIsIC5wcm9jeW5jUm9vdCcpLnJlbW92ZUNsYXNzKCdncm91cC1jYXQxIGdyb3VwLWNhdDIgZ3JvdXAtY2F0MyBncm91cC1jYXQ0IGdyb3VwLWNhdDUnKS5hZGRDbGFzcygnZ3JvdXAtY2F0MScpO1xuXG4gICAgICAgIC8vIHJlc2V0IGFsbCB0aGUgdGhpbmdzXG4gICAgICAgIGlmKHNlbGYucmVsYXRpb25zaGlwX3R5cGUgPT09ICczNjAnKSB7XG5cbiAgICAgICAgICAgIGlmKHNlbGYuY3Vycl9zdGVwID09PSAnMTgwJykge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyX3N0ZXAgPSAnMzYwJztcblxuICAgICAgICAgICAgICAgIC8vICQoJy5tYWluLWNvbnRlbnQnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJCgnLnBvc3RlZC1hbnN3ZXJzJykuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAkKCcuYW5zd2VycycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKCcucmVzZXQzNjBvckV4aXQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkKCcuY2xvc2VXaW5kb3cnKS5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICAkKCcuY29udGVudC0zNjAnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgJCgnLmNvbnRlbnQtMTgwJykuaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgJCgnLmxvZ2luLWNvbnRlbnQyJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoJy5sb2dpbi1jb250ZW50Jykuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgJCgnLmxvZ2luLWFjdGlvbjInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJCgnLmxvZ2luLWFjdGlvbicpLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKCcubG93ZXItaW5wdXRzJykuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgJCgnLmNhdGVnb3J5LW5hdmlnYXRpb24tY29udGFpbmVyJykuc2hvdygpO1xuICAgICAgICAgICAgICAgICQoJy5ncm91cHMtbmF2Jykuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgJCgnLnByb2N5bmNJbnRybycpLnNob3coKTtcblxuICAgICAgICAgICAgICAgIC8vIEZGRlxuICAgICAgICAgICAgICAgIHNlbGYuc3VydmV5X2lkICAgICAgICA9IHNlbGYuY29tcGFueV9zdXJ2ZXlpZDtcblxuICAgICAgICAgICAgICAgIHNlbGYuYW5zd2VycyAgID0ge307XG4gICAgICAgICAgICAgICAgc2VsZi5ncm91cHMgICAgPSBzZWxmLmNvbXBhbnlfZ3JvdXBzO1xuICAgICAgICAgICAgICAgIHNlbGYucXVlc3Rpb25zID0gc2VsZi5jb21wYW55X3F1ZXN0aW9ucztcblxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdEdyb3VwcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdFF1ZXN0aW9ucygpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0VGl0bGUoKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q29udGVudFRvcE1hcmdpbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZihzZWxmLnJlbGF0aW9uc2hpcF90eXBlID09PSAnMTgwJykge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3I6IHRoaXMgaXMgYSAxODAnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbdXBkYXRlTmF2IC0gdXNlcyBmb3IgdXBkYXRpbmcgbmF2YmFyIHdoZW4gY3VycmVudCBxdWVzdGlvbiBncm91cCBjaGFuZ2VzXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gJGN1cnJfZWwgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHVwZGF0ZU5hdjogZnVuY3Rpb24oJGN1cnJfZWwpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgcXVlc3Rpb24gZ3JvdXAgYXR0cmlidXRlc1xuICAgICAgICB2YXIgY3Vycl9xdWVzdGlvbl9ncm91cCA9ICRjdXJyX2VsLmF0dHIoJ2RhdGEtZ2lkJyk7XG4gICAgICAgIHZhciBsaV9uZHggICAgICAgICAgICAgID0gXy5pbmRleE9mKHNlbGYuZ3JvdXBfZ2lkcywgY3Vycl9xdWVzdGlvbl9ncm91cCk7XG5cbiAgICAgICAgdmFyICRjdXJyX2dyb3VwX3F1ZXN0aW9ucyA9ICQoJy5xdWVzdGlvbi1jb250YWluZXIgbGlbZGF0YS1naWQ9XCInK2N1cnJfcXVlc3Rpb25fZ3JvdXArJ1wiXScpO1xuICAgICAgICB2YXIgcV9udW0gICAgICAgICAgICAgICA9IDA7XG5cbiAgICAgICAgaWYoISRjdXJyX2dyb3VwX3F1ZXN0aW9ucy5oYXNDbGFzcygnY3VycmVudCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnd2VpcmRuZXNzIC0gbm8gY3VycmVudCBpbiAuY3VycmVudCBncm91cCA/Pz8gJywgJCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAkY3Vycl9ncm91cF9xdWVzdGlvbnMuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgaWYoJCh0aGlzKS5oYXNDbGFzcygnY3VycmVudCcpKSB7IHJldHVybiBmYWxzZTt9XG4gICAgICAgICAgICBxX251bSsrO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLmdyb3VwX2xhc3RfcXVlc3Rpb25bY3Vycl9xdWVzdGlvbl9ncm91cF0gPSBzZWxmLmN1cnJfcXVlc3Rpb25fbmR4O1xuICAgICAgICBjb25zb2xlLmxvZygnbGFzdCBxdWVzdGlvbnMnLCBzZWxmLmdyb3VwX2xhc3RfcXVlc3Rpb24pO1xuXG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSBsaV9uZHgrMTtcbiAgICAgICAgdmFyIG5ld19jbGFzc19uYW1lID0gKHNlbGYuY3Vycl9zdGVwID09PSAnMTgwJyA/ICdncm91cC1jYXQnK2luY3JlbWVudCA6ICdncm91cDM2MC1jYXQnK2luY3JlbWVudCk7XG5cbiAgICAgICAgdmFyIGFsbF9ncm91cF9jYXRfY2xhc3NlcyA9ICdncm91cC1jYXQxIGdyb3VwLWNhdDIgZ3JvdXAtY2F0MyBncm91cC1jYXQ0IGdyb3VwLWNhdDUgZ3JvdXAzNjAtY2F0MSBncm91cDM2MC1jYXQyIGdyb3VwMzYwLWNhdDMnO1xuICAgICAgICAkKCcuZ3JvdXAtaGVhZGVyLCAucHJvY3luY1Jvb3QnKS5yZW1vdmVDbGFzcyhhbGxfZ3JvdXBfY2F0X2NsYXNzZXMpLmFkZENsYXNzKG5ld19jbGFzc19uYW1lKTtcbiAgICAgICAgaWYoY3Vycl9xdWVzdGlvbl9ncm91cCAhPT0gc2VsZi5jdXJyX2dyb3VwKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZ3JvdXAtaGVhZGVyXG4gICAgICAgICAgICAkKCcuZ3JvdXAtaGVhZGVyJykuaHRtbChzZWxmLmdyb3Vwc1tsaV9uZHhdLmdyb3VwLmdyb3VwX25hbWUpLmF0dHIoJ2RhdGEtZ3JvdXAtaWQnLCBzZWxmLmdyb3Vwc1tsaV9uZHhdLmdyb3VwLmlkLmdpZCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBwcmV2IGdyb3VwIGxpIG5keFxuICAgICAgICAgICAgdmFyIHByZXZfbGlfbmR4ID0gXy5pbmRleE9mKHNlbGYuZ3JvdXBfZ2lkcywgc2VsZi5jdXJyX2dyb3VwKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgcHJldiBncm91cFxuICAgICAgICAgICAgJCgnLmdyb3Vwcy1uYXYgdWwgbGk6ZXEoJytwcmV2X2xpX25keCsnKScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICQoJy5ncm91cHMtbmF2IHVsIGxpOmVxKCcrbGlfbmR4KycpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgJCgnLmdyb3Vwcy1uYXYgdWwgbGk6ZXEoJytwcmV2X2xpX25keCsnKSBhJykuaHRtbChzZWxmLmdyb3Vwc1twcmV2X2xpX25keF0ubnVtX3F1ZXN0aW9ucyk7XG4gICAgICAgICAgICBzZWxmLmN1cnJfZ3JvdXAgPSBjdXJyX3F1ZXN0aW9uX2dyb3VwO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJldmlvdXMgYmFja2dyb3VuZCBjbGFzc1xuICAgICAgICAgICAgJCgnLm5hdi1iYWNrZ3JvdW5kW2RhdGEtbmR4PScrcHJldl9saV9uZHgrJ10nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAkKCcubmF2LWJhY2tncm91bmRbZGF0YS1uZHg9JytsaV9uZHgrJ10nKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBfdGV4dCA9IChxX251bSsxKSsnLycrc2VsZi5ncm91cHNbbGlfbmR4XS5udW1fcXVlc3Rpb25zO1xuICAgICAgICAkKCcuZ3JvdXBzLW5hdiB1bCBsaTplcSgnK2xpX25keCsnKSBhJykuaHRtbChncm91cF90ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW2dvVG9RdWVzdGlvbiAtIGdvIHRvIGEgc3BlY2lmaWMgcXVlc3Rpb24gd2l0aG91dCBkb2luZyBhbnkgYW5pbWF0aW9uc11cbiAgICAgKiBjYWxsZWQgd2hlbiA6XG4gICAgICogICAgIDEpIHNlbGVjdGluZyBhIGRpZmZlcmVudCBncm91cCBpbiB0aGUgbmF2YmFyXG4gICAgICogICAgIDIpIGZvdW5kIHNvbWV0aG5nIGluY29tcGxldGUgdXBvbiBzYXZpbmcgYW5zd2Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBxdWVzdGlvbl9uZHggW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gJG5hdl9lbCAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgZ29Ub1F1ZXN0aW9uOiBmdW5jdGlvbihxdWVzdGlvbl9uZHgsICRuYXZfZWwpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCduZHgnLCBxdWVzdGlvbl9uZHgpO1xuXG4gICAgICAgIGlmKHF1ZXN0aW9uX25keCAhPT0gLTEpIHtcblxuICAgICAgICAgICAgLy8gcmVzZXQgbWFya2Vyc1xuICAgICAgICAgICAgc2VsZi5jdXJyX3F1ZXN0aW9uX25keCA9IHF1ZXN0aW9uX25keDtcbiAgICAgICAgICAgIHNlbGYucHJldl9xdWVzdGlvbl9uZHggPSAoc2VsZi5jdXJyX3F1ZXN0aW9uX25keCA+IDAgPyBzZWxmLmN1cnJfcXVlc3Rpb25fbmR4IC0gMSA6IHNlbGYubnVtX3F1ZXN0aW9ucyAtIDEpO1xuICAgICAgICAgICAgc2VsZi5uZXh0X3F1ZXN0aW9uX25keCA9IChzZWxmLmN1cnJfcXVlc3Rpb25fbmR4IDwgc2VsZi5udW1fcXVlc3Rpb25zIC0gMSA/IHNlbGYuY3Vycl9xdWVzdGlvbl9uZHggKyAxIDogMCk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGxpIG5leHQgcHJldmlvdXNcbiAgICAgICAgICAgIHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcygnbmV4dCcpLnJlbW92ZUNsYXNzKCdwcmV2aW91cycpLnJlbW92ZUNsYXNzKCdjdXJyZW50JykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJykuYWRkQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICBzZWxmLiRoZWxwQ29udGFpbmVyLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcygnbmV4dCcpLnJlbW92ZUNsYXNzKCdwcmV2aW91cycpLnJlbW92ZUNsYXNzKCdjdXJyZW50JykucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJykuYWRkQ2xhc3MoJ2luYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGN1cnJlbnRcbiAgICAgICAgICAgIHZhciAkbmV3X3ByZXZfZWw7XG4gICAgICAgICAgICBpZihzZWxmLnByZXZfcXVlc3Rpb25fbmR4ICE9PSBzZWxmLm51bV9xdWVzdGlvbnMgLSAxKSB7XG4gICAgICAgICAgICAgICAgJG5ld19wcmV2X2VsID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3NlbGYucHJldl9xdWVzdGlvbl9uZHgrXCIpXCIpO1xuICAgICAgICAgICAgICAgICRuZXdfcHJldl9lbC5yZW1vdmVDbGFzcyhcImluYWN0aXZlXCIpLmFkZENsYXNzKCdwcmV2aW91cycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgJG5ld19jdXJyX2VsID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3NlbGYuY3Vycl9xdWVzdGlvbl9uZHgrXCIpXCIpO1xuICAgICAgICAgICAgdmFyICRuZXdfY3Vycl9oZWxwX2VsID0gc2VsZi4kaGVscENvbnRhaW5lci5maW5kKFwibGk6ZXEoXCIrc2VsZi5jdXJyX3F1ZXN0aW9uX25keCtcIilcIik7XG4gICAgICAgICAgICAkbmV3X2N1cnJfZWwucmVtb3ZlQ2xhc3MoXCJpbmFjdGl2ZVwiKS5hZGRDbGFzcygnY3VycmVudCcpO1xuICAgICAgICAgICAgJG5ld19jdXJyX2hlbHBfZWwuYWRkQ2xhc3MoJ2N1cnJlbnQnKTtcbiAgICAgICAgICAgICRuZXdfY3Vycl9lbC5jc3MoJ29wYWNpdHknLCAxKTtcblxuICAgICAgICAgICAgdmFyICRuZXdfbmV4dF9lbDtcbiAgICAgICAgICAgIGlmKHNlbGYubmV4dF9xdWVzdGlvbl9uZHggIT09IDApIHtcbiAgICAgICAgICAgICAgICAkbmV3X25leHRfZWwgPSBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lci5maW5kKFwibGk6ZXEoXCIrc2VsZi5uZXh0X3F1ZXN0aW9uX25keCtcIilcIik7XG4gICAgICAgICAgICAgICAgJG5ld19uZXh0X2VsLnJlbW92ZUNsYXNzKFwiaW5hY3RpdmVcIikuYWRkQ2xhc3MoJ25leHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJfcXVlc3Rpb25faWQgPSAkbmV3X2N1cnJfZWwuYXR0cignZGF0YS1xaWQnKTtcbiAgICAgICAgICAgICQoJ2lucHV0LnNsaWRlcicpLmF0dHIoJ2RhdGEtcWlkJywgY3Vycl9xdWVzdGlvbl9pZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpbnB1dCB2YWx1ZVxuICAgICAgICAgICAgaWYoc2VsZi5hbnN3ZXJzLmhhc093blByb3BlcnR5KGN1cnJfcXVlc3Rpb25faWQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoJ2lucHV0LnNsaWRlcicpLnZhbChzZWxmLmFuc3dlcnNbY3Vycl9xdWVzdGlvbl9pZF0pO1xuICAgICAgICAgICAgICAgICQoJy5pbnB1dC12YWwnKS5odG1sKCQoJ2lucHV0LnNsaWRlcicpLnZhbCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi51cGRhdGVOYXYoJG5ld19jdXJyX2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQoJy5ncm91cHMtbmF2IGxpJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAkbmF2X2VsLmNsb3Nlc3QoJ2xpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbbmV4dEFuaW0gLSBtb3ZlIGZvcndhcmRdXG4gICAgICogdXNlZCBieSBuZXh0UXVlc3Rpb25cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBuZXh0QW5pbTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciAkaGVscENvbnRhaW5lciAgICAgPSAkKCcuaGVscC1jb250YWluZXInKTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIHByZXZcbiAgICAgICAgaWYoc2VsZi5uZXh0X3F1ZXN0aW9uX25keCAhPT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyICRvbGRfcHJldl9lbCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLnByZXZfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgICAgIFR3ZWVuTGl0ZS50bygkb2xkX3ByZXZfZWwsIDAsIHthdXRvQWxwaGE6MCwgY2xhc3NOYW1lOlwiaW5hY3RpdmVcIn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGxpJ3MgbmR4J3NcbiAgICAgICAgc2VsZi5jdXJyX3F1ZXN0aW9uX25keCA9IChzZWxmLmN1cnJfcXVlc3Rpb25fbmR4ICsgMSA+IHNlbGYubnVtX3F1ZXN0aW9ucyAtIDEgPyAwIDogc2VsZi5jdXJyX3F1ZXN0aW9uX25keCArIDEpO1xuICAgICAgICBzZWxmLnByZXZfcXVlc3Rpb25fbmR4ID0gKHNlbGYucHJldl9xdWVzdGlvbl9uZHggKyAxID4gc2VsZi5udW1fcXVlc3Rpb25zIC0gMSA/IDAgOiBzZWxmLnByZXZfcXVlc3Rpb25fbmR4ICsgMSk7XG4gICAgICAgIHNlbGYubmV4dF9xdWVzdGlvbl9uZHggPSAoc2VsZi5uZXh0X3F1ZXN0aW9uX25keCArIDEgPiBzZWxmLm51bV9xdWVzdGlvbnMgLSAxID8gMCA6IHNlbGYubmV4dF9xdWVzdGlvbl9uZHggKyAxKTtcblxuICAgICAgICAvLyBhZGQgbmV3IHByZXZcbiAgICAgICAgdmFyICRuZXdfcHJldl9lbCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLnByZXZfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfcHJldl9lbCwgMC41LCB7YXV0b0FscGhhOjEsIGNsYXNzTmFtZTpcInByZXZpb3VzXCJ9KTtcblxuICAgICAgICAvLyBjdXJyIGhlbHBcbiAgICAgICAgc2VsZi4kaGVscENvbnRhaW5lci5maW5kKFwibGlcIikucmVtb3ZlQ2xhc3MoJ25leHQnKS5yZW1vdmVDbGFzcygncHJldmlvdXMnKS5yZW1vdmVDbGFzcygnY3VycmVudCcpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB2YXIgJG5ld19jdXJyX2hlbHBfZWwgPSBzZWxmLiRoZWxwQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgJG5ld19jdXJyX2hlbHBfZWwuYWRkQ2xhc3MoJ2N1cnJlbnQnKTtcblxuICAgICAgICAvLyBhZGQgbmV3IGN1cnJlbnRcbiAgICAgICAgdmFyICRuZXdfY3Vycl9lbCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfY3Vycl9lbCwgMC41LCB7YXV0b0FscGhhOjEsIGNsYXNzTmFtZTpcImN1cnJlbnRcIn0pO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbmV4dFxuICAgICAgICBpZihzZWxmLm5leHRfcXVlc3Rpb25fbmR4ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgJG5ld19uZXh0X2VsID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3NlbGYubmV4dF9xdWVzdGlvbl9uZHgrXCIpXCIpO1xuICAgICAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfbmV4dF9lbCwgMCwge2F1dG9BbHBoYTowLCBjbGFzc05hbWU6XCJuZXh0XCJ9KTtcbiAgICAgICAgfVxuICAgICAgICAvL1R3ZWVuTGl0ZS50bygkKCcjcXVlc3Rpb24tY29udGFpbmVyJyksIDAuMiwge3RvcDogMCAtICRuZXdfcHJldl9lbC5wb3NpdGlvbigpLnRvcH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZU5hdigkbmV3X2N1cnJfZWwpO1xuICAgICAgICB9LCA3MDApO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFtwcmV2QW5pbSAtIG1vdmUgYmFja11cbiAgICAgKiB1c2VkIGJ5IHByZXZRdWVzdGlvblxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHByZXZBbmltOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyICRoZWxwQ29udGFpbmVyICAgICA9ICQoJy5oZWxwLWNvbnRhaW5lcicpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbmV4dFxuICAgICAgICB2YXIgJG9sZF9uZXh0X2VsID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3NlbGYubmV4dF9xdWVzdGlvbl9uZHgrXCIpXCIpO1xuICAgICAgICBUd2VlbkxpdGUudG8oJG9sZF9uZXh0X2VsLCAwLCB7YXV0b0FscGhhOjAsIGNsYXNzTmFtZTpcImluYWN0aXZlXCJ9KTtcblxuICAgICAgICAvLyB1cGRhdGUgbGkgbmR4J3NcbiAgICAgICAgc2VsZi5jdXJyX3F1ZXN0aW9uX25keCA9IChzZWxmLmN1cnJfcXVlc3Rpb25fbmR4IC0gMSA8IDAgPyBzZWxmLm51bV9xdWVzdGlvbnMgLSAxIDogc2VsZi5jdXJyX3F1ZXN0aW9uX25keCAtIDEpO1xuICAgICAgICBzZWxmLnByZXZfcXVlc3Rpb25fbmR4ID0gKHNlbGYucHJldl9xdWVzdGlvbl9uZHggLSAxIDwgMCA/IHNlbGYubnVtX3F1ZXN0aW9ucyAtIDEgOiBzZWxmLnByZXZfcXVlc3Rpb25fbmR4IC0gMSk7XG4gICAgICAgIHNlbGYubmV4dF9xdWVzdGlvbl9uZHggPSAoc2VsZi5uZXh0X3F1ZXN0aW9uX25keCAtIDEgPCAwID8gc2VsZi5udW1fcXVlc3Rpb25zIC0gMSA6IHNlbGYubmV4dF9xdWVzdGlvbl9uZHggLSAxKTtcblxuICAgICAgICBjb25zb2xlLmxvZygncHJldiBhbmltIG5keHMnLCBzZWxmLmN1cnJfcXVlc3Rpb25fbmR4LCBzZWxmLnByZXZfcXVlc3Rpb25fbmR4LCBzZWxmLm5leHRfcXVlc3Rpb25fbmR4KTtcblxuICAgICAgICAvLyBhZGQgbmV3IG5leHRcbiAgICAgICAgdmFyICRuZXdfbmV4dF9lbCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLm5leHRfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfbmV4dF9lbCwgMC41LCB7YXV0b0FscGhhOjEsIGNsYXNzTmFtZTpcIm5leHRcIn0pO1xuXG4gICAgICAgIC8vIGN1cnIgaGVscFxuICAgICAgICAkaGVscENvbnRhaW5lci5maW5kKFwibGlcIikucmVtb3ZlQ2xhc3MoJ25leHQnKS5yZW1vdmVDbGFzcygncHJldmlvdXMnKS5yZW1vdmVDbGFzcygnY3VycmVudCcpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICB2YXIgJG5ld19jdXJyX2hlbHBfZWwgPSBzZWxmLiRoZWxwQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgJG5ld19jdXJyX2hlbHBfZWwuYWRkQ2xhc3MoJ2N1cnJlbnQnKTtcblxuICAgICAgICAvLyBhZGQgbmV3IGN1cnJcbiAgICAgICAgdmFyICRuZXdfY3Vycl9lbCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKTtcbiAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfY3Vycl9lbCwgMC41LCB7YXV0b0FscGhhOjEsIGNsYXNzTmFtZTpcImN1cnJlbnRcIn0pO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgcHJldlxuICAgICAgICBpZihzZWxmLnByZXZfcXVlc3Rpb25fbmR4ICE9PSBzZWxmLm51bV9xdWVzdGlvbnMgLSAxKSB7XG4gICAgICAgICAgICB2YXIgJG5ld19wcmV2X2VsID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3NlbGYucHJldl9xdWVzdGlvbl9uZHgrXCIpXCIpO1xuICAgICAgICAgICAgVHdlZW5MaXRlLnRvKCRuZXdfcHJldl9lbCwgMCwge2F1dG9BbHBoYTowLCBjbGFzc05hbWU6XCJwcmV2aW91c1wifSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJGRpc2NvdW50X2VsID0gKCRuZXdfcHJldl9lbCA/ICRuZXdfcHJldl9lbCA6ICRuZXdfY3Vycl9lbCk7XG4gICAgICAgIC8vVHdlZW5MaXRlLnRvKCQoJyNxdWVzdGlvbi1jb250YWluZXInKSwgMC4yLCB7dG9wOiAwIC0gJGRpc2NvdW50X2VsLnBvc2l0aW9uKCkudG9wfSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYudXBkYXRlTmF2KCRuZXdfY3Vycl9lbCk7XG4gICAgICAgIH0sIDcwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFtuZXh0UXVlc3Rpb24gLSBnbyBmb3J3YXJkIGJ5IDEgcXVlc3Rpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgbmV4dFF1ZXN0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICRzbGlkZXIgPSAkKCcuc3VydmV5LXJhbmdlLXNsaWRlcicpLFxuICAgICAgICAkc2xpZGVyVmFsdWVDb250YWluZXIgPSAkc2xpZGVyLnByZXYoJy5pbnB1dC12YWwnKTtcbiAgICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gZ2V0IGlucHV0IHZhbHVlXG4gICAgICAgIHZhciBhbnN3ZXJfdmFsID0gJHNsaWRlci52YWwoKTtcbiAgICAgICAgdmFyIGFuc3dlcl9pZCA9ICRzbGlkZXIuYXR0cignZGF0YS1xaWQnKTtcbiAgICAgICAgc2VsZi5hbnN3ZXJzW2Fuc3dlcl9pZF0gPSBhbnN3ZXJfdmFsO1xuXG4gICAgICAgIC8vIGxhc3QgcXVlc3Rpb25cbiAgICAgICAgaWYoc2VsZi5jdXJyX3F1ZXN0aW9uX25keCA9PT0gc2VsZi5udW1fcXVlc3Rpb25zLTEpIHtcblxuICAgICAgICAgICAgdmFyICRlbCA9IHNlbGYudmVyaWZ5QW5zd2VycygpO1xuICAgICAgICAgICAgaWYoJGVsID09PSBmYWxzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkKCcubWFpbi1jb250ZW50JykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoJy5sb3dlci1pbnB1dHMnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zYXZlQW5zd2VycygpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2dvaW5nIHRvIG1pc3NlZCBxdWVzdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXN0aW9uX25keCA9ICRlbC5pbmRleCgpO1xuICAgICAgICAgICAgICAgIHZhciBncm91cF9pZCA9ICRlbC5hdHRyKCdkYXRhLWdpZCcpO1xuICAgICAgICAgICAgICAgIHZhciAkbmF2X2VsID0gJChcIi5ncm91cHMtbmF2IGFbZGF0YS1naWQ9XCIrZ3JvdXBfaWQrXCJdXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuZ29Ub1F1ZXN0aW9uKHF1ZXN0aW9uX25keCwgJG5hdl9lbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8ganVzdCBhbm90aGVyIHF1ZXN0aW9uXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHNlbGYubmV4dEFuaW0oKTtcblxuICAgICAgICAgICAgLy8gc2V0IGlucHV0IHFpZFxuICAgICAgICAgICAgdmFyIGN1cnJfcXVlc3Rpb25faWQgPSBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lci5maW5kKFwibGk6ZXEoXCIrc2VsZi5jdXJyX3F1ZXN0aW9uX25keCtcIilcIikuYXR0cignZGF0YS1xaWQnKTtcbiAgICAgICAgICAgICRzbGlkZXIuYXR0cignZGF0YS1xaWQnLCBjdXJyX3F1ZXN0aW9uX2lkKTtcblxuICAgICAgICAgICAgLy8gc2V0IGlucHV0IHZhbHVlXG4gICAgICAgICAgICBpZihzZWxmLmFuc3dlcnMuaGFzT3duUHJvcGVydHkoY3Vycl9xdWVzdGlvbl9pZCkpIHtcbiAgICAgICAgICAgICAgICAkc2xpZGVyLnZhbChzZWxmLmFuc3dlcnNbY3Vycl9xdWVzdGlvbl9pZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2xpZGVyLnZhbCg1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHNsaWRlclZhbHVlQ29udGFpbmVyLmh0bWwoJHNsaWRlci52YWwoKSk7XG4gICAgICAgICAgICAvL2hpc3RvcnkucHVzaFN0YXRlKHtxX25keDogc2VsZi5jdXJyX3F1ZXN0aW9uX25keH0sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgSGlzdG9yeS5wdXNoU3RhdGUoe3FfbmR4OiBzZWxmLmN1cnJfcXVlc3Rpb25fbmR4fSwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAkKCdpbnB1dFt0eXBlPVwicmFuZ2VcIl0nKS5yYW5nZXNsaWRlcigndXBkYXRlJywgdHJ1ZSk7XG4gICAgICAgICQoJy5nby1uZXh0LXF1ZXN0aW9uJykuYWRkQ2xhc3MoJ2luYWN0aXZlJyk7XG5cbiAgICAgICAgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBbcHJldlF1ZXN0aW9uIC0gZ28gYmFjayBieSAxIHF1ZXN0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHByZXZRdWVzdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgJHNsaWRlciA9ICQoJy5zdXJ2ZXktcmFuZ2Utc2xpZGVyJyksXG4gICAgICAgICAgICAkc2xpZGVyVmFsdWVDb250YWluZXIgPSAkc2xpZGVyLnByZXYoJy5pbnB1dC12YWwnKTtcblxuICAgICAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYoc2VsZi5jdXJyX3F1ZXN0aW9uX25keCAhPT0gMCkge1xuXG4gICAgICAgICAgICBzZWxmLnByZXZBbmltKCk7XG4gICAgICAgICAgICB2YXIgY3Vycl9xdWVzdGlvbl9pZCA9IHNlbGYuJHF1ZXN0aW9uQ29udGFpbmVyLmZpbmQoXCJsaTplcShcIitzZWxmLmN1cnJfcXVlc3Rpb25fbmR4K1wiKVwiKS5hdHRyKCdkYXRhLXFpZCcpO1xuICAgICAgICAgICAgJHNsaWRlci5hdHRyKCdkYXRhLXFpZCcsIGN1cnJfcXVlc3Rpb25faWQpO1xuXG4gICAgICAgICAgICAvLyBzZXQgaW5wdXQgdmFsdWVcbiAgICAgICAgICAgIGlmKHNlbGYuYW5zd2Vycy5oYXNPd25Qcm9wZXJ0eShjdXJyX3F1ZXN0aW9uX2lkKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkc2xpZGVyLnZhbChzZWxmLmFuc3dlcnNbY3Vycl9xdWVzdGlvbl9pZF0pO1xuICAgICAgICAgICAgICAgICRzbGlkZXJWYWx1ZUNvbnRhaW5lci5odG1sKCRzbGlkZXIudmFsKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcihcInBvcHN0YXRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCgnaW5wdXRbdHlwZT1cInJhbmdlXCJdJykucmFuZ2VzbGlkZXIoJ3VwZGF0ZScsIHRydWUpO1xuICAgICAgICBzZWxmLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHZlcmlmeUFuc3dlcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25zb2xlLmxvZygnYWxsIHFvJywgc2VsZi5xdWVzdGlvbk9iamVjdHMsIHNlbGYuYW5zd2Vycyk7XG4gICAgICAgIGZvcih2YXIgcW8gaW4gc2VsZi5xdWVzdGlvbk9iamVjdHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4gcW8gJywgc2VsZi5hbnN3ZXJzW3NlbGYucXVlc3Rpb25PYmplY3RzW3FvXS5xdWVzdGlvbl9pZF0sIHNlbGYucXVlc3Rpb25PYmplY3RzW3FvXS5xdWVzdGlvbl9pZCk7XG4gICAgICAgICAgICBpZihzZWxmLmFuc3dlcnNbc2VsZi5xdWVzdGlvbk9iamVjdHNbcW9dLnF1ZXN0aW9uX2lkXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciAkZWwgPSBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lci5maW5kKFwibGlbZGF0YS1xaWQ9XCIrc2VsZi5xdWVzdGlvbk9iamVjdHNbcW9dLnF1ZXN0aW9uX2lkK1wiXVwiKTtcbiAgICAgICAgICAgICAgICBpZigkZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogW3NhdmVBbnN3ZXJzIGRlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNhdmVBbnN3ZXJzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBvc3RfZGF0YSA9IHt9O1xuICAgICAgICAkLmV4dGVuZCh0cnVlLCBwb3N0X2RhdGEsIHNlbGYuYW5zd2Vycywge2FjdGlvbjogJ3Bvc3RBbnN3ZXJzJywgbGltZXN1cnZleV9pZDogc2VsZi5zdXJ2ZXlfaWQsIGV2YWx1YXRpb25faWQ6IHNlbGYudXNlcl9yZWxhdGlvbnNoaXAsIHN0ZXA6IHNlbGYuY3Vycl9zdGVwfSk7XG4gICAgICAgICQoJy5wb3N0ZWQtYW5zd2VycycpLmVtcHR5KCk7XG5cbiAgICAgICAgdmFyIHJlc3BvbnNlX3N0YXR1cztcbiAgICAgICAgJC53aGVuKHNlbGYuZXhjaGFuZ2VEYXRhKHBvc3RfZGF0YSwgcmVzcG9uc2Vfc3RhdHVzKSkuZG9uZShmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhbnN3ZXJzIHJlc3BvbnNlJywgZGF0YSk7XG4gICAgICAgICAgICBpZihkYXRhLnN0YXR1cyA9PT0gJ09LJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkKCcuY2F0ZWdvcnktbmF2aWdhdGlvbi1jb250YWluZXInKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJCgnLmdyb3Vwcy1uYXYnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJCgnLmFuc3dlcnMnKS5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2VzIHNhdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0VSUk9SJywgZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFtzZXRDb250ZW50VG9wTWFyZ2luIGRlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIHNldENvbnRlbnRUb3BNYXJnaW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJ2J1dHRvbi5sb2dpbi1hY3Rpb24yJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBncm91cHNfaGVpZ2h0ID0gJCgnLm5hdi1iYWNrZ3JvdW5kOmZpcnN0JykuaGVpZ2h0KCk7XG5cbiAgICAgICAgICAgICQoJy5ncm91cHMtbmF2JykuaGVpZ2h0KGdyb3Vwc19oZWlnaHQpO1xuICAgICAgICAgICAgJCgnLmdyb3Vwcy11bCcpLmhlaWdodChncm91cHNfaGVpZ2h0KTtcblxuICAgICAgICB9KVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFtzZXRUaXRsZSBkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBzZXRUaXRsZTogZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdGl0bGVfc3RyID0gJyc7XG5cbiAgICAgICAgaWYoc2VsZi5jdXJyX3N0ZXAgPT09ICcxODAnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZV9zdHIgPSBzZWxmLmFnZW5jeV9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2VsZi5jdXJyX3N0ZXAgPT09ICczNjAnKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZV9zdHIgPSBzZWxmLmNvbXBhbnlfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlX3N0ciA9ICdFcnJvcic7XG4gICAgICAgIH1cblxuICAgICAgICAkKCcucmVsLXRpdGxlJykuaHRtbCh0aXRsZV9zdHIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFtiaW5kRXZlbnRzIC0gYmluZCBhbGwgcmVxdWlyZWQgZXZlbnRzXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBvcmllbnRhdGlvbiBsb2NrXG4gICAgICAgICQod2luZG93KS5iaW5kKCdvcmllbnRhdGlvbmNoYW5nZScsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgc3dpdGNoICggd2luZG93Lm9yaWVudGF0aW9uICkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgJCgnLnR1cm5EZXZpY2VOb3RpZmljYXRpb24nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGV2aWNlIGlzIGluIHBvcnRyYWl0IG1vZGUgbm93XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgICAgICAgICAgICQoJy50dXJuRGV2aWNlTm90aWZpY2F0aW9uJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRldmljZSBpcyBpbiBwb3J0cmFpdCBtb2RlIG5vd1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkZXZpY2UgaXMgaW4gbGFuZHNjYXBlIG5vd1xuICAgICAgICAgICAgICAgICAgICAkKCcudHVybkRldmljZU5vdGlmaWNhdGlvbicpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgLTkwOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBub3dcbiAgICAgICAgICAgICAgICAgICAgJCgnLnR1cm5EZXZpY2VOb3RpZmljYXRpb24nKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW50cm8gc2V0dXBcbiAgICAgICAgaWYoJCgnLnByb2N5bmNJbnRybycpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5sb2dpbi1hY3Rpb24nLCBmdW5jdGlvbihldilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICQoJy5sb2dpbi1jb250ZW50JykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoJy5sb2dpbi1jb250ZW50MicpLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKCcubG9naW4tYWN0aW9uJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoJy5sb2dpbi1hY3Rpb24yJykuc2hvdygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnLmxvZ2luLWFjdGlvbjInLCBmdW5jdGlvbihldilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICQoJy5xdWVzdGlvbi1jb250YWluZXInKS5jc3MoJ3RvcCcsIDApO1xuICAgICAgICAgICAgICAgICQoJy5wcm9jeW5jSW50cm8nKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgJCgnLm1haW4tY29udGVudCcpLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKCcucHJvY3luY1Jvb3QnKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDb250ZW50VG9wTWFyZ2luKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1haW4gcXVlc3Rpb25haXJlIHNldHVwXG4gICAgICAgIGlmKCQoJy5wcm9jeW5jUm9vdCcpLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBCaW5kIHRvIFN0YXRlQ2hhbmdlIEV2ZW50IC0gdGhpcyBpcyBtZWFudCB0byB1c2Ugc3RhdGVjaGFuZ2UgYnV0IHRodGEgZmlyZXMgYWxsIHRoZSB0aW1lIDooXG4gICAgICAgICAgICBIaXN0b3J5LkFkYXB0ZXIuYmluZCh3aW5kb3csICdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKGV2dCl7IC8vIE5vdGU6IFdlIGFyZSB1c2luZyBzdGF0ZWNoYW5nZSBpbnN0ZWFkIG9mIHBvcHN0YXRlXG4gICAgICAgICAgICAgICAgdmFyIFN0YXRlID0gSGlzdG9yeS5nZXRTdGF0ZSgpOyAvLyBOb3RlOiBXZSBhcmUgdXNpbmcgSGlzdG9yeS5nZXRTdGF0ZSgpIGluc3RlYWQgb2YgZXZlbnQuc3RhdGVcbiAgICAgICAgICAgICAgICAvL0hpc3RvcnkubG9nKFN0YXRlLmRhdGEsIFN0YXRlLnRpdGxlLCBTdGF0ZS51cmwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXN0aW9uX25keCA9IFN0YXRlLmRhdGEucV9uZHg7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwX2lkID0gc2VsZi4kcXVlc3Rpb25Db250YWluZXIuZmluZChcImxpOmVxKFwiK3F1ZXN0aW9uX25keCtcIilcIikuYXR0cignZGF0YS1naWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgJG5hdl9lbCA9ICQoXCIuZ3JvdXBzLW5hdiBhW2RhdGEtZ2lkPVwiK2dyb3VwX2lkK1wiXVwiKTtcbiAgICAgICAgICAgICAgICAvL3NlbGYuZ29Ub1F1ZXN0aW9uKFN0YXRlLnFfbmR4LCAkbmF2X2VsKTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwb3BzdGF0ZScsIHF1ZXN0aW9uX25keCwgU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIC8vIGJhY2sgYnV0dG9uIGJyb3dzZXIgaGlzdG9yeVxuICAgICAgICAgICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgIC8vICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vICAgICB2YXIgcXVlc3Rpb25fbmR4ID0gZS5zdGF0ZS5xX25keDtcbiAgICAgICAgICAgIC8vICAgICB2YXIgZ3JvdXBfaWQgPSBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lci5maW5kKFwibGk6ZXEoXCIrcXVlc3Rpb25fbmR4K1wiKVwiKS5hdHRyKCdkYXRhLWdpZCcpO1xuICAgICAgICAgICAgLy8gICAgIHZhciAkbmF2X2VsID0gJChcIi5ncm91cHMtbmF2IGFbZGF0YS1naWQ9XCIrZ3JvdXBfaWQrXCJdXCIpO1xuICAgICAgICAgICAgLy8gICAgIHNlbGYuZ29Ub1F1ZXN0aW9uKGUuc3RhdGUucV9uZHgsICRuYXZfZWwpO1xuXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyB9KTtcblxuICAgICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENvbnRlbnRUb3BNYXJnaW4oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrJywnLnJlc2V0MzYwb3JFeGl0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVzZXQzNjBvckV4aXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrJywnLmdvLXByZXYtcXVlc3Rpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZRdWVzdGlvbigpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoJ2JvZHknKS5vbignY2xpY2snLCcuZ28tbmV4dC1xdWVzdGlvbicsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgaWYoJCgnLmdvLW5leHQtcXVlc3Rpb24nKS5oYXNDbGFzcygnaW5hY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAkKCcuZ28tbmV4dC1xdWVzdGlvbicpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmV4dFF1ZXN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoJy5oZWxwLXRvZ2dsZScpLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZhciAkaGVscF9zdGF0dXMgPSAkKCcuaGVscC1jb250YWluZXInKS5maW5kKCcuY3VycmVudCcpO1xuICAgICAgICAgICAgICAgIGlmKCRoZWxwX3N0YXR1cy5oYXNDbGFzcygnaW5hY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAkaGVscF9zdGF0dXMucmVtb3ZlQ2xhc3MoJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGhlbHBfc3RhdHVzLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQoJ2JvZHknKS5vbignY2xpY2snLCAnLmdyb3Vwcy1uYXYgYScsIGZ1bmN0aW9uKGV2KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGdpZCA9ICQodGhpcykuYXR0cignZGF0YS1naWQnKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbmQgbGFzdCBhbnN3ZXJlZCBxdWVzdGlvbiB3aXRoIHdpdGhpbiBncm91cFxuICAgICAgICAgICAgICAgIC8vIHZhciBxdWVzdGlvbl9uZHggPSBzZWxmLiRxdWVzdGlvbkNvbnRhaW5lci5maW5kKFwibGlbZGF0YS1naWQ9XCIrZ2lkK1wiXTpmaXJzdFwiKS5pbmRleCgpO1xuICAgICAgICAgICAgICAgIHZhciBxdWVzdGlvbl9uZHggPSBzZWxmLmdyb3VwX2xhc3RfcXVlc3Rpb25bZ2lkXTtcbiAgICAgICAgICAgICAgICBpZigtMSA9PT0gcXVlc3Rpb25fbmR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmdvVG9RdWVzdGlvbihxdWVzdGlvbl9uZHgsICRlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFN1cnZleSgpO1xuIl19"]}