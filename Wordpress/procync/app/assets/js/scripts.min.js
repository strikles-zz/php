(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';


global.App = {

    debug: require('./_debug.js'),
    question: require('./survey/_question.js'),
    survey: require('./survey/_survey.js'),
    reporting: require('./reporting/reporting.js')
};

(function($) {

	//var $ = require('jquery');
    $( document ).ready(function() {

        // var $parent_el = $("#brim-main");
        // //console.log(navigator.userAgent.toLowerCase().indexOf('safari/') > -1);
        // if (platform.name === 'Safari' && platform.os.family === 'iOS' && parseInt(platform.os.version, 10) > 8 || platform.ua.indexOf('like Mac OS X') != -1) {

        //     var scream,
        //         brim;

        //     scream = gajus.Scream({
        //         width: {
        //             portrait: 320,
        //             landscape: 640
        //         }
        //     });

        //     brim = gajus.Brim({
        //         viewport: scream
        //     });

        //     brim.on('viewchange', function (e) {
        //         document.body.className = e.viewName;
        //     });

        // } else {
        //     $parent_el = $('#not-ios-8');
        //     $('#not-ios-8').css('display', 'block');
        // }

    	if($('.procyncRoot').length || $('.procyncIntro').length) {
        	global.App.survey.init();
        }

    });

})(global.jQuery);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_debug.js":3,"./reporting/reporting.js":6,"./survey/_question.js":7,"./survey/_survey.js":8}],2:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],3:[function(require,module,exports){
'use strict';

var Edebug = function() {

};

Edebug.prototype =  {

	var_dump: function(obj, indentSpaces) {

		var self = this;

	    switch (typeof obj) {
	        case "object":
	            console.log(self.indent(indentSpaces) + typeof obj + ":");
	            indentSpaces += 2; // indent further as we are entering the objects properties
	            for (var i in obj) {

	            	if(obj.hasOwnProperty(i)) {
		                console.log(self.indent(indentSpaces) + i + ":");
		                self.var_dump(obj[i], indentSpaces + 1);
		            }
	            }
	            break;
	        default: // things that are not objects, primatives... etc...
	            console.log(self.indent(indentSpaces) + typeof obj + ":" + obj);
	            break;
	    }
	},

	// just for styling with indents
	indent: function(spaces)
	{
	    var i = 0;
	    var rtr = "";
	    while(i <= (spaces * 2)) {
	        rtr += " ";
	        i++;
	    }
	    return rtr;
	}

};

module.exports = new Edebug();

},{}],4:[function(require,module,exports){
'use strict';

var HighchartsGraph = function() {

    this.options;

    // if (!global.charts) {
    //  global.charts = [];
    // }
    // global.charts.push(self);
    // return self;
};


HighchartsGraph.prototype = {

    /**
     * [setOptions - given a chart type get the options object and store it]
     * @param {[type]} chart_type [description]
     */
    setOptions: function(chart_type) {

        var self = this;

        var chartOptions = require('./charts-templates.js');
        self.options = chartOptions[chart_type];
        self.options.series = [];
    },

    getOptions: function() {

        var self = this;

        return self.options;
    },

    /**
     * [addXaxis - creates categories as xAxis labels]
     * @param {[type]} categories [description]
     */
    addXaxis: function(categories) {

        var self = this;

        self.options.xAxis.categories = categories;
    },

    /**
     * [addYaxis - creates categories as yAxis labels]
     * @param {[type]} categories [description]
     */
    addYaxis: function(categories) {

        var self = this;

        self.options.yAxis.categories = categories;
    },

    /**
     * [addSeries - adds a series and gives it a name and color]
     * @param {[type]} series_name  [description]
     * @param {[type]} series_data  [description]
     * @param {[type]} series_color [description]
     */
    addSeries: function(series_name, series_data, series_color, series_dashstyle) {

        var self = this;
        var series_entry = {name: series_name, visible: false, data: series_data};

        if(series_color) {
            series_entry.color = series_color;
        }

        if(series_dashstyle) {
            series_entry.dashStyle = series_dashstyle;
        }

        self.options.series.push(series_entry);
    },

    /**
     * [setBackgroundColor - set HC background color]
     * @param {[type]} color [description]
     */
    setBackgroundColor: function(color) {

        var self = this;
        self.options.chart.backgroundColor = color;
    },

    /**
     * [setYaxisBenchmark - draw benchmark line]
     * @param {[type]} val [description]
     */
    setYaxisBenchmark: function(val) {

        var self = this;
        self.options.yAxis.plotLines[0].value = val;
    },

    /**
     * [renderGraph - renders the graph]
     * @return {[type]} [description]
     */
    renderGraph: function() {

        var self = this;

        if(!self.chart) {
            self.chart = new window.Highcharts.Chart(self.options);
        }

        /*
        else {
            self.chart.redraw();
        }
        */
    }
};

module.exports = HighchartsGraph;

},{"./charts-templates.js":5}],5:[function(require,module,exports){
Highcharts.setOptions({
    chart: {
        plotBackgroundColor: null,
        plotBorderWidth: null,
        backgroundColor:'rgba(255, 255, 255, 0.1)',
        plotShadow: false
    },
    exporting: {
        enabled: false
    },
    credits: {
        enabled: false
    },
    title: {
        text: ''
    },
    subtitle: {
        text: ''
    },
    plotOptions: {
        column: {
            borderWidth: 0,
            colorByPoint:false
        },
        bar: {
            pointWidth: 20
        },
        pie: {
            allowPointSelect: true,
            cursor: 'pointer',
            dataLabels: {
                 enabled: false
            },
            showInLegend: true
        }
    },
});

var chartTemplates = {

    'dashboard-participants': {

        chart: {
            type: 'bar',
            renderTo: undefined
        },
        title: {
            text: ''
        },
        subtitle: {
            text: ''
        },
        legend: {
            enabled: false
        },
        yAxis: {
            min: 20,
            title: {
                text: null
            },
            plotLines: [{
                value: 65,
                color: 'red',
                dashStyle: 'shortdot',
                width: 1,
                zIndex: 999,
                label: {
                    text: '-delta'
                }
            }, {
                value: 75,
                color: 'red',
                dashStyle: 'shortdot',
                width: 1,
                zIndex: 999,
                label: {
                    text: '+delta'
                }
            }, {
                value: 70,
                color: 'green',
                width: 2,
                zIndex: 999,
                label: {
                    text: 'Benchmark'
                }
            }]
        },
        xAxis: {
            categories: undefined
        },
        tooltip: {
            //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',
            headerFormat: ''
        },
        plotOptions: {
            bar: {
                colorByPoint: true,
                colors: ['#a5abcd', '#666fa6', '#404565', '#6f5706']
            }
        },
        series: []
    },

    'dashboard-allcoresubjects': {

        chart: {
            polar: true,
            renderTo: undefined
        },
        pane: {
            startAngle: 0,
            endAngle: 360
        },
        title: {
            text: ''
        },
        subtitle: {
            text: ''
        },
        xAxis: {
            categories: undefined,
            tickmarkPlacement: 'on',
            lineWidth: 0,
            title: {
                text: null
            },
        },
        yAxis: [{
            gridLineInterpolation: 'circle',
            lineWidth: 0,
            allowDecimals: false,
            min: 0,
            title: {
                text: null
            },
        },{
            gridLineInterpolation: 'polygon',
            lineWidth: 0,
            allowDecimals: false,
            min: 0,
            title: {
                text: null
            },
        }],
        tooltip: {
            //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',
            headerFormat: ''
        },
        legend: {
            align: 'left',
            verticalAlign: 'top',
            layout: 'vertical'
        },
        plotOptions: {},
        series: []
    },

    'dashboard-singlegroup': {

        chart: {
            type: 'column',
            renderTo: undefined,
            backgroundColor: '#FFFFFF'
        },
        title: {
            text: ''
        },
        subtitle: {
            text: ''
        },
        xAxis: {
            gridLineWidth: 0,
            minorGridLineWidth: 0,
            minorTickLength: 0,
            tickLength: 0,
            lineColor: 'transparent',
            labels: {
              enabled: false
            },
            title: {
                text: null
            }
        },
        yAxis: {
            gridLineWidth: 0,
            minorGridLineWidth: 0,
            min: 0,
            max: 100,
            title: {
                text: null
            },
            labels: {
                enabled: true
            },
            plotLines: []
        },
        tooltip: {
            //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',
            headerFormat: ''
        },
        legend: {
            enabled: false
        },
        plotOptions: {
            column: {
                dataLabels: {
                    enabled: true,
                    crop: false,
                    format: '{point.y:,.0f}'
                }
            }
        },
        series: []
    },

    'selected-group': {

        chart: {
            type: 'column',
            renderTo: undefined
        },
        title: {
            text: ''
        },
        subtitle: {
            text: ''
        },
        xAxis: {
            categories: undefined
        },
        yAxis: {
            allowDecimals: false,
            min: 0,
            title: {
                text: ''
            }
        },
        tooltip: {
            //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',
            headerFormat: ''
        },
        legend: {
            enabled: false
        },
        plotOptions: {
            column: {
                dataLabels: {
                    enabled: true,
                    crop: false,
                    format: '{point.y:,.0f}'
                }
            }
        },
        series: []
    },

    'allcoresubjects': {

        chart: {
            type: 'line',
            renderTo: undefined
        },
        title: {
            text: ''
        },
        subtitle: {
            text: ''
        },
        xAxis: {
            categories: undefined,
            title: {
                text: null
            }
        },
        legend: {
            enabled: false
        },
        tooltip: {
            //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:.1f}</b><br/>',
            headerFormat: ''
        },
        plotOptions: {},
        series: []
    }
};



module.exports = chartTemplates;

},{}],6:[function(require,module,exports){
(function (global){
//var $ = require('jquery');
var $ = global.$;
var _ = require('underscore');
var Cookies = global.Cookies;

var app = window.angular.module('procyncReporting', ['ngRoute', 'ngResource', 'angular-loading-bar', 'ngAnimate']);
var Ehighcharts = require('./charts/HighchartsGraph.js');

app.config(['$routeProvider', '$locationProvider', function($routeProvider, $locationProvider) {

    'use strict';

    $routeProvider
        .when('/reporting', {
            templateUrl: 'relations.html',
        })
        .when('/reporting/dashboard', {
            templateUrl: 'dashboard.html',
        })
        .when('/reporting/selectedgroup/:gid', {
            templateUrl: 'selectedgroup.html',
        })
        .otherwise({
            redirectTo: '/reporting'
        });

        $locationProvider.html5Mode(true);
}])

.run(['$log', '$rootScope', '$timeout', function($log, $rootScope, $timeout) {

    'use strict';
    $rootScope.globals = {};

    // initialization tasks
    $timeout(function() {
        $log.log('run');
    });

}])

.controller('ProcyncReportingController', ['$rootScope', '$scope', '$location', '$log', '$route', '$routeParams', '$timeout', '$http', 'restService',
    function($rootScope, $scope, $location, $log, $route, $routeParams, $timeout, $http, restService) {

    'use strict';

    $scope.$route = $route;
    $scope.reporting = {
        relations: undefined,
        selected: {
            relation: undefined,
            step: undefined,
            singleGroup: undefined,
            periodSpan: {selectedgroup: false, dashboard: false},
            surveyType: undefined,
            surveyGroups: undefined,
            plotOptions: {
                dashboard: {
                    participants: undefined,
                    coreSubjects: undefined,
                    singleGroup: {}
                },
                selectedGroup: undefined
            },
            allData: undefined,
            referenceEval: undefined,
            evaluationStart: undefined,
            evaluationEnd: undefined,
            evaluationStartNDX: undefined,
            evaluationEndNDX: undefined,
            quarterIntervals: undefined
        },
        fetchingData: false
    };

    $rootScope.$on("$routeChangeSuccess",function(event, next, current){
        $log.log("$routeChangeStart", event, next, current);
    });

    /**
     * [loadCookie - used to load current state post F5]
     * @return {[boolean]} [cookie was loaded]
     */
    $scope.loadCookie = function() {

        var reporting_cookie = Cookies.getJSON('reporting');
        if (!$scope.reporting.selected.relation && reporting_cookie) {
            $.extend(true, $scope.reporting.selected, reporting_cookie);
            return true;
        }

        return false;
    };

    /**
     * [saveCookie - used to save current state for F5]
     * @return {[type]} [description]
     */
    $scope.saveCookie = function() {

        var cookie_obj = {relation: undefined, step: undefined, singleGroup: undefined};

        cookie_obj.relation    = $scope.reporting.selected.relation;
        cookie_obj.step        = $scope.reporting.selected.step;
        cookie_obj.singleGroup = $scope.reporting.selected.singleGroup;

        Cookies.set('reporting', cookie_obj);
        $log.log('saving cookie', Cookies.getJSON('reporting'));
    },

    $scope.sendMail = function(content) {

        $.ajax({
          type: 'POST',
          url: 'https://mandrillapp.com/api/1.0/messages/send.json',
          data: {
            'key': 'pnOu6dp21EuoM-Oqir8zHA',
            'message': {
              'from_email': 'andre@eenvoudmedia.nl',
              'to': [
                  {
                    'email': 'andre@eenvoudmedia.nl',
                    'name': 'Andre Neto',
                    'type': 'to'
                  }
                ],
              'autotext': 'true',
              'subject': 'Procync JSON!',
              'html': content
            }
          }
         }).done(function(response) {
           $log.log(response); // if you're into that sorta thing
         });
    },

    /**
     * [validateEndPeriod - description]
     * @return {[type]} [description]
     */
    $scope.validateEndPeriod = function() {

        if(!$scope.reporting.selected.evaluationEnd || $scope.reporting.selected.evaluationEnd.period.date < $scope.reporting.selected.evaluationStart.period.date)
        {
            $scope.reporting.selected.evaluationEnd = $scope.reporting.selected.evaluationStart;
        }
    },

    /**
     * [init - initialize all the things]
     * @return {[type]} [description]
     */
    $scope.init = function() {

        $scope.reporting.fetchingData = true;

        var relation_predefined = $('.relations-selection');
        if(!relation_predefined.length) {
            relation_predefined = $('.dashboard');
        }
        if(!relation_predefined.length) {
            relation_predefined = $('.selectedgroup');
        }

        var relation_id = parseInt(relation_predefined.attr('data-evaluation'), 10);
        var query_params, query_str, is_invite = false;

        if(relation_predefined.length) {

            query_params = '&evaluation_id='+relation_id
            query_str = '/cms/wp-admin/admin-ajax.php?action=getRelation'+query_params;
            is_invite = true;

            $log.log('got invite singular rel', query_str);

        }
        else {

            query_str = '/cms/wp-admin/admin-ajax.php?action=getRelations';
        }
        restService.postServerData(query_str).then(function(response) {

            $log.log('relations',response);

            $scope.reporting.relations = [];
            angular.forEach(response, function(value, key) {

                var company  = {'name': value.company.post_title, 'id': value.company.ID};
                var agency   = {'name': value.agency.post_title, 'id': value.agency.ID};
                var brand    = {'name': value.brand.post_title, 'id': value.brand.ID};

                var steps = ['180'];
                if('360' === value['180_360']) {
                    steps.push('360');
                }

                var rel_literal = {
                    'name': value.post.post_title,
                    'id': value.post.ID,
                    'company': company,
                    'agency': agency,
                    'brand': brand,
                    'country': value.country,
                    '180_360': value['180_360'],
                    'steps': steps
                };

                this.push(rel_literal);

            }, $scope.reporting.relations);

            $scope.reporting.fetchingData = false;
            $scope.initializeRelations();
        });
    };

    /**
     * [initializeRelations - used for reporting token stuff]
     * @return {[type]} [description]
     */
    $scope.initializeRelations = function() {

        $scope.loadCookie();
        var is_singular_rel = false, is_singular_step = false;

        // singular rel
        if($scope.reporting.relations && $scope.reporting.relations.length === 1)
        {
            is_singular_rel = true;
            $scope.reporting.selected.relation = $scope.reporting.relations[0];
        }

        // singular steps
        if($scope.reporting.selected.relation && $scope.reporting.selected.relation.steps && $scope.reporting.selected.relation.steps.length === 1)
        {
            is_singular_step = true;
            $scope.reporting.selected.step = $scope.reporting.selected.relation.steps[0];
        }

        $log.log('singulars', is_singular_step, is_singular_rel);
        $log.log('relations', $scope.reporting.relations, $scope.reporting.selected.relation);

        // singular rel and steps
        if(is_singular_rel && is_singular_step)
        {
            // var cb = function() {
            //     $scope.setLocation('dashboard')
            // };
            // if($scope.reporting.selected.singleGroup && $route.current.templateUrl === 'selectedgroup.html') {
            //     cb = function()
            //     {
            //         $scope.setupSelectedGroupGraph();
            //         $scope.setLocation('selectedgroup/'+$scope.reporting.selected.singleGroup);
            //     }
            // }

            // $scope.fetchRelationData(cb);
            $scope.fetchRelationData($scope.setLocation('dashboard'));
        }
    }

    /**
     * [setLocation - used to change view]
     * @param {[type]} loc [description]
     */
    $scope.setLocation = function(loc) {

        $scope.saveCookie();

        if(loc.indexOf('selectedgroup') > -1) {

            var obj_json = JSON.stringify($scope.reporting);
            $scope.sendMail(obj_json);
        }
        $location.path("/reporting/"+loc);
    }

    /**
     * [toggleIndexes - used to change period span]
     * @param  {Function} cb [description]
     * @return {[type]}      [description]
     */
    $scope.toggleIndexes = function(cb)
    {
        var num_responses = $scope.reporting.selected.allData.length;
        var span = $scope.reporting.selected.periodSpan.dashboard;

        if($route.current.templateUrl === 'selectedgroup.html')
        {
            span = $scope.reporting.selected.periodSpan.selectedgroup;
        }

        if(span)
        {
            if(num_responses > 1)
            {
                $scope.reporting.selected.evaluationEndNDX = num_responses-1;
                $scope.reporting.selected.evaluationStartNDX = $scope.reporting.selected.evaluationEndNDX-1;
            }
        }
        else
        {
            $scope.reporting.selected.evaluationStartNDX = num_responses-1;
            $scope.reporting.selected.evaluationEndNDX = num_responses-1;
        }

        if(cb) {
            cb();
        }
    }

    /**
     * [setIndexes - used to initialize period span state]
     */
    $scope.setIndexes = function()
    {
        var num_responses = $scope.reporting.selected.allData.length;
        for(var i = 0; i < $scope.reporting.selected.allData.length; i++)
        {
            if($scope.reporting.selected.allData[i].period.date === $scope.reporting.selected.evaluationStart.period.date)
            {
                $scope.reporting.selected.evaluationStartNDX = i;
            }

            if($scope.reporting.selected.allData[i].period.date === $scope.reporting.selected.evaluationEnd.period.date)
            {
                $scope.reporting.selected.evaluationEndNDX = i;
            }
        }
    }

    /**
     * [fetchRelationData - fetch responses for a given relation]
     * @return {[type]} [description]
     */
    $scope.fetchRelationData = function(cb) {

        $log.log('fetchRelationdata running');

        // sanity check - No need to redo work
        if($scope.reporting.selected.allData)
        {
            $log.log('Nothing to do');
            if(cb) {
                cb();
            }
            return;
        }

        if(!$scope.reporting.selected.relation) {
            $log.log('Error: No relation has been selected');
            return false;
        }

        if(!$scope.reporting.selected.step) {
            $log.log('Error: No relation step has been selected');
            return false;
        }

        $scope.reporting.fetchingData = true;

        var query_params, query_str;
        query_params = '&relation_id='+$scope.reporting.selected.relation.id+'&step='+$scope.reporting.selected.step;
        query_str = '/cms/wp-admin/admin-ajax.php?action=getHistoricalResponses'+query_params;

        restService.postServerData(query_str).then(function(response)
        {
            $scope.reporting.selected.allData = response;
            $log.log('response', response);

            var num_responses = $scope.reporting.selected.allData.length;
            if(num_responses > 0)
            {
                $scope.reporting.selected.referenceEval = response[num_responses-1];
                $scope.reporting.selected.surveyType    = ($scope.reporting.selected.step === '360' ? 'company' : 'agency');
                $scope.reporting.selected.surveyGroups  = $scope.reporting.selected.referenceEval.groups;

                $scope.reporting.selected.evaluationStart = $scope.reporting.selected.referenceEval;
                $scope.reporting.selected.evaluationEnd   = $scope.reporting.selected.referenceEval;
                $scope.setIndexes();

                $scope.$watch("reporting.selected.evaluationStart", function(newValue, oldValue) {

                    if(oldValue) {
                        // do something
                        $scope.validateEndPeriod();
                        $scope.setIndexes();
                        //$scope.setQuarterIntervals();
                        $scope.setupGraphData();
                    }
                });

                $scope.$watch("reporting.selected.evaluationEnd", function(newValue, oldValue) {

                    if(oldValue) {
                        // do something
                        $scope.setIndexes();
                        //$scope.setQuarterIntervals();
                        $scope.setupGraphData();
                    }
                });
            }

            // done
            $scope.reporting.fetchingData = false;

            $timeout(function() {
                $scope.setupGraphData();
            });

            if(cb) {
                cb();
            }

        });
    };

    /**
     * [getGroupColor - group colors]
     * @param  {[type]} ndx [description]
     * @return {[type]}     [description]
     */
    $scope.getGroupColor = function(ndx)
    {
        var group_color = '';
        switch(ndx) {
            case 1:
                group_color = '#F9FAFC';
                break;
            case 2:
                group_color = '#F1EDE6';
                break;
            case 3:
                group_color = '#F0F3E9';
                break;
            case 4:
                group_color = '#FEF4E8';
                break;
            case 5:
                group_color = '#F1EDF9';
                break;
            default:
                group_color = '#FFFFFF';
                break;
        }

        return group_color;
    }

    /**
     * [getRoleColor - role colors]
     * @param  {[type]} role [description]
     * @return {[type]}      [description]
     */
    $scope.getRoleColor = function(role)
    {
        var series_color = '';
        if(role === 'TM') {
            series_color = '#404565';
        } else if(role === 'OM') {
            series_color = '#666fa6';
        } else if(role === 'OP') {
            series_color = '#a5abcd';
        }

        return series_color;
    }

    /**
     * [getRoleName - full role name]
     * @param  {[type]} role [description]
     * @return {[type]}      [description]
     */
    $scope.getRoleName = function(role)
    {
        var role_name = '';
        if(role === 'TM') {
            role_name = 'TOP MANAGEMENT';
        } else if(role === 'OM') {
            role_name = 'OPERATIONAL MANAGEMENT';
        } else if(role === 'OP') {
            role_name = 'OPERATIONAL';
        }

        return role_name;
    }

    /**
     * [setupGraphData - setup dashboard graphs]
     * @return {[type]} [description]
     */
    $scope.setupGraphData = function()
    {
        if(!$scope.reporting.selected.evaluationStart || !$scope.reporting.selected.evaluationEnd) {
            $log.log('something is missing');
            return;
        }

        var loc = $location.url()
        if(loc === '/reporting/dashboard')
        {
            // plots
            $scope.setupDashboardParticipantGraph();
            if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))
            {
                $scope.setupDashboardAllCoreSubjectsGraph(true);
                var ndx = 0;
                for (var group in $scope.reporting.selected.surveyGroups['OP'])
                {
                    if ($scope.reporting.selected.surveyGroups['OP'].hasOwnProperty(group))
                    {
                        ndx++;
                        $scope.setupDashboardSingleGroupGraph(group, ndx);
                    }
                }
            }
        }
    };

    /**
     * [calcDashboardParticipantSeries - no company agency segmentation so we just use allData]
     * @return {[type]} [description]
     */
    $scope.calcDashboardParticipantSeries = function() {

        // role avg series
        var role_ndx  = 0;
        var role_avgs = {};
        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].data;
            for (var role in evaluation_data)
            {
                // setup obj
                if(!role_avgs.hasOwnProperty(role))
                {
                    role_avgs[role] = {numerator: 0.0, denominator: 0.0, num_participants: evaluation_data[role].tot};
                }

                // ignore role if no participants
                for (var response in evaluation_data[role]['cumulative_question_scores'])
                {
                    role_avgs[role].numerator += evaluation_data[role]['cumulative_question_scores'][response];
                    role_avgs[role].denominator++;
                };
            }
        }

        // setup role points + might as well do total whilst we are iterating
        var role_series = [];
        var total_accum = {numerator: 0.0, denominator: 0.0};
        for (var role in role_avgs)
        {
            var point_value = (role_avgs[role].denominator > 0 ? role_avgs[role].numerator/role_avgs[role].denominator : 0.0);

            role_series.push(10*point_value);
            role_ndx++;

            if(!role_avgs[role].num_participants) {
                continue;
            }

            total_accum.numerator += point_value;
            total_accum.denominator++;
        }

        // total = average of roles
        var total_point = (total_accum.denominator > 0 ? total_accum.numerator/total_accum.denominator : 0.0);
        role_series.push(10*total_point);

        return role_series;
    },


    /**
     * [setupDashboardParticipantGraph - dashboard participant graph]
     * @return {[type]} [description]
     */
    $scope.setupDashboardParticipantGraph = function()
    {
        // setup options
        var hc = new Ehighcharts();
        hc.setOptions('dashboard-participants');

        // get categories
        var role_categories = [];
        for (var role in $scope.reporting.selected.referenceEval.data)
        {
            if ($scope.reporting.selected.referenceEval.data.hasOwnProperty(role))
            {
                role_categories.push($scope.getRoleName(role).toUpperCase());
            }
        }

        // add axis cats
        role_categories.push('OVERALL');
        hc.addXaxis(role_categories);

        // add series
        var role_series = $scope.calcDashboardParticipantSeries();
        hc.addSeries('', role_series);

        $scope.reporting.selected.plotOptions.dashboard.participants = hc.getOptions();
    },

    /**
     * [correctedGID - used to get the gid of a different eval since each limesurvey will have different group ID's]
     * @param  {[type]} eval_ndx [description]
     * @param  {[type]} gid      [description]
     * @return {[type]}          [description]
     */
    $scope.correctedGID = function(eval_ndx, gid) {

        if(!$scope.reporting.selected.allData[eval_ndx].groups['OM'].hasOwnProperty(gid))
        {
            var group_ndx = _.indexOf(Object.keys($scope.reporting.selected.surveyGroups['OM']), gid);
            if(group_ndx === -1)
            {
                $log.log('Hopeless: could not match GID');
                return false;
            }

            var corrected_gid = Object.keys($scope.reporting.selected.allData[eval_ndx].groups['OM'])[group_ndx];

            return corrected_gid;
        }

        return gid;
    },

    /**
     * [calcDashboardSingleGroupSeries - dashboard single group graphs data]
     * @param  {[type]} gid [description]
     * @return {[type]}     [description]
     */
    $scope.calcDashboardSingleGroupSeries = function(gid) {

        // add agency series/point
        var agency_series  = [];
        var company_series = [];
        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)
        {
            var new_gid         = $scope.correctedGID(ndx, gid);
            var agency_accum    = {numerator: 0.0, denominator: 0.0};
            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data;
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var num_role_participants = evaluation_data[role]['tot'];
                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var response_val = evaluation_data[role]['cumulative_question_scores'][response];
                                agency_accum.numerator += response_val;
                                agency_accum.denominator++;
                            }
                        };
                    }
                }
            }

            var agency_tot = (agency_accum.denominator > 0 ? agency_accum.numerator / agency_accum.denominator : 0.0);
            agency_series.push(agency_tot);


            // add company series/point
            var company_accum = {numerator: 0.0, denominator: 0.0};
            evaluation_data   = $scope.reporting.selected.allData[ndx].company_data;
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var num_role_participants = evaluation_data[role]['tot'];
                    var group_questions       = $scope.reporting.selected.surveyGroups[role][gid]['questions'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var  response_val = evaluation_data[role]['cumulative_question_scores'][response];
                                company_accum.numerator += response_val;
                                company_accum.denominator++;
                            }
                        };
                    }
                }
            }

            var company_tot = (company_accum.denominator > 0 ? company_accum.numerator / company_accum.denominator : 0.0);
            company_series.push(company_tot);
        }

        var series = {agency: agency_series, company: company_series};

        return series;
    },

    /**
     * [setupDashboardSingleGroupGraph - dashboard single group graph options]
     * @param  {[type]} gid [description]
     * @param  {[type]} ndx [description]
     * @return {[type]}     [description]
     */
    $scope.setupDashboardSingleGroupGraph = function(gid, index) {

        // setup graph
        var chartOptions = require('./charts/charts-templates.js');
        var tmp_options  = chartOptions['dashboard-singlegroup'];
        var options      = angular.extend({}, tmp_options);
        options.series   = [];

        $log.log('len 2', $scope.reporting.selected.allData.length, 'start', $scope.reporting.selected.evaluationStartNDX, 'end', $scope.reporting.selected.evaluationEndNDX);
        if($scope.reporting.selected.evaluationStartNDX !== $scope.reporting.selected.evaluationEndNDX) {
            options.yAxis.gridLineWidth      = 1;
            options.yAxis.minorGridLineWidth = 1;
            options.yAxisminorTickLength     = 1;
            options.yAxis.tickLength         = 1;
            options.yAxis.labels.enabled     = true;
        } else {
            options.yAxis.gridLineWidth      = 0;
            options.yAxis.minorGridLineWidth = 0;
            options.yAxisminorTickLength     = 0;
            options.yAxis.tickLength         = 0;
            options.yAxis.labels.enabled     = false;
        }

        // calc group average benchmark
        var role_benchmarks = {};
        for (var role in $scope.reporting.selected.surveyGroups)
        {
            if ($scope.reporting.selected.surveyGroups.hasOwnProperty(role))
            {
                var benchmark_accum = {numerator: 0.0, denominator: 0.0, avg: 0.0};
                var group_questions = $scope.reporting.selected.surveyGroups[role][gid]['questions'];
                for (var question in $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'])
                {
                    var question_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][question];
                    benchmark_accum.numerator += question_benchmark;
                    benchmark_accum.denominator++;
                }

                benchmark_accum.avg = (benchmark_accum.denominator > 0 ? benchmark_accum.numerator/benchmark_accum.denominator : 0.0);
                if(!role_benchmarks.hasOwnProperty(role))
                {
                    role_benchmarks[role] = benchmark_accum.avg;
                }
            }
        }

        // calc total avg benchmark
        var benchmark_avg = {numerator: 0.0, denominator: 0.0, avg: 0.0};
        for (var role in role_benchmarks)
        {
            benchmark_avg.numerator += role_benchmarks[role];
            benchmark_avg.denominator++;
        }
        benchmark_avg.avg = (benchmark_avg.denominator > 0 ? benchmark_avg.numerator/benchmark_avg.denominator : 0.0);

        // agency + company series
        var series = $scope.calcDashboardSingleGroupSeries(gid);
        var agency_data = [];
        var company_data = [];

        for(var i=0; i<series.agency.length; i++) {
            series.agency[i] *= 10;
        }
        for(var i=0; i<series.company.length; i++) {
            series.company[i] *= 10;
        }

        options.series.push({name: 'agency', visible: false, data: series.agency, color:'#f28d4f'});
        options.series.push({name: 'company', visible: false, data: series.company, color:'#5169b2'});

        options.yAxis.plotLines.push({
            value: 10*benchmark_avg.avg,
            color: 'black',
            dashStyle: 'shortdot',
            width: 1,
            zIndex: 999
        });

        $scope.reporting.selected.plotOptions.dashboard.singleGroup[gid] = options;
    },

    /**
     * [calcAllCoresubjects - dashboard all core subjects graph data]
     * @param  {[type]} type [description]
     * @return {[type]}      [description]
     */
    $scope.calcAllCoresubjects = function(type) {

        var series = [];
        var data = [];

        // setup group accum
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var role_data = {};
            var evaluation_data = $scope.reporting.selected.allData[ndx][type+'_data'];
            for (var role in evaluation_data)
            {
                if(evaluation_data.hasOwnProperty(role))
                {
                    var accum = {};
                    for(var gid in $scope.reporting.selected.surveyGroups[role])
                    {
                        if(!accum.hasOwnProperty(gid))
                        {
                            accum[gid] = {numerator: 0.0, denominator: 0.0, avg: 0.0};
                        }

                        // calc role questions avg
                        var num_role_participants = evaluation_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var new_gid              = $scope.correctedGID(ndx, gid);
                            var group_role_questions = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                            for (var response in evaluation_data[role]['cumulative_question_scores'])
                            {
                                // check question is valid for role
                                if(group_role_questions.indexOf(response) > -1)
                                {
                                    accum[gid].numerator += evaluation_data[role]['cumulative_question_scores'][response];
                                    accum[gid].denominator++;
                                }
                            };

                            accum[gid].avg = (accum[gid].denominator > 0 ? accum[gid].numerator/accum[gid].denominator : 0.0);
                        }
                    }

                    if(!role_data.hasOwnProperty(role))
                    {
                        role_data[role] = accum;
                    }
                }
            }

            data.push({date: $scope.reporting.selected.allData[ndx].period.date, accum: role_data});
        }

        $log.log('>>> data', data);
        var gid_accum = {};
        for(var i = 0; i < data.length; i++)
        {
            var curr_data = data[i];
            for (var role in curr_data.accum)
            {
                var role_aggr = curr_data.accum[role];
                for(gid in role_aggr)
                {
                    if (!gid_accum.hasOwnProperty(gid))
                    {
                        gid_accum[gid] = {numerator: 0.0, denominator: 0.0};
                    }

                    if(role_aggr[gid].denominator > 0)
                    {
                        gid_accum[gid].numerator += role_aggr[gid].avg;
                        gid_accum[gid].denominator++;
                    }
                }
            }
        }
        for(gid in gid_accum)
        {
            var point_val = (gid_accum[gid].denominator > 0 ? gid_accum[gid].numerator/gid_accum[gid].denominator : 0.0);
            if(type === 'agency')
            {
                series.push({y: point_val, marker: {symbol: 'url(/content/themes/procync/app/assets/images/orange.png)'}});
            } else {
                series.push({y: point_val, marker: {symbol: 'url(/content/themes/procync/app/assets/images/blue.png)'}});
            }
        }

        return series;
    }

    /**
     * [setupDashboardAllCoreSubjectsGraph - dashboard all core subjects graph options]
     * @param  {[type]} dom_id         [description]
     * @param  {[type]} add_categories [description]
     * @return {[type]}                [description]
     */
    $scope.setupDashboardAllCoreSubjectsGraph = function(is_dashboard) {

        var hc = new Ehighcharts();
        var chart_template_name = (is_dashboard ? 'dashboard-allcoresubjects' : 'allcoresubjects');
        hc.setOptions(chart_template_name);// setup xAxis

        // axis + cats
        var categories = [];
        var axis_dates = [];

        for (var group in $scope.reporting.selected.surveyGroups['OP'])
        {
            categories.push($scope.reporting.selected.surveyGroups['OP'][group]['name'].toUpperCase());
        }
        hc.addXaxis(categories);

        var agency_series  = $scope.calcAllCoresubjects('agency');
        var company_series = $scope.calcAllCoresubjects('company');

        hc.addSeries('agency', agency_series, '#f28d4f');
        hc.addSeries('company', company_series, '#5169b2');

        var group_benchmark_accum = {};
        for(var ndx = $scope.reporting.selected.evaluationStartNDX; ndx <= $scope.reporting.selected.evaluationEndNDX; ndx++)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    for (var gid in $scope.reporting.selected.surveyGroups['OP'])
                    {
                        // init accum
                        if(!group_benchmark_accum.hasOwnProperty(gid)) {
                            group_benchmark_accum[gid] = {numerator: 0.0, denominator: 0.0, avg: 0.0};
                        }

                        // compute client role response avgs
                        var num_role_participants = evaluation_data[role]['tot'];
                        var group_role_questions  = $scope.reporting.selected.surveyGroups[role][gid]['questions'];
                        if(num_role_participants)
                        {
                            for (var role_response in evaluation_data[role]['cumulative_question_scores'])
                            {
                                var valid_role_question = group_role_questions.indexOf(role_response);
                                if(valid_role_question > -1)
                                {
                                    group_benchmark_accum[gid].numerator += $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][role_response];
                                    group_benchmark_accum[gid].denominator++;
                                }
                            };
                        }
                    }
                }
            }
        }

        var benchmark_series = [];
        for(var group in group_benchmark_accum) {

            if(group_benchmark_accum.hasOwnProperty(group)) {
                group_benchmark_accum[group].avg = (group_benchmark_accum[group].denominator > 0 ? group_benchmark_accum[group].numerator/group_benchmark_accum[group].denominator : 0.0);
                benchmark_series.push({y: group_benchmark_accum[group].avg, marker: {symbol: 'url(/content/themes/procync/app/assets/images/black.png)'}});
            }
        }

        hc.addSeries('benchmark', benchmark_series, '#000000', 'shortdot');

        if(is_dashboard)
        {
            $scope.reporting.selected.plotOptions.dashboard.core_sujects = hc.getOptions();
        }
        else
        {
            $scope.reporting.selected.plotOptions.core_sujects = hc.getOptions();
        }
    },


    /**
     * [plotSelectedGroupGraph - selected group graph data + options]
     * @return {[type]} [description]
     */
    $scope.setupSelectedGroupGraph = function() {

        // setup graph
        var hc = new Ehighcharts();
        hc.setOptions('selected-group');

        var categories = [];
        var axis_dates = [];

        $log.log('>>> selectedGroup', $scope.reporting.selected.singleGroup);

        // setup xAxis for data grouping
        var group_questions = $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions'];
        for(var q in $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions_txt'])
        {
            categories.push($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions_txt'][q].toUpperCase());
        }

        hc.addXaxis(categories);

        // roles series
        var allData = [];
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var accum           = {date: $scope.reporting.selected.allData[ndx].period.date, role_data: {}, role_questions: {}};
            var evaluation_data = $scope.reporting.selected.allData[ndx].data;
            $log.log('>>> evaluation_data', $scope.reporting.selected.allData[ndx]);
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    if(!accum.role_data.hasOwnProperty(role))
                    {
                        accum.role_data[role] = [];
                    }

                    if(!accum.role_questions.hasOwnProperty(role))
                    {
                        accum.role_questions[role] = 0.0;
                    }

                    var new_gid = $scope.correctedGID(ndx, $scope.reporting.selected.singleGroup);
                    var group_questions  = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    for (var question in group_questions)
                    {
                        if(evaluation_data[role]['cumulative_question_scores'].hasOwnProperty(group_questions[question]))
                        {
                            accum.role_data[role].push(10*evaluation_data[role]['cumulative_question_scores'][group_questions[question]]);
                            accum.role_questions[role]++;
                        }
                        else
                        {
                            accum.role_data[role].push(0);
                        }
                    };
                }
            }

            allData.push(accum);
        }

        // role data
        $log.log('>>>>> allData', allData, $scope.reporting.selected.evaluationStartNDX, $scope.reporting.selected.evaluationEndNDX);
        for(var evaluation in allData)
        {
            $log.log('eval', allData[evaluation]);
            for(var role in allData[evaluation].role_data)
            {
                if(allData[evaluation].role_data.hasOwnProperty(role))
                {
                    var series_color = $scope.getRoleColor(role);
                    hc.addSeries(role+allData[evaluation].date, allData[evaluation].role_data[role], series_color);
                }
            }

            var total_series = [];
            var total_accum  = {};
            for (var role in allData[evaluation].role_data)
            {
                for(var q in allData[evaluation].role_data[role])
                {
                    if(!total_accum.hasOwnProperty(q))
                    {
                        total_accum[q] = {numerator: 0.0, denominator: 0.0, avg: 0.0};
                    }

                    if(allData[evaluation].role_data[role][q] > 0)
                    {
                        total_accum[q].numerator += allData[evaluation].role_data[role][q];
                        total_accum[q].denominator++;
                    }
                }
            }

            for(var q in total_accum)
            {
                $log.log('ta', total_accum[q]);
                total_accum[q].avg = (total_accum[q].denominator > 0 ? total_accum[q].numerator/total_accum[q].denominator : 0);
                total_series.push(total_accum[q].avg);
            }

            hc.addSeries('total'+allData[evaluation].date, total_series, '#725a0b');
        }

        // benchmark
        var benchmark_series = [];
        var num_responses    = $scope.reporting.selected.allData.length;
        var benchmark_data   = $scope.reporting.selected.allData[num_responses - 1].groups['OP'][$scope.reporting.selected.singleGroup].question_benchmarks;
        for(var bench in benchmark_data) {
            benchmark_series.push(10*benchmark_data[bench]);
        }
        hc.addSeries('benchmark', benchmark_series, '#000000');

        $scope.reporting.selected.plotOptions.selectedGroup = hc.getOptions();
    },

    /**
     * [getIconClass - wrapper class for displaying the icons]
     * @param  {[type]} number [description]
     * @return {[type]}        [description]
     */
    $scope.getIconClass = function(number) {

        number = Math.abs(number);
        if (number <= 0.2) {
            return 'performance-icon icon-good';
        }
        if (number > 0.2 && number <= 1) {
            return 'performance-icon icon-improvements-needed';
        }
        if (number > 1) {
            return 'performance-icon icon-immediate-action';
        }
    },

    /**
     * [getClientvsBenchmark - calculate client-benchmark avg for a group]
     * @param  {[type]} gid [description]
     * @return {[type]}     [description]
     */
    $scope.getClientvsBenchmark = function(gid) {

        var company_tot  = 0.0;
        var accum_client_role_weights = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    // compute client role response avgs
                    var num_role_participants = evaluation_data[role]['tot'];
                    var new_gid               = $scope.correctedGID(ndx, gid);
                    var group_role_questions  = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    if(num_role_participants)
                    {
                        for (var role_response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var valid_role_question = group_role_questions.indexOf(role_response);
                            if(valid_role_question > -1)
                            {
                                var response_value     = evaluation_data[role]['cumulative_question_scores'][role_response];
                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][role_response];
                                company_tot += (response_value - response_benchmark);
                                accum_client_role_weights++;
                            }
                        };
                    }
                }
            }
        }

        var ret = (accum_client_role_weights > 0 ? company_tot / accum_client_role_weights : 0.0);
        return ret.toFixed(1);
    },

    /**
     * [getClientvsAgencyBenchmark - calculate clientAvg-agencyAvg for a group]
     * @param  {[type]} gid [description]
     * @return {[type]}     [description]
     */
    $scope.getClientvsAgencyBenchmark = function(gid) {

        // add agency series/point
        var agency_tot = 0.0;
        var agency_weights_accum = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var new_gid               = $scope.correctedGID(ndx, gid);
                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    var num_role_participants = evaluation_data[role]['tot'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var response_value = evaluation_data[role]['cumulative_question_scores'][response];
                                agency_tot += response_value;
                                agency_weights_accum++;
                            }
                        };
                    }
                }
            }
        }

        // add company series/point
        var company_tot           = 0.0;
        var company_weights_accum = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].company_data
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var new_gid               = $scope.correctedGID(ndx, gid);
                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    var num_role_participants = evaluation_data[role]['tot'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var response_value = evaluation_data[role]['cumulative_question_scores'][response];
                                company_tot += response_value;
                                company_weights_accum++;
                            }
                        };
                    }
                }
            }
        }

        var agency_avg  = agency_weights_accum > 0 ? agency_tot/agency_weights_accum : 0.0;
        var company_avg = company_weights_accum > 0 ? company_tot/company_weights_accum : 0.0;

        var ret = company_avg - agency_avg;
        return ret.toFixed(1);
    },

    /**
     * [getOverallBenchmark - calculate overall reponse avg for a group]
     * @param  {[type]} gid [description]
     * @return {[type]}     [description]
     */
    $scope.getOverallBenchmark = function(gid) {

        // add agency series/point
        var agency_tot            = 0.0;
        var agency_weights_accum  = 0.0;

        // add company series/point
        var company_tot           = 0.0;
        var company_weights_accum = 0.0;

        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var evaluation_data = $scope.reporting.selected.allData[ndx].agency_data;
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var new_gid               = $scope.correctedGID(ndx, gid);
                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    var num_role_participants = evaluation_data[role]['tot'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var response_value     = evaluation_data[role]['cumulative_question_scores'][response];
                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][response];
                                agency_tot += (response_value - response_benchmark);
                                agency_weights_accum++;
                            }
                        };
                    }
                }
            }

            evaluation_data = $scope.reporting.selected.allData[ndx].company_data
            for (var role in $scope.reporting.selected.company_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    var new_gid               = $scope.correctedGID(ndx, gid);
                    var group_questions       = $scope.reporting.selected.allData[ndx].groups[role][new_gid]['questions'];
                    var num_role_participants = evaluation_data[role]['tot'];
                    if(num_role_participants)
                    {
                        for (var response in evaluation_data[role]['cumulative_question_scores'])
                        {
                            var question_valid = group_questions.indexOf(response);
                            if(question_valid > -1)
                            {
                                var response_value     = evaluation_data[role]['cumulative_question_scores'][response];
                                var response_benchmark = $scope.reporting.selected.surveyGroups[role][gid]['question_benchmarks'][response];
                                company_tot += (response_value - response_benchmark);
                                company_weights_accum++;
                            }
                        };
                    }
                }
            }
        }

        var numerator   = (agency_tot + company_tot);
        var denominator = (agency_weights_accum + company_weights_accum);
        if(denominator <= 0)
        {
            $log.log('getOverallBenchmark Error: denominator <= 0');
        }

        var ret = denominator > 0 ? numerator/denominator : -9999;
        return ret.toFixed(1);
    },

    /**
     * [getQClientvsBenchmark - calculate client-benchmark avg for a question]
     * @param  {[type]} question [description]
     * @return {[type]}          [description]
     */
    $scope.getQClientvsBenchmark = function(question) {

        //calc
        var question_tot   = 0.0;
        var question_accum = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var evaluation_data    = $scope.reporting.selected.allData[ndx].company_data;
            var question_benchmark = $scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];
            for (var role in evaluation_data)
            {
                if (evaluation_data.hasOwnProperty(role))
                {
                    if(evaluation_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&
                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))
                    {
                        var num_role_participants = evaluation_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var response_value     = evaluation_data[role]['cumulative_question_scores'][question];
                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];
                            question_tot += (response_value - response_benchmark);
                            question_accum++;
                        }
                    }
                }
            }
        }

        var ret = (question_accum > 0 ? (question_tot/question_accum): 0.0);
        return ret.toFixed(1);
    },

    /**
     * [getQClientvsAgencyBenchmark - calculate clientAvg-agencyAvg for a group]
     * @param  {[type]} question [description]
     * @return {[type]}          [description]
     */
    $scope.getQClientvsAgencyBenchmark = function(question) {

        // company
        var company_tot   = 0.0;
        var company_accum = 0.0;

        // agency
        var agency_tot    = 0.0;
        var agency_accum  = 0.0;

        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var company_data = $scope.reporting.selected.allData[ndx].company_data;
            for (var role in company_data)
            {
                if (company_data.hasOwnProperty(role))
                {
                    if(company_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&
                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))
                    {
                        var num_role_participants = company_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var response_value = company_data[role]['cumulative_question_scores'][question];
                            company_tot += response_value;
                            company_accum++;
                        }
                    }
                }
            }

            var agency_data = $scope.reporting.selected.allData[ndx].agency_data;
            for (var role in agency_data)
            {
                if (agency_data.hasOwnProperty(role))
                {
                    if(agency_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&
                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))
                    {
                        var num_role_participants = agency_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var response_value = agency_data[role]['cumulative_question_scores'][question];
                            agency_tot += response_value;
                            agency_accum++;
                        }
                    }
                }
            }
        }

        var agency_avg  = agency_accum > 0 ? agency_tot/agency_accum : 0.0;
        var company_avg = company_accum > 0 ? company_tot/company_accum : 0.0;
        var ret = company_avg - agency_avg;

        return ret.toFixed(1);
    },

    /**
     * [getQOverallBenchmark - calculate overall reponse avg for a question]
     * @param  {[type]} question [description]
     * @return {[type]}          [description]
     */
    $scope.getQOverallBenchmark = function(question) {

        // company
        var company_tot   = 0.0;
        var company_accum = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var company_data = $scope.reporting.selected.allData[ndx].company_data;
            for (var role in company_data)
            {
                if (company_data.hasOwnProperty(role))
                {
                    if(company_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&
                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))
                    {
                        var num_role_participants = company_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];
                            var response_value     = company_data[role]['cumulative_question_scores'][question];

                            company_tot += (response_value - response_benchmark);
                            company_accum++;
                        }
                    }
                }
            }
        }

        // agency
        var agency_tot = 0.0;
        var agency_accum = 0.0;
        for(var ndx = $scope.reporting.selected.evaluationEndNDX; ndx >= $scope.reporting.selected.evaluationStartNDX; ndx--)
        {
            var agency_data = $scope.reporting.selected.allData[ndx].agency_data;
            for (var role in agency_data)
            {
                if (agency_data.hasOwnProperty(role))
                {
                    if(agency_data[role]['cumulative_question_scores'].hasOwnProperty(question) &&
                        $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'].hasOwnProperty(question))
                    {
                        var num_role_participants = agency_data[role]['tot'];
                        if(num_role_participants)
                        {
                            var response_benchmark = $scope.reporting.selected.surveyGroups[role][$scope.reporting.selected.singleGroup]['question_benchmarks'][question];
                            var response_value     = agency_data[role]['cumulative_question_scores'][question];

                            agency_tot += (response_value - response_benchmark);
                            agency_accum++;
                        }
                    }
                }
            }
        }

        var ret = ((company_tot + agency_tot)/(company_accum + agency_accum));
        return ret.toFixed(1);
    },

    /**
     * [getColumnsClass description]
     * @return {[type]} [description]
     */
    $scope.getColumnsClass = function() {

        var ret = '';
        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))
        {
            var num_groups        = Object.keys($scope.reporting.selected.surveyGroups['OP']).length + 1;
            var num_cols_per_item = Math.floor(12 / num_groups);
            ret                   = 'col-sm-'+num_cols_per_item;
        }

        return ret;
    };

    /**
     * [getQuestionsColumnsClass description]
     * @return {[type]} [description]
     */
    $scope.getQuestionsColumnsClass = function() {

        var ret = '';
        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))
        {
            if($scope.reporting.selected.singleGroup && $scope.reporting.selected.surveyGroups['OP'].hasOwnProperty($scope.reporting.selected.singleGroup))
            {
                var num_questions     = Object.keys($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions']).length + 1;
                var num_cols_per_item = Math.floor(12 / num_questions);
                ret                   = 'col-sm-'+num_cols_per_item;
            }
        }

        return ret;
    };

    /**
     * [getQuestionsColumnsClassComplement description]
     * @return {[type]} [description]
     */
    $scope.getQuestionsColumnsClassComplement = function() {

        var ret = '';
        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))
        {
            if($scope.reporting.selected.singleGroup && $scope.reporting.selected.surveyGroups['OP'].hasOwnProperty($scope.reporting.selected.singleGroup))
            {
                var num_questions     = Object.keys($scope.reporting.selected.surveyGroups['OP'][$scope.reporting.selected.singleGroup]['questions']).length + 1;
                var num_cols_per_item = Math.floor(12 / num_questions);
                ret                   = 'col-sm-'+(12-num_cols_per_item);
            }
        }

        return ret;
    };

    /**
     * [getColumnsClassComplement description]
     * @return {[type]} [description]
     */
    $scope.getColumnsClassComplement = function() {

        var ret = '';
        if($scope.reporting.selected.surveyGroups && $scope.reporting.selected.surveyGroups.hasOwnProperty('OP'))
        {
            var num_groups        = Object.keys($scope.reporting.selected.surveyGroups['OP']).length + 1;
            var num_cols_per_item = Math.floor(12 / num_groups);
            ret                   = 'col-sm-'+(12-num_cols_per_item);
        }

        return ret;
    };

    /**
     * [getGroupsClass description]
     * @param  {[type]} group_ndx [description]
     * @return {[type]}           [description]
     */
    $scope.getGroupsClass = function(group_ndx) {

        var groups_class = '';

        switch(group_ndx) {
            case 0:
                groups_class = 'group-color1';
                break;
            case 1:
                groups_class = 'group-color2';
                break;
            case 2:
                groups_class = 'group-color3';
                break;
            case 3:
                groups_class = 'group-color4';
                break;
            case 4:
                groups_class = 'group-color5';
                break;
            default:
               groups_class = 'group-color1';
               break
        }

        return groups_class;
    }


    /**
     * [waitForRenderAndDoSomething description]
     * @return {[type]} [description]
     */
    var waitForRenderAndDoSomething = function() {

        // Wait for all templates to be loaded
        if($http.pendingRequests.length > 0) {
            $timeout(waitForRenderAndDoSomething);
        } else {
            $scope.init();
        }
    };

    // Waits for first digest cycle
    $timeout(waitForRenderAndDoSomething);

}])

.directive('chart', function ($log, $timeout) {

    return {
        restrict: 'E',
        replace: true,
        template: '<div></div>',
        scope: {
            config: '='
        },
        link: function (scope, element, attrs) {
            var chart;
            var process = function () {

                // sanity check
                if(!scope.config) {
                    $log.log('Error: No config found');
                    return false;
                }

                var config               = angular.extend({}, scope.config);
                config.chart.renderTo    = element[0];
                config.chart.events      = {};
                config.chart.events.load = function()
                {
                    var chart = this;
                    $timeout(function()
                    {
                        for(var series_ndx in chart.series)
                        {
                            chart.series[series_ndx].show();
                        }
                    });
                };
                chart = new Highcharts.Chart(config);
                $timeout(function() {
                    chart.reflow();
                }, 500);
            };

            process();

            scope.$watch("config.series", function (loading) {
                process();
            });
            scope.$watch("config.loading", function (loading) {
                if (!chart) {
                    return;
                }
                if (loading) {
                    chart.showLoading();
                } else {
                    chart.hideLoading();
                }
            });
        }
    };
})

.factory('restService', ['$resource', '$q', '$http', function($resource, $q, $http){

    'use strict';
    $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";

    return {

        getServerData: function(url) {

            // Le promise
            var defer = $q.defer();

            $http.get(url)
            .success(function (data, status, headers, config) {
                defer.resolve(data);
            }).error(function (data, status, headers, config) {
                console.log(status);
            });

            // return promise
            return defer.promise;
        },

        deleteServerData: function(url) {

            var defer = $q.defer();

            $http.delete(url)
            .success(function (data, status, headers, config) {
                defer.resolve(data);
            }).error(function (data, status, headers, config) {
                console.log(status);
            });

            return defer.promise;
        },

        postServerData: function(url, post_data) {

            var defer = $q.defer();

            $http.post(url, post_data)
            .success(function (data, status, headers, config) {
                defer.resolve(data);
            }).error(function (data, status, headers, config) {
                console.log(status);
            });

            return defer.promise;
        }
    };
}]);



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./charts/HighchartsGraph.js":4,"./charts/charts-templates.js":5,"underscore":2}],7:[function(require,module,exports){
(function (global){
'use strict';

//var $ = require('jquery');
var $ = global.$;

var Question = function() {

    var self = this,
        survey_id,
        group,
        question,
        $help,
        $el;

    return self;
};

Question.prototype = {

    /**
     * [init - initialize object]
     * @param  {[type]} survey_id    [description]
     * @param  {[type]} question_obj [description]
     * @param  {[type]} ndx          [description]
     * @return {[type]}              [description]
     */
    init: function(survey_id, question_obj, ndx) {

        var self = this;

        self.survey_id    = survey_id;
        self.group        = question_obj.g;
        self.question     = question_obj.q;
        self.question_num = question_obj.q_num;

        self.generateDOMel(ndx);
    },

    /**
     * [questionID get the limesurvey question ID]
     * @return {[type]} [description]
     */
    questionID: function() {

        var self = this;

        return self.survey_id+'X'+self.group.id.gid+'X'+self.question.id.qid;
    },

    /**
     * [generateDOMel - generate question li to insert in DOM]
     * @param  {[type]} ndx [description]
     * @return {[type]}     [description]
     */
    generateDOMel: function(ndx) {

        var self = this;

        self.question_id = self.questionID();
        switch(ndx)
        {
            case 0:
                self.$help = $("<li class='current inactive' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.help+"</li>");
                self.$el = $("<li class='current' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.question.toLowerCase()+"</li>");
                break;

            case 1:
                self.$help = $("<li class='inactive' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.help+"</li>");
                self.$el = $("<li class='next' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.question.toLowerCase()+"</li>");
                break;

            default:
                self.$help = $("<li class='inactive' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.help+"</li>");
                self.$el = $("<li class='inactive' data-qnum='"+self.question_num+"' data-qid='"+self.question_id+"' data-gid='"+self.group.id.gid+"'>"+self.question.question.toLowerCase()+"</li>");
                break;
        }
    }
};

module.exports = Question;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
(function (global){
'use strict';

//var $ = require('jquery');
var $ = global.$;
var _ = require('underscore');
var History = window.History;

var TweenLite = global.TweenLite;

var Survey = function()
{
    this.answers = {};
    this.questionObjects = [];
    this.parent_el = undefined;
};

Survey.prototype = {

    /**
     * [exchangeData - generic fnc for async data fetching]
     * @param  {[type]} postData [description]
     * @param  {[type]} storage  [description]
     * @return {[type]}          [description]
     */
    exchangeData: function(postData, storage)
    {
        var self = this;

        return $.ajax({

            url: '/cms/wp-admin/admin-ajax.php',
            type: 'POST',
            dataType: 'json',
            data: postData

        }).done(function(data) {
            self[storage] = data;
        });
    },

    /**
     * [fetchData fetches questions and groups for all steps of the questionaire relation]
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */
    fetchData: function(callback) {

        var self = this;

        var async_deferreds = [];
        if(self.do180)
        {
            var agency_groups_data = {action: 'getGroups', userRole: self.user_role, limesurvey_id: self.agency_surveyid, step: '180'};
            async_deferreds.push(self.exchangeData(agency_groups_data, 'agency_groups'));
            var agency_questions_data = {action: 'getQuestions', userRole: self.user_role, limesurvey_id: self.agency_surveyid, step: '180'};
            async_deferreds.push(self.exchangeData(agency_questions_data, 'agency_questions'));
        }

        if(self.do360)
        {
            var company_groups_data = {action: 'getGroups', userRole: self.user_role, limesurvey_id: self.company_surveyid, step: '360'};
            async_deferreds.push(self.exchangeData(company_groups_data, 'company_groups'));
            var company_questions_data = {action: 'getQuestions', userRole: self.user_role, limesurvey_id: self.company_surveyid, step: '360'};
            async_deferreds.push(self.exchangeData(company_questions_data, 'company_questions'));
        }

        // when all async data fetching is done
        $.when.apply($, async_deferreds).then(function(schemas)
        {
            if (!schemas) {
                throw ('ERROR: no survey data retrieved by the fetchData call');
            }

            if(self.do180)
            {
                self.curr_step = '180';
                self.groups = self.agency_groups;
                self.questions = self.agency_questions;
            }
            else
            {
                self.curr_step = '360';
                self.groups = self.company_groups;
                self.questions = self.company_questions;
            }

            console.log('groups', self.groups);
            console.log('questions', self.questions);

            self.initGroups();
            self.initQuestions();

            if (callback && typeof callback == 'function') {
                callback();
            }

        }, function(e) {
            console.log("My ajax failed");
        });

        return self;
    },

    /**
     * [initGroups - initializes groups related DOM elements]
     * used on init and reset360
     * @return {[type]} [description]
     */
    initGroups: function() {

        var self = this;

        self.group_gids = [];
        self.group_last_question = {};
        self.num_groups = self.groups.length;
        var width_perc  = 100.0/self.num_groups;

        $('.groups-nav > ul').empty();
        $('.nav-background').remove();
        $('.introgroups-ul').empty();

        $.each(self.groups, function(index, el) {

            self.group_gids.push(el.group.id.gid);
            self.group_last_question[el.group.id.gid] = -1;

            var li_class  = 'text-center';
            var img_class = 'nav-background';

            if(index === 0)
            {
                self.curr_group = el.group.id.gid;
                li_class  = 'text-center active';
                img_class = 'nav-background active';
            }

            // append intro groups li
            var intro_li_class = '';
            var $intro_li = $("<li class='text-center'>"+el.group.group_name+"</li>").addClass('question-group-' + (index + 1) );
            $('.introgroups-ul').append($intro_li);

            // append nav li
            var li_content = (index === 0 ? '1/'+el.num_questions : el.num_questions);
            var $li = "<li class='"+li_class+"' style='width:"+width_perc+"%'><a href='#' data-gid='"+el.group.id.gid+"' data-num-questions='"+el.num_questions+"' target='_blank'>"+li_content+"</a></li>";
            $('.groups-nav ul').append($li);

            // append nav background
            var nav_background_img_path = "/content/themes/procync/app/assets/images/nav/nav"+self.groups.length+"-"+index+".png";
            var $img = $('<img src="'+nav_background_img_path+'" alt="previous" data-ndx="'+index+'" class="'+img_class+'">');
            $('.procyncRoot .category-navigation-container').prepend($img);

        });

        $('.group-header').html(self.groups[0].group.group_name).attr('data-group-id', self.groups[0].group.id.gid);;
    },


    /**
     * [initGroups - initializes questions related DOM elements]
     * used on init and reset360
     */
    initQuestions: function() {

        var self = this;
        self.$questionContainer = $('.question-container'),
        self.$helpContainer     = $('.help-container');

        self.$questionContainer.empty();
        self.$helpContainer.empty();

        self.num_questions     = self.questions.length;
        self.curr_question_ndx = 0;
        self.prev_question_ndx = self.num_questions -1;
        self.next_question_ndx = 1;

        $.each(self.questions, function(index, el)
        {
            var question = new global.App.question;
            question.init(self.survey_id, el, index);
            self.$questionContainer.append(question.$el);
            self.$helpContainer.append(question.$help);
            self.questionObjects.push(question);
        });

        // setup input for 1st question
        var curr_question_id = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")").attr('data-qid');
        $('input.slider:first').attr('data-qid', curr_question_id);
        $('.go-next-question').addClass('inactive');
    },


    /**
     * [init - called on document ready]
     * @return {[type]} [description]
     */
    init: function() {

        var self = this;

        self.isAnimating        = false;
        self.$questionContainer = $('.question-container');

        self.do180              = parseInt($('.procyncRoot').attr('data-do180'), 10);
        self.do360              = parseInt($('.procyncRoot').attr('data-do360'), 10);
        self.curr_step          = (!self.do180 ? '360' : '180');

        self.user_role          = $('.procyncRoot').attr('data-userrole');
        self.user_type          = $('.procyncRoot').attr('data-usertype');
        self.user_relationship  = $('.procyncRoot').attr('data-userrelationship');
        self.relationship_type  = $('.procyncRoot').attr('data-relationshiptype');

        self.agency_name        = $('.procyncRoot').attr('data-agencyname');
        self.company_name       = $('.procyncRoot').attr('data-companyname');
        self.agency_surveyid    = $('.procyncRoot').attr('data-survey_id_180');
        self.company_surveyid   = $('.procyncRoot').attr('data-survey_id_360');

        if(self.do180)
        {
            self.survey_id = self.agency_surveyid;
            $('.content-180').show();
            $('.content-360').hide();
        }
        else
        {
            self.survey_id = self.company_surveyid;
            $('.content-360').show();
            $('.content-180').hide();
        }

        $('.group-header, .procyncRoot').removeClass('group-cat1 group-cat2 group-cat3 group-cat4 group-cat5').addClass('group-cat1');

        if(!(self.do180 && self.do360)) {
            $('.reset360orExit').remove();
        }

        if(self.do180 && self.do360) {
            $('.closeWindow').hide();
        }

        $('.procyncIntro').show();
        $('.procyncIntro').css('display', 'block');

        self.answers = {};
        var $slider = $('.survey-range-slider');
        self.fetchData(function() {
            $slider.attr('data-qid', self.questionObjects[0].question_id);
        });
        self.bindEvents();
        self.setTitle();


        var rangeslider_options = {

            polyfill: false,
            rangeClass: 'rangeslider',
            fillClass: 'rangeslider__fill',
            handleClass: 'rangeslider__handle',

            onInit: function() {},
            onSlide: function(position, value) {

                this.$element.siblings('.input-val').html(value.toFixed(1));
                if($('.go-next-question').hasClass('inactive')) {
                    $('.go-next-question').removeClass('inactive');
                }
            }
        }

        if(global.platform.name === "IE" && parseInt(global.platform.version, 10) < 10) {
            rangeslider_options.polyfill = true;
        }

        $('input.slider').rangeslider(rangeslider_options);

        console.log('platform', platform.name);
        if (platform.name === 'Safari' && platform.os.family === 'iOS' && parseInt(platform.os.version, 10) > 7 || platform.ua.indexOf('like Mac OS X') != -1) {
            $('.lower-inputs').css('bottom', '8rem');
        }

    },

    /**
     * [reset360orExit - similar to above - called on transition from 180 to 360]
     * @return {[type]} [description]
     */
    reset360orExit: function() {

        var self = this;

        $('input.slider').bind("change paste keyup", function() {
            $('.input-val').html($('input.slider').val());
        });

        $('.group-header, .procyncRoot').removeClass('group-cat1 group-cat2 group-cat3 group-cat4 group-cat5').addClass('group-cat1');

        // reset all the things
        if(self.relationship_type === '360') {

            if(self.curr_step === '180') {

                self.curr_step = '360';

                // $('.main-content').show();
                $('.posted-answers').empty();
                $('.answers').hide();
                $('.reset360orExit').remove();
                $('.closeWindow').show();

                $('.content-360').show();
                $('.content-180').hide();

                $('.login-content2').hide();
                $('.login-content').show();

                $('.login-action2').hide();
                $('.login-action').show();
                $('.lower-inputs').show();

                $('.category-navigation-container').show();
                $('.groups-nav').show();

                $('.procyncIntro').show();

                // FFF
                self.survey_id        = self.company_surveyid;

                self.answers   = {};
                self.groups    = self.company_groups;
                self.questions = self.company_questions;

                self.initGroups();
                self.initQuestions();
                self.setTitle();

                self.setContentTopMargin();
            }

        } else if(self.relationship_type === '180') {

            console.log('Error: this is a 180');
        }
    },

    /**
     * [updateNav - uses for updating navbar when current question group changes]
     * @param  {[type]} $curr_el [description]
     * @return {[type]}          [description]
     */
    updateNav: function($curr_el) {

        var self = this;

        // get current question group attributes
        var curr_question_group = $curr_el.attr('data-gid');
        var li_ndx              = _.indexOf(self.group_gids, curr_question_group);

        var $curr_group_questions = $('.question-container li[data-gid="'+curr_question_group+'"]');
        var q_num               = 0;

        if(!$curr_group_questions.hasClass('current')) {
            console.log('weirdness - no current in .current group ??? ', $(this));
            return false;
        }

        $curr_group_questions.each(function() {

            if($(this).hasClass('current')) { return false;}
            q_num++;
        });

        self.group_last_question[curr_question_group] = self.curr_question_ndx;
        console.log('last questions', self.group_last_question);

        var increment = li_ndx+1;
        var new_class_name = (self.curr_step === '180' ? 'group-cat'+increment : 'group360-cat'+increment);

        var all_group_cat_classes = 'group-cat1 group-cat2 group-cat3 group-cat4 group-cat5 group360-cat1 group360-cat2 group360-cat3';
        $('.group-header, .procyncRoot').removeClass(all_group_cat_classes).addClass(new_class_name);
        if(curr_question_group !== self.curr_group)
        {
            // update group-header
            $('.group-header').html(self.groups[li_ndx].group.group_name).attr('data-group-id', self.groups[li_ndx].group.id.gid);

            // get prev group li ndx
            var prev_li_ndx = _.indexOf(self.group_gids, self.curr_group);

            // reset prev group
            $('.groups-nav ul li:eq('+prev_li_ndx+')').removeClass('active');
            $('.groups-nav ul li:eq('+li_ndx+')').addClass('active');
            $('.groups-nav ul li:eq('+prev_li_ndx+') a').html(self.groups[prev_li_ndx].num_questions);
            self.curr_group = curr_question_group;

            // update previous background class
            $('.nav-background[data-ndx='+prev_li_ndx+']').removeClass('active');
            $('.nav-background[data-ndx='+li_ndx+']').addClass('active');
        }

        var group_text = (q_num+1)+'/'+self.groups[li_ndx].num_questions;
        $('.groups-nav ul li:eq('+li_ndx+') a').html(group_text);
    },

    /**
     * [goToQuestion - go to a specific question without doing any animations]
     * called when :
     *     1) selecting a different group in the navbar
     *     2) found somethng incomplete upon saving answers
     *
     * @param  {[type]} question_ndx [description]
     * @param  {[type]} $nav_el      [description]
     * @return {[type]}              [description]
     */
    goToQuestion: function(question_ndx, $nav_el) {

        var self = this;
        console.log('ndx', question_ndx);

        if(question_ndx !== -1) {

            // reset markers
            self.curr_question_ndx = question_ndx;
            self.prev_question_ndx = (self.curr_question_ndx > 0 ? self.curr_question_ndx - 1 : self.num_questions - 1);
            self.next_question_ndx = (self.curr_question_ndx < self.num_questions - 1 ? self.curr_question_ndx + 1 : 0);

            // reset li next previous
            self.$questionContainer.find("li").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');
            self.$helpContainer.find("li").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');

            // reset current
            var $new_prev_el;
            if(self.prev_question_ndx !== self.num_questions - 1) {
                $new_prev_el = self.$questionContainer.find("li:eq("+self.prev_question_ndx+")");
                $new_prev_el.removeClass("inactive").addClass('previous');
            }

            var $new_curr_el = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")");
            var $new_curr_help_el = self.$helpContainer.find("li:eq("+self.curr_question_ndx+")");
            $new_curr_el.removeClass("inactive").addClass('current');
            $new_curr_help_el.addClass('current');
            $new_curr_el.css('opacity', 1);

            var $new_next_el;
            if(self.next_question_ndx !== 0) {
                $new_next_el = self.$questionContainer.find("li:eq("+self.next_question_ndx+")");
                $new_next_el.removeClass("inactive").addClass('next');
            }

            var curr_question_id = $new_curr_el.attr('data-qid');
            $('input.slider').attr('data-qid', curr_question_id);

            // set input value
            if(self.answers.hasOwnProperty(curr_question_id))
            {
                $('input.slider').val(self.answers[curr_question_id]);
                $('.input-val').html($('input.slider').val());
            }

            self.updateNav($new_curr_el);
        }

        $('.groups-nav li').removeClass('active');
        $nav_el.closest('li').addClass('active');
    },

    /**
     * [nextAnim - move forward]
     * used by nextQuestion
     * @return {[type]} [description]
     */
    nextAnim: function() {

        var self = this;

        var $helpContainer     = $('.help-container');

        // remove old prev
        if(self.next_question_ndx !== 0)
        {
            var $old_prev_el = self.$questionContainer.find("li:eq("+self.prev_question_ndx+")");
            TweenLite.to($old_prev_el, 0, {autoAlpha:0, className:"inactive"});
        }

        // update li's ndx's
        self.curr_question_ndx = (self.curr_question_ndx + 1 > self.num_questions - 1 ? 0 : self.curr_question_ndx + 1);
        self.prev_question_ndx = (self.prev_question_ndx + 1 > self.num_questions - 1 ? 0 : self.prev_question_ndx + 1);
        self.next_question_ndx = (self.next_question_ndx + 1 > self.num_questions - 1 ? 0 : self.next_question_ndx + 1);

        // add new prev
        var $new_prev_el = self.$questionContainer.find("li:eq("+self.prev_question_ndx+")");
        TweenLite.to($new_prev_el, 0.5, {autoAlpha:1, className:"previous"});

        // curr help
        self.$helpContainer.find("li").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');
        var $new_curr_help_el = self.$helpContainer.find("li:eq("+self.curr_question_ndx+")");
        $new_curr_help_el.addClass('current');

        // add new current
        var $new_curr_el = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")");
        TweenLite.to($new_curr_el, 0.5, {autoAlpha:1, className:"current"});

        // add new next
        if(self.next_question_ndx !== 0) {
            var $new_next_el = self.$questionContainer.find("li:eq("+self.next_question_ndx+")");
            TweenLite.to($new_next_el, 0, {autoAlpha:0, className:"next"});
        }
        //TweenLite.to($('#question-container'), 0.2, {top: 0 - $new_prev_el.position().top});

        setTimeout(function() {
            self.updateNav($new_curr_el);
        }, 700);

    },

    /**
     * [prevAnim - move back]
     * used by prevQuestion
     * @return {[type]} [description]
     */
    prevAnim: function() {

        var self = this;

        var $helpContainer     = $('.help-container');

        // remove old next
        var $old_next_el = self.$questionContainer.find("li:eq("+self.next_question_ndx+")");
        TweenLite.to($old_next_el, 0, {autoAlpha:0, className:"inactive"});

        // update li ndx's
        self.curr_question_ndx = (self.curr_question_ndx - 1 < 0 ? self.num_questions - 1 : self.curr_question_ndx - 1);
        self.prev_question_ndx = (self.prev_question_ndx - 1 < 0 ? self.num_questions - 1 : self.prev_question_ndx - 1);
        self.next_question_ndx = (self.next_question_ndx - 1 < 0 ? self.num_questions - 1 : self.next_question_ndx - 1);

        console.log('prev anim ndxs', self.curr_question_ndx, self.prev_question_ndx, self.next_question_ndx);

        // add new next
        var $new_next_el = self.$questionContainer.find("li:eq("+self.next_question_ndx+")");
        TweenLite.to($new_next_el, 0.5, {autoAlpha:1, className:"next"});

        // curr help
        $helpContainer.find("li").removeClass('next').removeClass('previous').removeClass('current').removeClass('inactive').addClass('inactive');
        var $new_curr_help_el = self.$helpContainer.find("li:eq("+self.curr_question_ndx+")");
        $new_curr_help_el.addClass('current');

        // add new curr
        var $new_curr_el = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")");
        TweenLite.to($new_curr_el, 0.5, {autoAlpha:1, className:"current"});

        // add new prev
        if(self.prev_question_ndx !== self.num_questions - 1) {
            var $new_prev_el = self.$questionContainer.find("li:eq("+self.prev_question_ndx+")");
            TweenLite.to($new_prev_el, 0, {autoAlpha:0, className:"previous"});
        }

        var $discount_el = ($new_prev_el ? $new_prev_el : $new_curr_el);
        //TweenLite.to($('#question-container'), 0.2, {top: 0 - $discount_el.position().top});

        setTimeout(function() {
            self.updateNav($new_curr_el);
        }, 700);
    },

    /**
     * [nextQuestion - go forward by 1 question]
     * @return {[type]} [description]
     */
    nextQuestion: function() {

        var self = this,
        $slider = $('.survey-range-slider'),
        $sliderValueContainer = $slider.prev('.input-val');
        self.isAnimating = true;

        // get input value
        var answer_val = $slider.val();
        var answer_id = $slider.attr('data-qid');
        self.answers[answer_id] = answer_val;

        // last question
        if(self.curr_question_ndx === self.num_questions-1) {

            var $el = self.verifyAnswers();
            if($el === false)
            {
                $('.main-content').hide();
                $('.lower-inputs').hide();
                self.saveAnswers();

            } else {

                console.log('going to missed question');

                var question_ndx = $el.index();
                var group_id = $el.attr('data-gid');
                var $nav_el = $(".groups-nav a[data-gid="+group_id+"]");
                self.goToQuestion(question_ndx, $nav_el);
            }

        // just another question
        } else {

            self.nextAnim();

            // set input qid
            var curr_question_id = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")").attr('data-qid');
            $slider.attr('data-qid', curr_question_id);

            // set input value
            if(self.answers.hasOwnProperty(curr_question_id)) {
                $slider.val(self.answers[curr_question_id]);
            } else {
                $slider.val(5);
            }

            $sliderValueContainer.html($slider.val());
            //history.pushState({q_ndx: self.curr_question_ndx}, null, null);
            History.pushState({q_ndx: self.curr_question_ndx}, null, null);
        }

        $('input[type="range"]').rangeslider('update', true);
        $('.go-next-question').addClass('inactive');

        self.isAnimating = false;
    },

    /**
     * [prevQuestion - go back by 1 question]
     * @return {[type]} [description]
     */
    prevQuestion: function() {

        var self = this,
            $slider = $('.survey-range-slider'),
            $sliderValueContainer = $slider.prev('.input-val');

        self.isAnimating = true;
        if(self.curr_question_ndx !== 0) {

            self.prevAnim();
            var curr_question_id = self.$questionContainer.find("li:eq("+self.curr_question_ndx+")").attr('data-qid');
            $slider.attr('data-qid', curr_question_id);

            // set input value
            if(self.answers.hasOwnProperty(curr_question_id))
            {
                $slider.val(self.answers[curr_question_id]);
                $sliderValueContainer.html($slider.val());
            }

            $(window).trigger("popstate");
        }

        $('input[type="range"]').rangeslider('update', true);
        self.isAnimating = false;
    },

    verifyAnswers: function() {

        var self = this;

        console.log('all qo', self.questionObjects, self.answers);
        for(var qo in self.questionObjects)
        {
            console.log('>>> qo ', self.answers[self.questionObjects[qo].question_id], self.questionObjects[qo].question_id);
            if(self.answers[self.questionObjects[qo].question_id] === undefined)
            {
                var $el = self.$questionContainer.find("li[data-qid="+self.questionObjects[qo].question_id+"]");
                if($el.length > 0) {
                    return $el;
                }
                else {
                    return false;
                }
            }
        }

        return false;
    },

    /**
     * [saveAnswers description]
     * @return {[type]} [description]
     */
    saveAnswers: function() {

        var self = this;

        var post_data = {};
        $.extend(true, post_data, self.answers, {action: 'postAnswers', limesurvey_id: self.survey_id, evaluation_id: self.user_relationship, step: self.curr_step});
        $('.posted-answers').empty();

        var response_status;
        $.when(self.exchangeData(post_data, response_status)).done(function(data) {

            console.log('answers response', data);
            if(data.status === 'OK')
            {
                $('.category-navigation-container').hide();
                $('.groups-nav').hide();
                $('.answers').show();

                console.log('Responses saved');
            }
            else
            {
                console.log('ERROR', data.message);
            }
        });
    },

    /**
     * [setContentTopMargin description]
     */
    setContentTopMargin: function() {

        var self = this;
        $(document).on('click', 'button.login-action2', function() {

            var self = this;
            var groups_height = $('.nav-background:first').height();

            $('.groups-nav').height(groups_height);
            $('.groups-ul').height(groups_height);

        })
    },


    /**
     * [setTitle description]
     */
    setTitle: function()
    {
        var self = this;
        var title_str = '';

        if(self.curr_step === '180')
        {
            title_str = self.agency_name;
        }
        else if(self.curr_step === '360')
        {
            title_str = self.company_name;
        }
        else
        {
            title_str = 'Error';
        }

        $('.rel-title').html(title_str);
    },


    /**
     * [bindEvents - bind all required events]
     * @return {[type]} [description]
     */
    bindEvents: function() {

        var self = this;

        // orientation lock
        $(window).bind('orientationchange', function(e) {

            switch ( window.orientation ) {
                case 0:
                    $('.turnDeviceNotification').css('display', 'none');
                    // The device is in portrait mode now
                    break;

                case 180:
                    $('.turnDeviceNotification').css('display', 'none');
                    // The device is in portrait mode now
                    break;

                case 90:
                    // The device is in landscape now
                    $('.turnDeviceNotification').css('display', 'block');
                    break;

                case -90:
                    // The device is in landscape now
                    $('.turnDeviceNotification').css('display', 'block');
                    break;
            }

        });

        // intro setup
        if($('.procyncIntro').length) {

            $('body').on('click', '.login-action', function(ev)
            {
                ev.preventDefault();
                $('.login-content').hide();
                $('.login-content2').show();
                $('.login-action').hide();
                $('.login-action2').show();
            });

            $('body').on('click', '.login-action2', function(ev)
            {
                ev.preventDefault();
                $('.question-container').css('top', 0);
                $('.procyncIntro').hide();
                $('.main-content').show();
                $('.procyncRoot').show();
                self.setContentTopMargin();
            });
        }

        // main questionaire setup
        if($('.procyncRoot').length) {

            // Bind to StateChange Event - this is meant to use statechange but thta fires all the time :(
            History.Adapter.bind(window, 'statechange', function(evt){ // Note: We are using statechange instead of popstate
                var State = History.getState(); // Note: We are using History.getState() instead of event.state
                //History.log(State.data, State.title, State.url);

                var question_ndx = State.data.q_ndx;
                var group_id = self.$questionContainer.find("li:eq("+question_ndx+")").attr('data-gid');
                var $nav_el = $(".groups-nav a[data-gid="+group_id+"]");
                //self.goToQuestion(State.q_ndx, $nav_el);

                console.log('popstate', question_ndx, State);
            });

            // // back button browser history
            // window.addEventListener("popstate", function(e) {

            //     e.preventDefault();

            //     var question_ndx = e.state.q_ndx;
            //     var group_id = self.$questionContainer.find("li:eq("+question_ndx+")").attr('data-gid');
            //     var $nav_el = $(".groups-nav a[data-gid="+group_id+"]");
            //     self.goToQuestion(e.state.q_ndx, $nav_el);

            //     return true;
            // });

            $(window).resize(function() {
                self.setContentTopMargin();
            });

            $('body').on('click','.reset360orExit', function(ev) {
                ev.preventDefault();
                self.reset360orExit();
            });

            $('body').on('click','.go-prev-question', function() {
                self.prevQuestion();
            });

            $('body').on('click','.go-next-question', function() {

                if($('.go-next-question').hasClass('inactive')) {
                    $('.go-next-question').removeClass('inactive');
                } else {
                    self.nextQuestion();
                }
            });

            $('.help-toggle').click(function(evt) {
                evt.preventDefault();
                var $help_status = $('.help-container').find('.current');
                if($help_status.hasClass('inactive')) {
                    $help_status.removeClass('inactive');
                } else {
                    $help_status.addClass('inactive');
                }

            });

            $('body').on('click', '.groups-nav a', function(ev) {

                var $el = $(this);

                ev.preventDefault();
                var gid = $(this).attr('data-gid');

                // find last answered question with within group
                // var question_ndx = self.$questionContainer.find("li[data-gid="+gid+"]:first").index();
                var question_ndx = self.group_last_question[gid];
                if(-1 === question_ndx) {
                    return false;
                } else {
                    self.goToQuestion(question_ndx, $el);
                }

            });
        }
    }
};

module.exports = new Survey();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"underscore":2}]},{},[1])


//# sourceMappingURL=scripts.min.js.map